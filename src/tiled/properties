moc_terraindock.cpp:        - idx * sizeof(QByteArrayData) \
moc_terraindock.cpp:        case 0: _t->currentTerrainChanged((*reinterpret_cast< const Terrain*(*)>(_a[1]))); break;
moc_terraindock.cpp:        case 1: _t->currentRowChanged((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_terraindock.cpp:        case 2: _t->indexPressed((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_terraindock.cpp:        case 3: _t->expandRows((*reinterpret_cast< const QModelIndex(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_terraindock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_terraindock.cpp:        _id -= 4;
moc_terraindock.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_terraindock.cpp:        _id -= 4;
patreondialog.cpp:    ui->setupUi(this);
patreondialog.cpp:    ui->maybeLaterButton->setVisible(false);
patreondialog.cpp:    connect(ui->gotoPatreon, SIGNAL(clicked()), SLOT(openPatreonPage()));
patreondialog.cpp:    connect(ui->alreadyPatron, SIGNAL(clicked()), SLOT(togglePatreonStatus()));
patreondialog.cpp:    prefs->setPatron(!prefs->isPatron());
patreondialog.cpp:    if (Preferences::instance()->isPatron()) {
patreondialog.cpp:        ui->textBrowser->setHtml(tr(
patreondialog.cpp:        ui->alreadyPatron->setText(tr("I'm no longer a patron"));
patreondialog.cpp:        ui->textBrowser->setHtml(tr(
patreondialog.cpp:        ui->alreadyPatron->setText(tr("I'm already a patron!"));
addremovelayer.cpp:    const int currentLayer = mMapDocument->currentLayerIndex();
addremovelayer.cpp:    mMapDocument->layerModel()->insertLayer(mIndex, mLayer);
addremovelayer.cpp:        mMapDocument->setCurrentLayerIndex(currentLayer + 1);
addremovelayer.cpp:    const int currentLayer = mMapDocument->currentLayerIndex();
addremovelayer.cpp:    mLayer = mMapDocument->layerModel()->takeLayerAt(mIndex);
addremovelayer.cpp:        mMapDocument->setCurrentLayerIndex(currentLayer - 1);
terrainbrush.h: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
newmapdialog.ui:<?xml version="1.0" encoding="UTF-8"?>
Binary file moc_zoomable.o matches
Binary file tilesetchanges.o matches
Binary file tilesetdock.o matches
Binary file minimapdock.o matches
addremovemapobject.cpp:    , mIndex(-1)
addremovemapobject.cpp:    mMapDocument->mapObjectModel()->insertObject(mObjectGroup, mIndex,
addremovemapobject.cpp:    mIndex = mMapDocument->mapObjectModel()->removeObject(mObjectGroup,
addremovemapobject.cpp:                         mapObject->objectGroup(),
moc_terrainmodel.cpp:        - idx * sizeof(QByteArrayData) \
moc_terrainmodel.cpp:        case 0: _t->terrainAdded((*reinterpret_cast< Tileset*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_terrainmodel.cpp:        case 1: _t->terrainRemoved((*reinterpret_cast< Terrain*(*)>(_a[1]))); break;
moc_terrainmodel.cpp:        case 2: _t->terrainChanged((*reinterpret_cast< Tileset*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_terrainmodel.cpp:        case 3: _t->tilesetAboutToBeAdded((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_terrainmodel.cpp:        case 4: _t->tilesetAdded(); break;
moc_terrainmodel.cpp:        case 5: _t->tilesetAboutToBeRemoved((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_terrainmodel.cpp:        case 6: _t->tilesetRemoved(); break;
moc_terrainmodel.cpp:        case 7: _t->tilesetNameChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_terrainmodel.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_terrainmodel.cpp:        _id -= 8;
moc_terrainmodel.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_terrainmodel.cpp:        _id -= 8;
Binary file movemapobjecttogroup.o matches
automappingmanager.h: * Copyright 2010-2011, Stefan Beller, stefanbeller@googlemail.com
Binary file qrc_qtpropertybrowser.o matches
Binary file moc_tileselectionitem.o matches
Binary file moc_tilesetmodel.o matches
Binary file tilestamp.o matches
Binary file moc_tileanimationdriver.o matches
moc_undodock.cpp:        - idx * sizeof(QByteArrayData) \
moc_undodock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
tilestamp.h:        Q_ASSERT(map->layerCount() == 1);
tilestamp.h:        Q_ASSERT(map->layerAt(0)->isTileLayer());
documentmanager.cpp:        mLabel->setText(tr("File change detected. Discard changes and reload the map?"));
documentmanager.cpp:        layout->addWidget(mLabel);
documentmanager.cpp:        layout->addStretch(1);
documentmanager.cpp:        layout->addWidget(mButtons);
documentmanager.cpp:        mWarning->setVisible(false);
documentmanager.cpp:        layout->setMargin(0);
documentmanager.cpp:        layout->setSpacing(0);
documentmanager.cpp:        layout->addWidget(mapView);
documentmanager.cpp:        layout->addWidget(mWarning);
documentmanager.cpp:    { mWarning->setVisible(visible); }
documentmanager.cpp:    mTabWidget->setDocumentMode(true);
documentmanager.cpp:    mTabWidget->setTabsClosable(true);
documentmanager.cpp:    const int index = mTabWidget->currentIndex();
documentmanager.cpp:    if (index == -1)
documentmanager.cpp:    if (QWidget *widget = mTabWidget->currentWidget())
documentmanager.cpp:        return static_cast<MapViewContainer*>(widget)->mapView();
documentmanager.cpp:        return mapView->mapScene();
documentmanager.cpp:    if (index == -1)
documentmanager.cpp:    return static_cast<MapViewContainer*>(mTabWidget->widget(index))->mapView();
documentmanager.cpp:        return -1;
documentmanager.cpp:        QFileInfo fileInfo(mDocuments.at(i)->fileName());
documentmanager.cpp:    return -1;
documentmanager.cpp:    mTabWidget->setCurrentIndex(index);
documentmanager.cpp:    if (index != -1)
documentmanager.cpp:    const int tabCount = mTabWidget->count();
documentmanager.cpp:    const int currentIndex = mTabWidget->currentIndex();
documentmanager.cpp:    switchToDocument((currentIndex > 0 ? currentIndex : tabCount) - 1);
documentmanager.cpp:    const int tabCount = mTabWidget->count();
documentmanager.cpp:    const int currentIndex = mTabWidget->currentIndex();
documentmanager.cpp:    mUndoGroup->addStack(mapDocument->undoStack());
documentmanager.cpp:    if (!mapDocument->fileName().isEmpty())
documentmanager.cpp:        mFileSystemWatcher->addPath(mapDocument->fileName());
documentmanager.cpp:    scene->setMapDocument(mapDocument);
documentmanager.cpp:    view->setScene(scene);
documentmanager.cpp:    const int documentIndex = mDocuments.size() - 1;
documentmanager.cpp:    mTabWidget->addTab(container, mapDocument->displayName());
documentmanager.cpp:    mTabWidget->setTabToolTip(documentIndex, mapDocument->fileName());
documentmanager.cpp:    const int index = mTabWidget->currentIndex();
documentmanager.cpp:    if (index == -1)
documentmanager.cpp:    QWidget *mapViewContainer = mTabWidget->widget(index);
documentmanager.cpp:    mTabWidget->removeTab(index);
documentmanager.cpp:    if (!mapDocument->fileName().isEmpty())
documentmanager.cpp:        mFileSystemWatcher->removePath(mapDocument->fileName());
documentmanager.cpp:    const int index = mTabWidget->currentIndex();
documentmanager.cpp:    if (index == -1)
documentmanager.cpp:    MapDocument *newDocument = MapDocument::load(oldDocument->fileName(),
documentmanager.cpp:                                                 oldDocument->readerFormat(),
documentmanager.cpp:        emit reloadError(tr("%1:\n\n%2").arg(oldDocument->fileName(), error));
documentmanager.cpp:    const int layerIndex = oldDocument->currentLayerIndex();
documentmanager.cpp:    const qreal scale = mapView->zoomable()->scale();
documentmanager.cpp:    const int horizontalPosition = mapView->horizontalScrollBar()->sliderPosition();
documentmanager.cpp:    const int verticalPosition = mapView->verticalScrollBar()->sliderPosition();
documentmanager.cpp:    mTabWidget->moveTab(mDocuments.size() - 1, index);
documentmanager.cpp:    mapView->zoomable()->setScale(scale);
documentmanager.cpp:    mapView->horizontalScrollBar()->setSliderPosition(horizontalPosition);
documentmanager.cpp:    mapView->verticalScrollBar()->setSliderPosition(verticalPosition);
documentmanager.cpp:    if (layerIndex > 0 && layerIndex < newDocument->map()->layerCount())
documentmanager.cpp:        newDocument->setCurrentLayerIndex(layerIndex);
documentmanager.cpp:        MapScene *mapScene = mViewWithTool->mapScene();
documentmanager.cpp:        mapScene->disableSelectedTool();
documentmanager.cpp:        mUndoGroup->setActiveStack(mapDocument->undoStack());
documentmanager.cpp:        MapScene *mapScene = mapView->mapScene();
documentmanager.cpp:        mapScene->setSelectedTool(mSelectedTool);
documentmanager.cpp:        mapScene->enableSelectedTool();
documentmanager.cpp:            mapView->viewport()->setCursor(mSelectedTool->cursor());
documentmanager.cpp:            mapView->viewport()->unsetCursor();
documentmanager.cpp:        MapScene *mapScene = mViewWithTool->mapScene();
documentmanager.cpp:        mapScene->disableSelectedTool();
documentmanager.cpp:            mapScene->setSelectedTool(tool);
documentmanager.cpp:            mapScene->enableSelectedTool();
documentmanager.cpp:            mViewWithTool->viewport()->setCursor(tool->cursor());
documentmanager.cpp:            mViewWithTool->viewport()->unsetCursor();
documentmanager.cpp:        mFileSystemWatcher->addPath(fileName);
documentmanager.cpp:        mFileSystemWatcher->removePath(oldFileName);
documentmanager.cpp:    QString tabText = mapDocument->displayName();
documentmanager.cpp:    if (mapDocument->isModified())
documentmanager.cpp:    mTabWidget->setTabText(index, tabText);
documentmanager.cpp:    mTabWidget->setTabToolTip(index, mapDocument->fileName());
documentmanager.cpp:    Q_ASSERT(index != -1);
documentmanager.cpp:    QWidget *widget = mTabWidget->widget(index);
documentmanager.cpp:    container->setFileChangedWarningVisible(false);
documentmanager.cpp:    if (index == -1)
documentmanager.cpp:    if (QFileInfo(fileName).lastModified() == document->lastSaved())
documentmanager.cpp:    if (!document->isModified()) {
documentmanager.cpp:    QWidget *widget = mTabWidget->widget(index);
documentmanager.cpp:    container->setFileChangedWarningVisible(true);
documentmanager.cpp:    int index = mTabWidget->indexOf(static_cast<MapViewContainer*>(sender()));
documentmanager.cpp:    Q_ASSERT(index != -1);
documentmanager.cpp:        mViewWithTool->viewport()->setCursor(cursor);
documentmanager.cpp:    view->centerOn(currentDocument()->renderer()->pixelToScreenCoords(x, y));
createrectangleobjecttool.cpp:    setIcon(QIcon(QLatin1String(":images/24x24/insert-rectangle.png")));
createrectangleobjecttool.cpp:    Utils::setThemeIcon(this, "insert-rectangle");
createrectangleobjecttool.cpp:    newMapObject->setShape(MapObject::Rectangle);
Binary file moc_editterraindialog.o matches
tilelayeritem.cpp: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tilelayeritem.cpp:    setOpacity(mLayer->opacity());
tilelayeritem.cpp:    setPos(mLayer->offset());
tilelayeritem.cpp:    MapRenderer *renderer = mMapDocument->renderer();
tilelayeritem.cpp:    QRectF boundingRect = renderer->boundingRect(mLayer->bounds());
tilelayeritem.cpp:    QMargins margins = mLayer->drawMargins();
tilelayeritem.cpp:    if (const Map *map = mLayer->map()) {
tilelayeritem.cpp:        margins.setTop(margins.top() - map->tileHeight());
tilelayeritem.cpp:        margins.setRight(margins.right() - map->tileWidth());
tilelayeritem.cpp:    mBoundingRect = boundingRect.adjusted(-margins.left(),
tilelayeritem.cpp:                                          -margins.top(),
tilelayeritem.cpp:    MapRenderer *renderer = mMapDocument->renderer();
tilelayeritem.cpp:    renderer->drawTileLayer(painter, mLayer, option->exposedRect);
Binary file moc_offsetmapdialog.o matches
Binary file moc_mapsdock.o matches
Binary file commanddatamodel.o matches
Binary file moc_tilestampmodel.o matches
Binary file abstracttool.o matches
qteditorfactory.moc:        - idx * sizeof(QByteArrayData) \
qteditorfactory.moc:        case 0: _t->valueChanged((*reinterpret_cast< const QChar(*)>(_a[1]))); break;
qteditorfactory.moc:        case 1: _t->setValue((*reinterpret_cast< const QChar(*)>(_a[1]))); break;
qteditorfactory.moc:        case 2: _t->slotClearChar(); break;
qteditorfactory.moc:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
qteditorfactory.moc:        _id -= 3;
qteditorfactory.moc:            *reinterpret_cast<int*>(_a[0]) = -1;
qteditorfactory.moc:        _id -= 3;
qteditorfactory.moc:        - idx * sizeof(QByteArrayData) \
qteditorfactory.moc:        case 0: _t->valueChanged((*reinterpret_cast< const QColor(*)>(_a[1]))); break;
qteditorfactory.moc:        case 1: _t->setValue((*reinterpret_cast< const QColor(*)>(_a[1]))); break;
qteditorfactory.moc:        case 2: _t->buttonClicked(); break;
qteditorfactory.moc:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
qteditorfactory.moc:        _id -= 3;
qteditorfactory.moc:            *reinterpret_cast<int*>(_a[0]) = -1;
qteditorfactory.moc:        _id -= 3;
qteditorfactory.moc:        - idx * sizeof(QByteArrayData) \
qteditorfactory.moc:        case 0: _t->valueChanged((*reinterpret_cast< const QFont(*)>(_a[1]))); break;
qteditorfactory.moc:        case 1: _t->setValue((*reinterpret_cast< const QFont(*)>(_a[1]))); break;
qteditorfactory.moc:        case 2: _t->buttonClicked(); break;
qteditorfactory.moc:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
qteditorfactory.moc:        _id -= 3;
qteditorfactory.moc:            *reinterpret_cast<int*>(_a[0]) = -1;
qteditorfactory.moc:        _id -= 3;
abstractobjecttool.cpp:    switch (event->key()) {
abstractobjecttool.cpp:    event->ignore();
abstractobjecttool.cpp:        offsetPos -= layer->offset();
abstractobjecttool.cpp:    const QPointF tilePosF = mapDocument()->renderer()->screenToTileCoords(offsetPos);
abstractobjecttool.cpp:    if (event->button() == Qt::RightButton) {
abstractobjecttool.cpp:        showContextMenu(topMostObjectItemAt(event->scenePos()),
abstractobjecttool.cpp:                        event->screenPos());
abstractobjecttool.cpp:    return dynamic_cast<ObjectGroup*>(mapDocument()->currentLayer());
abstractobjecttool.cpp:    foreach (QGraphicsItem *item, mMapScene->items(pos)) {
abstractobjecttool.cpp:    mapDocument()->duplicateObjects(mapDocument()->selectedObjects());
abstractobjecttool.cpp:    mapDocument()->removeObjects(mapDocument()->selectedObjects());
abstractobjecttool.cpp:    mapDocument()->flipSelectedObjects(FlipHorizontally);
abstractobjecttool.cpp:    mapDocument()->flipSelectedObjects(FlipVertically);
abstractobjecttool.cpp:    QSet<MapObjectItem *> selection = mMapScene->selectedObjectItems();
abstractobjecttool.cpp:        mMapScene->setSelectedObjectItems(selection);
abstractobjecttool.cpp:    const QList<MapObject*> &selectedObjects = mapDocument()->selectedObjects();
abstractobjecttool.cpp:    const QList<ObjectGroup*> objectGroups = mapDocument()->map()->objectGroups();
abstractobjecttool.cpp:    duplicateAction->setIcon(QIcon(QLatin1String(":/images/16x16/stock-duplicate-16.png")));
abstractobjecttool.cpp:    removeAction->setIcon(QIcon(QLatin1String(":/images/16x16/edit-delete.png")));
abstractobjecttool.cpp:    if (objectGroup && objectGroup->drawOrder() == ObjectGroup::IndexOrder) {
abstractobjecttool.cpp:            QAction *action = moveToLayerMenu->addAction(objectGroup->name());
abstractobjecttool.cpp:            action->setData(QVariant::fromValue(objectGroup));
abstractobjecttool.cpp:    QIcon propIcon(QLatin1String(":images/16x16/document-properties.png"));
abstractobjecttool.cpp:    propertiesAction->setEnabled(selectedObjects.size() == 1);
abstractobjecttool.cpp:    Utils::setThemeIcon(removeAction, "edit-delete");
abstractobjecttool.cpp:    Utils::setThemeIcon(propertiesAction, "document-properties");
abstractobjecttool.cpp:        mapDocument()->setCurrentObject(mapObject);
abstractobjecttool.cpp:        mapDocument()->emitEditCurrentObject();
abstractobjecttool.cpp:    if (ObjectGroup *objectGroup = action->data().value<ObjectGroup*>()) {
abstractobjecttool.cpp:        mapDocument()->moveObjectsToGroup(mapDocument()->selectedObjects(),
minimapdock.cpp:    mMiniMap->setMapDocument(map);
minimapdock.cpp:    switch (e->type()) {
minimapdock.cpp:    setWindowTitle(tr("Mini-map"));
preferences.cpp: * Copyright 2009-2011, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
preferences.cpp:    mSettings->beginGroup(QLatin1String("Storage"));
preferences.cpp:    mSettings->endGroup();
preferences.cpp:    mSettings->beginGroup(QLatin1String("Interface"));
preferences.cpp:    mSettings->endGroup();
preferences.cpp:    mSettings->beginGroup(QLatin1String("ObjectTypes"));
preferences.cpp:            mSettings->value(QLatin1String("Names")).toStringList();
preferences.cpp:            mSettings->value(QLatin1String("Colors")).toStringList();
preferences.cpp:    mSettings->endGroup();
preferences.cpp:    mSettings->beginGroup(QLatin1String("Automapping"));
preferences.cpp:    mSettings->endGroup();
preferences.cpp:    mSettings->beginGroup(QLatin1String("MapsDirectory"));
preferences.cpp:    mSettings->endGroup();
preferences.cpp:    tilesetManager->setReloadTilesetsOnChange(mReloadTilesetsOnChange);
preferences.cpp:    tilesetManager->setAnimateTiles(mShowTileAnimations);
preferences.cpp:    mSettings->beginGroup(QLatin1String("Install"));
preferences.cpp:    mFirstRun = mSettings->value(QLatin1String("FirstRun")).toDate();
preferences.cpp:        mSettings->setValue(QLatin1String("FirstRun"), mFirstRun.toString(Qt::ISODate));
preferences.cpp:    mSettings->setValue(QLatin1String("RunCount"), mRunCount);
preferences.cpp:    mSettings->endGroup();
preferences.cpp:    mSettings->beginGroup(QLatin1String("Startup"));
preferences.cpp:    mSettings->endGroup();
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/ObjectLabelVisibility"), visibility);
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/ShowGrid"), mShowGrid);
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/ShowTileObjectOutlines"),
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/ShowTileAnimations"),
preferences.cpp:    tilesetManager->setAnimateTiles(mShowTileAnimations);
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/SnapToGrid"), mSnapToGrid);
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/SnapToFineGrid"), mSnapToFineGrid);
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/GridColor"), mGridColor.name());
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/GridFine"), mGridFine);
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/ObjectLineWidth"), mObjectLineWidth);
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/HighlightCurrentLayer"),
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/ShowTilesetGrid"),
preferences.cpp:    mSettings->setValue(QLatin1String("Storage/LayerDataFormat"),
preferences.cpp:    mSettings->setValue(QLatin1String("Storage/MapRenderOrder"),
preferences.cpp:    mSettings->setValue(QLatin1String("Storage/DtdEnabled"), enabled);
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/Language"),
preferences.cpp:    LanguageManager::instance()->installTranslators();
preferences.cpp:    mSettings->setValue(QLatin1String("Storage/ReloadTilesets"),
preferences.cpp:    tilesetManager->setReloadTilesetsOnChange(mReloadTilesetsOnChange);
preferences.cpp:    mSettings->setValue(QLatin1String("Interface/OpenGL"), mUseOpenGL);
preferences.cpp:    mSettings->beginGroup(QLatin1String("ObjectTypes"));
preferences.cpp:    mSettings->setValue(QLatin1String("Names"), names);
preferences.cpp:    mSettings->setValue(QLatin1String("Colors"), colors);
preferences.cpp:    mSettings->endGroup();
preferences.cpp:    QString path = mSettings->value(lastPathKey(fileType)).toString();
preferences.cpp:        MapDocument *mapDocument = documentManager->currentDocument();
preferences.cpp:            path = QFileInfo(mapDocument->fileName()).path();
preferences.cpp:    mSettings->setValue(lastPathKey(fileType), path);
preferences.cpp:    mSettings->setValue(QLatin1String("Automapping/WhileDrawing"), enabled);
preferences.cpp:    mSettings->setValue(QLatin1String("MapsDirectory/Current"), path);
preferences.cpp:    mSettings->setValue(QLatin1String("Install/IsPatron"), isPatron);
preferences.cpp:    mSettings->setValue(QLatin1String("Startup/OpenLastFiles"), open);
preferences.cpp:    return mSettings->value(QLatin1String(key), defaultValue).toBool();
preferences.cpp:    const QString name = mSettings->value(QLatin1String(key),
preferences.cpp:    return mSettings->value(QLatin1String(key), def).toString();
preferences.cpp:    return mSettings->value(QLatin1String(key), defaultValue).toInt();
preferences.cpp:    return mSettings->value(QLatin1String(key), defaultValue).toReal();
preferences.cpp:    mSettings->setValue(QLatin1String("Storage/StampsDirectory"), stampsDirectory);
Binary file moc_patreondialog.o matches
moc_editpolygontool.cpp:        - idx * sizeof(QByteArrayData) \
moc_editpolygontool.cpp:        case 0: _t->updateHandles(); break;
moc_editpolygontool.cpp:        case 1: _t->objectsRemoved((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_editpolygontool.cpp:        case 2: _t->deleteNodes(); break;
moc_editpolygontool.cpp:        case 3: _t->joinNodes(); break;
moc_editpolygontool.cpp:        case 4: _t->splitSegments(); break;
moc_editpolygontool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_editpolygontool.cpp:        _id -= 5;
moc_editpolygontool.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_editpolygontool.cpp:        _id -= 5;
colorbutton.cpp:    size.rwidth() -= 2;
colorbutton.cpp:    size.rheight() -= 2;
colorbutton.cpp:    painter.drawRect(0, 0, pixmap.width() - 1, pixmap.height() - 1);
Binary file erasetiles.o matches
Binary file objectgroupitem.o matches
Binary file moc_tmxmapformat.o matches
moc_propertybrowser.cpp:        - idx * sizeof(QByteArrayData) \
moc_propertybrowser.cpp:        case 0: _t->mapChanged(); break;
moc_propertybrowser.cpp:        case 1: _t->objectsChanged((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_propertybrowser.cpp:        case 2: _t->layerChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_propertybrowser.cpp:        case 3: _t->objectGroupChanged((*reinterpret_cast< ObjectGroup*(*)>(_a[1]))); break;
moc_propertybrowser.cpp:        case 4: _t->imageLayerChanged((*reinterpret_cast< ImageLayer*(*)>(_a[1]))); break;
moc_propertybrowser.cpp:        case 5: _t->tilesetChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_propertybrowser.cpp:        case 6: _t->tileChanged((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_propertybrowser.cpp:        case 7: _t->terrainChanged((*reinterpret_cast< Tileset*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_propertybrowser.cpp:        case 8: _t->propertyAdded((*reinterpret_cast< Object*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_propertybrowser.cpp:        case 9: _t->propertyRemoved((*reinterpret_cast< Object*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_propertybrowser.cpp:        case 10: _t->propertyChanged((*reinterpret_cast< Object*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_propertybrowser.cpp:        case 11: _t->propertiesChanged((*reinterpret_cast< Object*(*)>(_a[1]))); break;
moc_propertybrowser.cpp:        case 12: _t->selectedObjectsChanged(); break;
moc_propertybrowser.cpp:        case 13: _t->selectedTilesChanged(); break;
moc_propertybrowser.cpp:        case 14: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QVariant(*)>(_a[2]))); break;
moc_propertybrowser.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_propertybrowser.cpp:        _id -= 15;
moc_propertybrowser.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_propertybrowser.cpp:        _id -= 15;
ui_preferencesdialog.h:        if (PreferencesDialog->objectName().isEmpty())
ui_preferencesdialog.h:            PreferencesDialog->setObjectName(QStringLiteral("PreferencesDialog"));
ui_preferencesdialog.h:        PreferencesDialog->resize(421, 426);
ui_preferencesdialog.h:        verticalLayout->setObjectName(QStringLiteral("verticalLayout"));
ui_preferencesdialog.h:        verticalLayout->setSizeConstraint(QLayout::SetFixedSize);
ui_preferencesdialog.h:        tabWidget->setObjectName(QStringLiteral("tabWidget"));
ui_preferencesdialog.h:        tab->setObjectName(QStringLiteral("tab"));
ui_preferencesdialog.h:        verticalLayout_2->setObjectName(QStringLiteral("verticalLayout_2"));
ui_preferencesdialog.h:        groupBox->setObjectName(QStringLiteral("groupBox"));
ui_preferencesdialog.h:        gridLayout->setObjectName(QStringLiteral("gridLayout"));
ui_preferencesdialog.h:        reloadTilesetImages->setObjectName(QStringLiteral("reloadTilesetImages"));
ui_preferencesdialog.h:        gridLayout->addWidget(reloadTilesetImages, 1, 0, 1, 2);
ui_preferencesdialog.h:        enableDtd->setObjectName(QStringLiteral("enableDtd"));
ui_preferencesdialog.h:        gridLayout->addWidget(enableDtd, 0, 0, 1, 2);
ui_preferencesdialog.h:        openLastFiles->setObjectName(QStringLiteral("openLastFiles"));
ui_preferencesdialog.h:        openLastFiles->setChecked(true);
ui_preferencesdialog.h:        gridLayout->addWidget(openLastFiles, 2, 0, 1, 1);
ui_preferencesdialog.h:        verticalLayout_2->addWidget(groupBox);
ui_preferencesdialog.h:        groupBox_2->setObjectName(QStringLiteral("groupBox_2"));
ui_preferencesdialog.h:        gridLayout_2->setObjectName(QStringLiteral("gridLayout_2"));
ui_preferencesdialog.h:        openGL->setObjectName(QStringLiteral("openGL"));
ui_preferencesdialog.h:        gridLayout_2->addWidget(openGL, 5, 0, 1, 4);
ui_preferencesdialog.h:        label_2->setObjectName(QStringLiteral("label_2"));
ui_preferencesdialog.h:        gridLayout_2->addWidget(label_2, 0, 0, 1, 1);
ui_preferencesdialog.h:        label_3->setObjectName(QStringLiteral("label_3"));
ui_preferencesdialog.h:        gridLayout_2->addWidget(label_3, 2, 0, 1, 1);
ui_preferencesdialog.h:        gridColor->setObjectName(QStringLiteral("gridColor"));
ui_preferencesdialog.h:        gridLayout_2->addWidget(gridColor, 2, 3, 1, 1);
ui_preferencesdialog.h:        gridLayout_2->addItem(horizontalSpacer_2, 0, 4, 1, 1);
ui_preferencesdialog.h:        languageCombo->setObjectName(QStringLiteral("languageCombo"));
ui_preferencesdialog.h:        gridLayout_2->addWidget(languageCombo, 0, 3, 1, 1);
ui_preferencesdialog.h:        label_4->setObjectName(QStringLiteral("label_4"));
ui_preferencesdialog.h:        gridLayout_2->addWidget(label_4, 3, 0, 1, 1);
ui_preferencesdialog.h:        gridFine->setObjectName(QStringLiteral("gridFine"));
ui_preferencesdialog.h:        gridFine->setMinimum(1);
ui_preferencesdialog.h:        gridFine->setMaximum(128);
ui_preferencesdialog.h:        gridLayout_2->addWidget(gridFine, 3, 3, 1, 1);
ui_preferencesdialog.h:        objectLineWidth->setObjectName(QStringLiteral("objectLineWidth"));
ui_preferencesdialog.h:        objectLineWidth->setDecimals(1);
ui_preferencesdialog.h:        objectLineWidth->setMinimum(1);
ui_preferencesdialog.h:        objectLineWidth->setValue(2);
ui_preferencesdialog.h:        gridLayout_2->addWidget(objectLineWidth, 4, 3, 1, 1);
ui_preferencesdialog.h:        label->setObjectName(QStringLiteral("label"));
ui_preferencesdialog.h:        gridLayout_2->addWidget(label, 4, 0, 1, 1);
ui_preferencesdialog.h:        verticalLayout_2->addWidget(groupBox_2);
ui_preferencesdialog.h:        verticalLayout_2->addItem(verticalSpacer);
ui_preferencesdialog.h:        tabWidget->addTab(tab, QString());
ui_preferencesdialog.h:        tab_2->setObjectName(QStringLiteral("tab_2"));
ui_preferencesdialog.h:        verticalLayout_3->setObjectName(QStringLiteral("verticalLayout_3"));
ui_preferencesdialog.h:        groupBox_3->setObjectName(QStringLiteral("groupBox_3"));
ui_preferencesdialog.h:        verticalLayout_4->setObjectName(QStringLiteral("verticalLayout_4"));
ui_preferencesdialog.h:        objectTypesTable->setObjectName(QStringLiteral("objectTypesTable"));
ui_preferencesdialog.h:        objectTypesTable->setSelectionBehavior(QAbstractItemView::SelectRows);
ui_preferencesdialog.h:        objectTypesTable->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
ui_preferencesdialog.h:        objectTypesTable->setWordWrap(false);
ui_preferencesdialog.h:        objectTypesTable->horizontalHeader()->setHighlightSections(false);
ui_preferencesdialog.h:        objectTypesTable->verticalHeader()->setVisible(false);
ui_preferencesdialog.h:        objectTypesTable->verticalHeader()->setHighlightSections(false);
ui_preferencesdialog.h:        verticalLayout_4->addWidget(objectTypesTable);
ui_preferencesdialog.h:        horizontalLayout->setObjectName(QStringLiteral("horizontalLayout"));
ui_preferencesdialog.h:        addObjectTypeButton->setObjectName(QStringLiteral("addObjectTypeButton"));
ui_preferencesdialog.h:        addObjectTypeButton->setIcon(icon);
ui_preferencesdialog.h:        addObjectTypeButton->setAutoRaise(true);
ui_preferencesdialog.h:        horizontalLayout->addWidget(addObjectTypeButton);
ui_preferencesdialog.h:        removeObjectTypeButton->setObjectName(QStringLiteral("removeObjectTypeButton"));
ui_preferencesdialog.h:        removeObjectTypeButton->setEnabled(false);
ui_preferencesdialog.h:        removeObjectTypeButton->setIcon(icon1);
ui_preferencesdialog.h:        removeObjectTypeButton->setAutoRaise(true);
ui_preferencesdialog.h:        horizontalLayout->addWidget(removeObjectTypeButton);
ui_preferencesdialog.h:        horizontalLayout->addItem(horizontalSpacer);
ui_preferencesdialog.h:        importObjectTypesButton->setObjectName(QStringLiteral("importObjectTypesButton"));
ui_preferencesdialog.h:        sizePolicy.setHeightForWidth(importObjectTypesButton->sizePolicy().hasHeightForWidth());
ui_preferencesdialog.h:        importObjectTypesButton->setSizePolicy(sizePolicy);
ui_preferencesdialog.h:        horizontalLayout->addWidget(importObjectTypesButton);
ui_preferencesdialog.h:        exportObjectTypesButton->setObjectName(QStringLiteral("exportObjectTypesButton"));
ui_preferencesdialog.h:        sizePolicy1.setHeightForWidth(exportObjectTypesButton->sizePolicy().hasHeightForWidth());
ui_preferencesdialog.h:        exportObjectTypesButton->setSizePolicy(sizePolicy1);
ui_preferencesdialog.h:        horizontalLayout->addWidget(exportObjectTypesButton);
ui_preferencesdialog.h:        verticalLayout_4->addLayout(horizontalLayout);
ui_preferencesdialog.h:        verticalLayout_3->addWidget(groupBox_3);
ui_preferencesdialog.h:        tabWidget->addTab(tab_2, QString());
ui_preferencesdialog.h:        tab_3->setObjectName(QStringLiteral("tab_3"));
ui_preferencesdialog.h:        autoMapWhileDrawing->setObjectName(QStringLiteral("autoMapWhileDrawing"));
ui_preferencesdialog.h:        autoMapWhileDrawing->setGeometry(QRect(10, 20, 391, 22));
ui_preferencesdialog.h:        tabWidget->addTab(tab_3, QString());
ui_preferencesdialog.h:        verticalLayout->addWidget(tabWidget);
ui_preferencesdialog.h:        buttonBox->setObjectName(QStringLiteral("buttonBox"));
ui_preferencesdialog.h:        buttonBox->setOrientation(Qt::Horizontal);
ui_preferencesdialog.h:        buttonBox->setStandardButtons(QDialogButtonBox::Close);
ui_preferencesdialog.h:        verticalLayout->addWidget(buttonBox);
ui_preferencesdialog.h:        label_2->setBuddy(languageCombo);
ui_preferencesdialog.h:        label_3->setBuddy(gridColor);
ui_preferencesdialog.h:        label_4->setBuddy(gridFine);
ui_preferencesdialog.h:        label->setBuddy(objectLineWidth);
ui_preferencesdialog.h:        tabWidget->setCurrentIndex(0);
ui_preferencesdialog.h:        PreferencesDialog->setWindowTitle(QApplication::translate("PreferencesDialog", "Preferences", 0));
ui_preferencesdialog.h:        groupBox->setTitle(QApplication::translate("PreferencesDialog", "Saving and Loading", 0));
ui_preferencesdialog.h:        reloadTilesetImages->setText(QApplication::translate("PreferencesDialog", "&Reload tileset images when they change", 0));
ui_preferencesdialog.h:        enableDtd->setToolTip(QApplication::translate("PreferencesDialog", "Not enabled by default since a reference to an external DTD is known to cause problems with some XML parsers.", 0));
ui_preferencesdialog.h:        enableDtd->setText(QApplication::translate("PreferencesDialog", "Include &DTD reference in saved maps", 0));
ui_preferencesdialog.h:        openLastFiles->setText(QApplication::translate("PreferencesDialog", "Open last files on startup", 0));
ui_preferencesdialog.h:        groupBox_2->setTitle(QApplication::translate("PreferencesDialog", "Interface", 0));
ui_preferencesdialog.h:        openGL->setText(QApplication::translate("PreferencesDialog", "Hardware &accelerated drawing (OpenGL)", 0));
ui_preferencesdialog.h:        label_2->setText(QApplication::translate("PreferencesDialog", "&Language:", 0));
ui_preferencesdialog.h:        label_3->setText(QApplication::translate("PreferencesDialog", "Grid color:", 0));
ui_preferencesdialog.h:        label_4->setText(QApplication::translate("PreferencesDialog", "Fine grid divisions:", 0));
ui_preferencesdialog.h:        objectLineWidth->setSuffix(QApplication::translate("PreferencesDialog", " pixels", 0));
ui_preferencesdialog.h:        label->setText(QApplication::translate("PreferencesDialog", "Object line width:", 0));
ui_preferencesdialog.h:        tabWidget->setTabText(tabWidget->indexOf(tab), QApplication::translate("PreferencesDialog", "General", 0));
ui_preferencesdialog.h:        groupBox_3->setTitle(QApplication::translate("PreferencesDialog", "Object Types", 0));
ui_preferencesdialog.h:        addObjectTypeButton->setToolTip(QApplication::translate("PreferencesDialog", "Add Object Type", 0));
ui_preferencesdialog.h:        addObjectTypeButton->setText(QApplication::translate("PreferencesDialog", "Add", 0));
ui_preferencesdialog.h:        removeObjectTypeButton->setToolTip(QApplication::translate("PreferencesDialog", "Remove Selected Object Types", 0));
ui_preferencesdialog.h:        removeObjectTypeButton->setText(QApplication::translate("PreferencesDialog", "Remove", 0));
ui_preferencesdialog.h:        importObjectTypesButton->setText(QApplication::translate("PreferencesDialog", "Import...", 0));
ui_preferencesdialog.h:        exportObjectTypesButton->setText(QApplication::translate("PreferencesDialog", "Export...", 0));
ui_preferencesdialog.h:        tabWidget->setTabText(tabWidget->indexOf(tab_2), QApplication::translate("PreferencesDialog", "Object Types", 0));
ui_preferencesdialog.h:        autoMapWhileDrawing->setText(QApplication::translate("PreferencesDialog", "Use Automapping, when drawing into layers", 0));
ui_preferencesdialog.h:        tabWidget->setTabText(tabWidget->indexOf(tab_3), QApplication::translate("PreferencesDialog", "Automapping", 0));
Binary file fileedit.o matches
Binary file addremoveterrain.o matches
Binary file moc_automapper.o matches
tileselectionitem.h: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
moc_createrectangleobjecttool.cpp:        - idx * sizeof(QByteArrayData) \
moc_createrectangleobjecttool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
brushitem.cpp: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
brushitem.cpp:    mRegion = tileLayer ? tileLayer->region() : QRegion();
brushitem.cpp:    const QPoint oldPosition(mTileLayer->x(), mTileLayer->y());
brushitem.cpp:    mRegion.translate(pos - oldPosition);
brushitem.cpp:    mTileLayer->setX(pos.x());
brushitem.cpp:    mTileLayer->setY(pos.y());
brushitem.cpp:    int mapWidth = mMapDocument->map()->width();
brushitem.cpp:    int mapHeight = mMapDocument->map()->height();
brushitem.cpp:    const MapRenderer *renderer = mMapDocument->renderer();
brushitem.cpp:        const qreal opacity = painter->opacity();
brushitem.cpp:        painter->setOpacity(0.75);
brushitem.cpp:        renderer->drawTileLayer(painter, mTileLayer.data(), option->exposedRect);
brushitem.cpp:        painter->setOpacity(opacity);
brushitem.cpp:    renderer->drawTileSelection(painter, insideMapRegion,
brushitem.cpp:                                option->exposedRect);
brushitem.cpp:    renderer->drawTileSelection(painter, outsideMapRegion,
brushitem.cpp:                                option->exposedRect);
brushitem.cpp:    mBoundingRect = mMapDocument->renderer()->boundingRect(bounds);
brushitem.cpp:        const Map *map = mMapDocument->map();
brushitem.cpp:        QMargins drawMargins = mTileLayer->drawMargins();
brushitem.cpp:        drawMargins.setTop(drawMargins.top() - map->tileHeight());
brushitem.cpp:        drawMargins.setRight(drawMargins.right() - map->tileWidth());
brushitem.cpp:        mBoundingRect.adjust(qMin(0, -drawMargins.left()),
brushitem.cpp:                             qMin(0, -drawMargins.top()),
exportasimagedialog.cpp: * Copyright 2009-2015, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
exportasimagedialog.cpp:    mUi->setupUi(this);
exportasimagedialog.cpp:    QPushButton *saveButton = mUi->buttonBox->button(QDialogButtonBox::Save);
exportasimagedialog.cpp:    saveButton->setText(tr("Export"));
exportasimagedialog.cpp:    mUi->fileNameEdit->setText(suggestion);
exportasimagedialog.cpp:    QSettings *s = Preferences::instance()->settings();
exportasimagedialog.cpp:            s->value(QLatin1String(VISIBLE_ONLY_KEY), true).toBool();
exportasimagedialog.cpp:            s->value(QLatin1String(CURRENT_SCALE_KEY), true).toBool();
exportasimagedialog.cpp:            s->value(QLatin1String(DRAW_GRID_KEY), false).toBool();
exportasimagedialog.cpp:            s->value(QLatin1String(INCLUDE_BACKGROUND_COLOR), false).toBool();
exportasimagedialog.cpp:    mUi->visibleLayersOnly->setChecked(visibleLayersOnly);
exportasimagedialog.cpp:    mUi->currentZoomLevel->setChecked(useCurrentScale);
exportasimagedialog.cpp:    mUi->drawTileGrid->setChecked(drawTileGrid);
exportasimagedialog.cpp:    mUi->includeBackgroundColor->setChecked(includeBackgroundColor);
exportasimagedialog.cpp:    connect(mUi->browseButton, SIGNAL(clicked()), SLOT(browse()));
exportasimagedialog.cpp:    connect(mUi->fileNameEdit, SIGNAL(textChanged(QString)),
exportasimagedialog.cpp:    return a->y() < b->y();
exportasimagedialog.cpp:    const QString fileName = mUi->fileNameEdit->text();
exportasimagedialog.cpp:    const bool visibleLayersOnly = mUi->visibleLayersOnly->isChecked();
exportasimagedialog.cpp:    const bool useCurrentScale = mUi->currentZoomLevel->isChecked();
exportasimagedialog.cpp:    const bool drawTileGrid = mUi->drawTileGrid->isChecked();
exportasimagedialog.cpp:    const bool includeBackgroundColor = mUi->includeBackgroundColor->isChecked();
exportasimagedialog.cpp:    MapRenderer *renderer = mMapDocument->renderer();
exportasimagedialog.cpp:    const Tiled::RenderFlags renderFlags = renderer->flags();
exportasimagedialog.cpp:    renderer->setFlag(ShowTileObjectOutlines, false);
exportasimagedialog.cpp:    QSize mapSize = renderer->mapSize();
exportasimagedialog.cpp:    QMargins margins = mMapDocument->map()->computeLayerOffsetMargins();
exportasimagedialog.cpp:            if (mMapDocument->map()->backgroundColor().isValid())
exportasimagedialog.cpp:                image.fill(mMapDocument->map()->backgroundColor());
exportasimagedialog.cpp:                                 "Try reducing the zoom level or using a 64-bit version of Tiled."));
exportasimagedialog.cpp:        renderer->setPainterScale(mCurrentScale);
exportasimagedialog.cpp:        renderer->setPainterScale(1);
exportasimagedialog.cpp:    foreach (const Layer *layer, mMapDocument->map()->layers()) {
exportasimagedialog.cpp:        if (visibleLayersOnly && !layer->isVisible())
exportasimagedialog.cpp:        painter.setOpacity(layer->opacity());
exportasimagedialog.cpp:        painter.translate(layer->offset());
exportasimagedialog.cpp:            renderer->drawTileLayer(&painter, tileLayer);
exportasimagedialog.cpp:            QList<MapObject*> objects = objGroup->objects();
exportasimagedialog.cpp:            if (objGroup->drawOrder() == ObjectGroup::TopDownOrder)
exportasimagedialog.cpp:                if (object->isVisible()) {
exportasimagedialog.cpp:                    if (object->rotation() != qreal(0)) {
exportasimagedialog.cpp:                        QPointF origin = renderer->pixelToScreenCoords(object->position());
exportasimagedialog.cpp:                        painter.rotate(object->rotation());
exportasimagedialog.cpp:                        painter.translate(-origin);
exportasimagedialog.cpp:                    renderer->drawMapObject(&painter, object, color);
exportasimagedialog.cpp:                    if (object->rotation() != qreal(0))
exportasimagedialog.cpp:            renderer->drawImageLayer(&painter, imageLayer);
exportasimagedialog.cpp:        painter.translate(-layer->offset());
exportasimagedialog.cpp:        renderer->drawGrid(&painter, QRectF(QPointF(), renderer->mapSize()),
exportasimagedialog.cpp:                           prefs->gridColor());
exportasimagedialog.cpp:    renderer->setFlags(renderFlags);
exportasimagedialog.cpp:    QSettings *s = Preferences::instance()->settings();
exportasimagedialog.cpp:    s->setValue(QLatin1String(VISIBLE_ONLY_KEY), visibleLayersOnly);
exportasimagedialog.cpp:    s->setValue(QLatin1String(CURRENT_SCALE_KEY), useCurrentScale);
exportasimagedialog.cpp:    s->setValue(QLatin1String(DRAW_GRID_KEY), drawTileGrid);
exportasimagedialog.cpp:    s->setValue(QLatin1String(INCLUDE_BACKGROUND_COLOR), includeBackgroundColor);
exportasimagedialog.cpp:                                             mUi->fileNameEdit->text(),
exportasimagedialog.cpp:        mUi->fileNameEdit->setText(f);
exportasimagedialog.cpp:    QPushButton *saveButton = mUi->buttonBox->button(QDialogButtonBox::Save);
exportasimagedialog.cpp:    saveButton->setEnabled(!mUi->fileNameEdit->text().isEmpty());
Binary file rotatemapobject.o matches
tileanimationeditor.ui:<?xml version="1.0" encoding="UTF-8"?>
Binary file moc_terrainbrush.o matches
Binary file moc_mapscene.o matches
qrc_qtpropertybrowser.cpp:  // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-wait.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-busy.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-whatsthis.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-sizev.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-arrow.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-vsplit.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-hand.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-closedhand.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-forbidden.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-hsplit.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-openhand.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-sizeall.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-sizeb.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-uparrow.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-ibeam.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-sizef.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-cross.png
qrc_qtpropertybrowser.cpp:    // /home/student/tiled/src/qtpropertybrowser/src/images/cursor-sizeh.png
qrc_qtpropertybrowser.cpp:  // qt-project.org
qrc_qtpropertybrowser.cpp:    // cursor-wait.png
qrc_qtpropertybrowser.cpp:    // cursor-busy.png
qrc_qtpropertybrowser.cpp:    // cursor-whatsthis.png
qrc_qtpropertybrowser.cpp:    // cursor-sizev.png
qrc_qtpropertybrowser.cpp:    // cursor-arrow.png
qrc_qtpropertybrowser.cpp:    // cursor-vsplit.png
qrc_qtpropertybrowser.cpp:    // cursor-hand.png
qrc_qtpropertybrowser.cpp:    // cursor-closedhand.png
qrc_qtpropertybrowser.cpp:    // cursor-forbidden.png
qrc_qtpropertybrowser.cpp:    // cursor-hsplit.png
qrc_qtpropertybrowser.cpp:    // cursor-openhand.png
qrc_qtpropertybrowser.cpp:    // cursor-sizeall.png
qrc_qtpropertybrowser.cpp:    // cursor-sizeb.png
qrc_qtpropertybrowser.cpp:    // cursor-uparrow.png
qrc_qtpropertybrowser.cpp:    // cursor-ibeam.png
qrc_qtpropertybrowser.cpp:    // cursor-sizef.png
qrc_qtpropertybrowser.cpp:    // cursor-cross.png
qrc_qtpropertybrowser.cpp:    // cursor-sizeh.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-forbidden.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-cross.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-sizev.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-sizeb.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-sizef.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-sizeh.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-whatsthis.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-hand.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-wait.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-openhand.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-sizeall.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-closedhand.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-uparrow.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-arrow.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-vsplit.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-hsplit.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-ibeam.png
qrc_qtpropertybrowser.cpp:  // :/qt-project.org/qtpropertybrowser/images/cursor-busy.png
abstracttiletool.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
abstracttiletool.cpp:    mBrushItem->setVisible(false);
abstracttiletool.cpp:    mBrushItem->setZValue(10000);
abstracttiletool.cpp:    scene->addItem(mBrushItem);
abstracttiletool.cpp:    scene->removeItem(mBrushItem);
abstracttiletool.cpp:        offsetPos -= layer->offset();
abstracttiletool.cpp:        mBrushItem->setLayerOffset(layer->offset());
abstracttiletool.cpp:    const MapRenderer *renderer = mapDocument()->renderer();
abstracttiletool.cpp:    const QPointF tilePosF = renderer->screenToTileCoords(offsetPos);
abstracttiletool.cpp:    mBrushItem->setMapDocument(newDocument);
abstracttiletool.cpp:            const QPoint pos = tilePosition() - tileLayer->position();
abstracttiletool.cpp:            if (tileLayer->contains(pos))
abstracttiletool.cpp:                tile = tileLayer->cellAt(pos).tile;
abstracttiletool.cpp:        QString tileIdString = tile ? QString::number(tile->id()) : tr("empty");
abstracttiletool.cpp:            if (layer->isVisible())
abstracttiletool.cpp:    mBrushItem->setVisible(showBrush);
abstracttiletool.cpp:    return dynamic_cast<TileLayer*>(mapDocument()->currentLayer());
Binary file moc_createpolylineobjecttool.o matches
varianteditorfactory.cpp:    const int type = manager->propertyType(property);
varianteditorfactory.cpp:        editor->setFilePath(manager->value(property).toString());
varianteditorfactory.cpp:        editor->setFilter(manager->attributeValue(property, QLatin1String("filter")).toString());
varianteditorfactory.cpp:        QVariant suggestions = manager->attributeValue(property, QLatin1String("suggestions"));
varianteditorfactory.cpp:                completer->setCaseSensitivity(Qt::CaseInsensitive);
varianteditorfactory.cpp:                lineEdit->setCompleter(completer);
varianteditorfactory.cpp:        itEditor.next()->setFilePath(value.toString());
varianteditorfactory.cpp:        itEditor.next()->setFilter(value.toString());
varianteditorfactory.cpp:            manager->setValue(property, value);
qrc_tiled.cpp:  // /home/student/tiled/src/tiled/images/about-tiled-logo.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/22x22/stock-tool-by-color-select.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/22x22/stock-tool-rect-select.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/22x22/stock-tool-clone.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/22x22/stock-tool-eraser.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/22x22/stock-tool-bucket-fill.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/22x22/stock-tool-fuzzy-select-22.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/22x22/tool-select-objects.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/edit-undo.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/help-about.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/system-run.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/edit-cut.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/edit-copy.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/insert-rectangle.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/document-page-setup.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/insert-image.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/document-properties.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/move-image-layer.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/document-save-as.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/zoom-original.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/edit-clear.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/insert-polygon.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/zoom-out.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/edit-paste.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/terrain-edit.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/zoom-in.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/document-open-recent.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/document-save.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/document-new.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/insert-ellipse.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/go-down.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/drive-harddisk.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/insert-polyline.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/tool-edit-polygons.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/insert-object.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/go-up.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/document-open.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/24x24/edit-redo.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/drive-harddisk.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/zoom-out.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/application-exit.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/layer-object.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/edit-clear.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/document-open.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/layer-image.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/terminal-red.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/go-down.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/help-about.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/zoom-in.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/document-new.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/terminal-green.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/edit-redo.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/document-open-recent.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/document-export.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/edit-undo.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/document-properties.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/document-save-as.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/stock-duplicate-16.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/document-import.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/layer-tile.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/edit-delete.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/edit-copy.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/zoom-original.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/document-save.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/document-page-setup.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/go-up.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/window-close.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/edit-cut.png
qrc_tiled.cpp:    // /home/student/tiled/src/tiled/images/16x16/edit-paste.png
qrc_tiled.cpp:    // about-tiled-logo.png
qrc_tiled.cpp:    // stock-tool-by-color-select.png
qrc_tiled.cpp:    // stock-tool-rect-select.png
qrc_tiled.cpp:    // stock-tool-clone.png
qrc_tiled.cpp:    // stock-tool-eraser.png
qrc_tiled.cpp:    // stock-tool-bucket-fill.png
qrc_tiled.cpp:    // stock-tool-fuzzy-select-22.png
qrc_tiled.cpp:    // tool-select-objects.png
qrc_tiled.cpp:    // edit-undo.png
qrc_tiled.cpp:    // help-about.png
qrc_tiled.cpp:    // system-run.png
qrc_tiled.cpp:    // edit-cut.png
qrc_tiled.cpp:    // edit-copy.png
qrc_tiled.cpp:    // insert-rectangle.png
qrc_tiled.cpp:    // document-page-setup.png
qrc_tiled.cpp:    // insert-image.png
qrc_tiled.cpp:    // document-properties.png
qrc_tiled.cpp:    // move-image-layer.png
qrc_tiled.cpp:    // document-save-as.png
qrc_tiled.cpp:    // zoom-original.png
qrc_tiled.cpp:    // edit-clear.png
qrc_tiled.cpp:    // insert-polygon.png
qrc_tiled.cpp:    // zoom-out.png
qrc_tiled.cpp:    // edit-paste.png
qrc_tiled.cpp:    // terrain-edit.png
qrc_tiled.cpp:    // zoom-in.png
qrc_tiled.cpp:    // document-open-recent.png
qrc_tiled.cpp:    // document-save.png
qrc_tiled.cpp:    // document-new.png
qrc_tiled.cpp:    // insert-ellipse.png
qrc_tiled.cpp:    // go-down.png
qrc_tiled.cpp:    // drive-harddisk.png
qrc_tiled.cpp:    // insert-polyline.png
qrc_tiled.cpp:    // tool-edit-polygons.png
qrc_tiled.cpp:    // insert-object.png
qrc_tiled.cpp:    // go-up.png
qrc_tiled.cpp:    // document-open.png
qrc_tiled.cpp:    // edit-redo.png
qrc_tiled.cpp:    // application-exit.png
qrc_tiled.cpp:    // layer-object.png
qrc_tiled.cpp:    // layer-image.png
qrc_tiled.cpp:    // terminal-red.png
qrc_tiled.cpp:    // terminal-green.png
qrc_tiled.cpp:    // document-export.png
qrc_tiled.cpp:    // stock-duplicate-16.png
qrc_tiled.cpp:    // document-import.png
qrc_tiled.cpp:    // layer-tile.png
qrc_tiled.cpp:    // edit-delete.png
qrc_tiled.cpp:    // window-close.png
qrc_tiled.cpp:  // :/images/about-tiled-logo.png
qrc_tiled.cpp:  // :/images/24x24/document-open-recent.png
qrc_tiled.cpp:  // :/images/24x24/insert-polygon.png
qrc_tiled.cpp:  // :/images/24x24/edit-copy.png
qrc_tiled.cpp:  // :/images/24x24/document-open.png
qrc_tiled.cpp:  // :/images/24x24/tool-edit-polygons.png
qrc_tiled.cpp:  // :/images/24x24/zoom-in.png
qrc_tiled.cpp:  // :/images/24x24/document-properties.png
qrc_tiled.cpp:  // :/images/24x24/edit-undo.png
qrc_tiled.cpp:  // :/images/24x24/go-up.png
qrc_tiled.cpp:  // :/images/24x24/insert-ellipse.png
qrc_tiled.cpp:  // :/images/24x24/go-down.png
qrc_tiled.cpp:  // :/images/24x24/zoom-out.png
qrc_tiled.cpp:  // :/images/24x24/edit-cut.png
qrc_tiled.cpp:  // :/images/24x24/insert-object.png
qrc_tiled.cpp:  // :/images/24x24/system-run.png
qrc_tiled.cpp:  // :/images/24x24/insert-polyline.png
qrc_tiled.cpp:  // :/images/24x24/document-page-setup.png
qrc_tiled.cpp:  // :/images/24x24/move-image-layer.png
qrc_tiled.cpp:  // :/images/24x24/document-save-as.png
qrc_tiled.cpp:  // :/images/24x24/terrain-edit.png
qrc_tiled.cpp:  // :/images/24x24/edit-paste.png
qrc_tiled.cpp:  // :/images/24x24/document-new.png
qrc_tiled.cpp:  // :/images/24x24/edit-redo.png
qrc_tiled.cpp:  // :/images/24x24/insert-rectangle.png
qrc_tiled.cpp:  // :/images/24x24/edit-clear.png
qrc_tiled.cpp:  // :/images/24x24/drive-harddisk.png
qrc_tiled.cpp:  // :/images/24x24/help-about.png
qrc_tiled.cpp:  // :/images/24x24/zoom-original.png
qrc_tiled.cpp:  // :/images/24x24/insert-image.png
qrc_tiled.cpp:  // :/images/24x24/document-save.png
qrc_tiled.cpp:  // :/images/22x22/stock-tool-eraser.png
qrc_tiled.cpp:  // :/images/22x22/tool-select-objects.png
qrc_tiled.cpp:  // :/images/22x22/stock-tool-fuzzy-select-22.png
qrc_tiled.cpp:  // :/images/22x22/stock-tool-bucket-fill.png
qrc_tiled.cpp:  // :/images/22x22/stock-tool-rect-select.png
qrc_tiled.cpp:  // :/images/22x22/stock-tool-by-color-select.png
qrc_tiled.cpp:  // :/images/22x22/stock-tool-clone.png
qrc_tiled.cpp:  // :/images/16x16/window-close.png
qrc_tiled.cpp:  // :/images/16x16/document-open-recent.png
qrc_tiled.cpp:  // :/images/16x16/terminal-red.png
qrc_tiled.cpp:  // :/images/16x16/document-import.png
qrc_tiled.cpp:  // :/images/16x16/document-export.png
qrc_tiled.cpp:  // :/images/16x16/edit-copy.png
qrc_tiled.cpp:  // :/images/16x16/document-open.png
qrc_tiled.cpp:  // :/images/16x16/layer-tile.png
qrc_tiled.cpp:  // :/images/16x16/stock-duplicate-16.png
qrc_tiled.cpp:  // :/images/16x16/zoom-in.png
qrc_tiled.cpp:  // :/images/16x16/layer-object.png
qrc_tiled.cpp:  // :/images/16x16/document-properties.png
qrc_tiled.cpp:  // :/images/16x16/edit-undo.png
qrc_tiled.cpp:  // :/images/16x16/go-up.png
qrc_tiled.cpp:  // :/images/16x16/go-down.png
qrc_tiled.cpp:  // :/images/16x16/zoom-out.png
qrc_tiled.cpp:  // :/images/16x16/application-exit.png
qrc_tiled.cpp:  // :/images/16x16/edit-cut.png
qrc_tiled.cpp:  // :/images/16x16/layer-image.png
qrc_tiled.cpp:  // :/images/16x16/document-page-setup.png
qrc_tiled.cpp:  // :/images/16x16/document-save-as.png
qrc_tiled.cpp:  // :/images/16x16/edit-delete.png
qrc_tiled.cpp:  // :/images/16x16/edit-paste.png
qrc_tiled.cpp:  // :/images/16x16/document-new.png
qrc_tiled.cpp:  // :/images/16x16/edit-redo.png
qrc_tiled.cpp:  // :/images/16x16/edit-clear.png
qrc_tiled.cpp:  // :/images/16x16/drive-harddisk.png
qrc_tiled.cpp:  // :/images/16x16/terminal-green.png
qrc_tiled.cpp:  // :/images/16x16/help-about.png
qrc_tiled.cpp:  // :/images/16x16/zoom-original.png
qrc_tiled.cpp:  // :/images/16x16/document-save.png
Binary file changeimagelayerposition.o matches
Binary file terrainview.o matches
moc_abstracttool.cpp:        - idx * sizeof(QByteArrayData) \
moc_abstracttool.cpp:        case 0: _t->statusInfoChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_abstracttool.cpp:        case 1: _t->cursorChanged((*reinterpret_cast< const QCursor(*)>(_a[1]))); break;
moc_abstracttool.cpp:        case 2: _t->enabledChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_abstracttool.cpp:        case 3: _t->setMapDocument((*reinterpret_cast< MapDocument*(*)>(_a[1]))); break;
moc_abstracttool.cpp:        case 4: _t->updateEnabledState(); break;
moc_abstracttool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_abstracttool.cpp:        _id -= 5;
moc_abstracttool.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_abstracttool.cpp:        _id -= 5;
moc_abstracttool.cpp:        _id -= 6;
moc_abstracttool.cpp:        _id -= 6;
moc_abstracttool.cpp:        _id -= 6;
moc_abstracttool.cpp:        _id -= 6;
moc_abstracttool.cpp:        _id -= 6;
moc_abstracttool.cpp:        _id -= 6;
moc_abstracttool.cpp:        _id -= 6;
moc_abstracttool.cpp:        _id -= 6;
moc_abstracttool.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_abstracttool.cpp:        _id -= 6;
mapdocument.h: * Copyright 2008-2014, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
mapdocument.h:     * Returns the index of the currently selected layer. Returns -1 if no
Binary file createpolygonobjecttool.o matches
Binary file commanddialog.o matches
Binary file resizemapobject.o matches
Binary file moc_objectsdock.o matches
magicwandtool.h: * Copyright 2009-2010, Jeff Bland <jksb@member.fsf.org>
minimapdock.h: * Shows a mini-map.
tileselectionitem.cpp: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tileselectionitem.cpp:    const QRegion &selection = mMapDocument->selectedArea();
tileselectionitem.cpp:    MapRenderer *renderer = mMapDocument->renderer();
tileselectionitem.cpp:    renderer->drawTileSelection(painter, selection, highlight,
tileselectionitem.cpp:                                option->exposedRect);
tileselectionitem.cpp:    update(mMapDocument->renderer()->boundingRect(changedArea));
tileselectionitem.cpp:    if (Layer *layer = mMapDocument->currentLayer())
tileselectionitem.cpp:        setPos(layer->offset());
tileselectionitem.cpp:    const QRect b = mMapDocument->selectedArea().boundingRect();
tileselectionitem.cpp:    mBoundingRect = mMapDocument->renderer()->boundingRect(b);
documentmanager.h:     * index. Returns -1 when the document isn't open.
minimap.cpp:        mMapDocument->disconnect(this);
minimap.cpp:        if (MapView *mapView = dm->viewForDocument(mMapDocument)) {
minimap.cpp:            mapView->zoomable()->disconnect(this);
minimap.cpp:            mapView->horizontalScrollBar()->disconnect(this);
minimap.cpp:            mapView->verticalScrollBar()->disconnect(this);
minimap.cpp:        connect(mMapDocument->undoStack(), SIGNAL(indexChanged(int)),
minimap.cpp:        if (MapView *mapView = dm->viewForDocument(mMapDocument)) {
minimap.cpp:            connect(mapView->horizontalScrollBar(), SIGNAL(valueChanged(int)), SLOT(update()));
minimap.cpp:            connect(mapView->verticalScrollBar(), SIGNAL(valueChanged(int)), SLOT(update()));
minimap.cpp:            connect(mapView->zoomable(), SIGNAL(scaleChanged(qreal)), SLOT(update()));
minimap.cpp:    if (mMapDocument && mMapDocument->map()->backgroundColor().isValid())
minimap.cpp:        backgroundColor = mMapDocument->map()->backgroundColor();
minimap.cpp:    p.translate(-1, -1);
minimap.cpp:    return a->y() < b->y();
minimap.cpp:    MapRenderer *renderer = mMapDocument->renderer();
minimap.cpp:    QSize mapSize = renderer->mapSize();
minimap.cpp:    QMargins margins = mMapDocument->map()->computeLayerOffsetMargins();
minimap.cpp:    const Tiled::RenderFlags renderFlags = renderer->flags();
minimap.cpp:    renderer->setFlag(ShowTileObjectOutlines, false);
minimap.cpp:    renderer->setPainterScale(scale);
minimap.cpp:    foreach (const Layer *layer, mMapDocument->map()->layers()) {
minimap.cpp:        if (visibleLayersOnly && !layer->isVisible())
minimap.cpp:        painter.setOpacity(layer->opacity());
minimap.cpp:        painter.translate(layer->offset());
minimap.cpp:            renderer->drawTileLayer(&painter, tileLayer);
minimap.cpp:            QList<MapObject*> objects = objGroup->objects();
minimap.cpp:            if (objGroup->drawOrder() == ObjectGroup::TopDownOrder)
minimap.cpp:                if (object->isVisible()) {
minimap.cpp:                    if (object->rotation() != qreal(0)) {
minimap.cpp:                        QPointF origin = renderer->pixelToScreenCoords(object->position());
minimap.cpp:                        painter.rotate(object->rotation());
minimap.cpp:                        painter.translate(-origin);
minimap.cpp:                    renderer->drawMapObject(&painter, object, color);
minimap.cpp:                    if (object->rotation() != qreal(0))
minimap.cpp:            renderer->drawImageLayer(&painter, imageLayer);
minimap.cpp:        painter.translate(-layer->offset());
minimap.cpp:        renderer->drawGrid(&painter, QRectF(QPointF(), renderer->mapSize()),
minimap.cpp:                           prefs->gridColor());
minimap.cpp:    renderer->setFlags(renderFlags);
minimap.cpp:    MapView *mapView = DocumentManager::instance()->currentMapView();
minimap.cpp:        mapView->zoomable()->handleWheelDelta(delta);
minimap.cpp:    mapView->centerOn(mapToScene(centerPos));
minimap.cpp:    if (event->orientation() == Qt::Vertical) {
minimap.cpp:        centerViewOnLocalPixel(event->pos(), event->delta());
minimap.cpp:    if (event->button() == Qt::LeftButton) {
minimap.cpp:        QPoint cursorPos = event->pos();
minimap.cpp:            mDragOffset = viewPort.center() - cursorPos + QPoint(1, 1);
minimap.cpp:    if (event->button() == Qt::LeftButton && mDragging) {
minimap.cpp:        if (viewPort.contains(event->pos())) {
minimap.cpp:        } else if (rect().contains(event->pos())) {
minimap.cpp:        centerViewOnLocalPixel(event->pos() + mDragOffset);
minimap.cpp:    if (viewportRect().contains(event->pos())) {
minimap.cpp:    MapView *mapView = DocumentManager::instance()->currentMapView();
minimap.cpp:    const QRectF sceneRect = mapView->sceneRect();
minimap.cpp:    const QRectF viewRect = mapView->mapToScene(mapView->viewport()->geometry()).boundingRect();
minimap.cpp:    return QRect((viewRect.x() - sceneRect.x()) / sceneRect.width() * mImageRect.width() + mImageRect.x(),
minimap.cpp:                 (viewRect.y() - sceneRect.y()) / sceneRect.height() * mImageRect.height() + mImageRect.y(),
minimap.cpp:    MapView *mapView = DocumentManager::instance()->currentMapView();
minimap.cpp:    const QRectF sceneRect = mapView->sceneRect();
minimap.cpp:    p -= mImageRect.topLeft();
mapscene.cpp: * Copyright 2008-2014, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
mapscene.cpp:    mDarkRectangle->setPen(Qt::NoPen);
mapscene.cpp:    mDarkRectangle->setBrush(Qt::black);
mapscene.cpp:    mDarkRectangle->setOpacity(darkeningFactor);
mapscene.cpp:    mGridVisible = prefs->showGrid();
mapscene.cpp:    mObjectLineWidth = prefs->objectLineWidth();
mapscene.cpp:    mShowTileObjectOutlines = prefs->showTileObjectOutlines();
mapscene.cpp:    mHighlightCurrentLayer = prefs->highlightCurrentLayer();
mapscene.cpp:    qApp->installEventFilter(this);
mapscene.cpp:    qApp->removeEventFilter(this);
mapscene.cpp:        mMapDocument->disconnect(this);
mapscene.cpp:        MapRenderer *renderer = mMapDocument->renderer();
mapscene.cpp:        renderer->setObjectLineWidth(mObjectLineWidth);
mapscene.cpp:        renderer->setFlag(ShowTileObjectOutlines, mShowTileObjectOutlines);
mapscene.cpp:        selectedObjects.append(item->mapObject());
mapscene.cpp:    mMapDocument->setSelectedObjects(selectedObjects);
mapscene.cpp:    const Map *map = mMapDocument->map();
mapscene.cpp:    mLayerItems.resize(map->layerCount());
mapscene.cpp:    if (map->backgroundColor().isValid())
mapscene.cpp:        setBackgroundBrush(map->backgroundColor());
mapscene.cpp:    for (Layer *layer : map->layers()) {
mapscene.cpp:        layerItem->setZValue(layerIndex);
mapscene.cpp:    tileSelectionItem->setZValue(10000 - 2);
mapscene.cpp:    mObjectSelectionItem->setZValue(10000 - 1);
mapscene.cpp:    if (TileLayer *tl = layer->asTileLayer()) {
mapscene.cpp:    } else if (ObjectGroup *og = layer->asObjectGroup()) {
mapscene.cpp:        const ObjectGroup::DrawOrder drawOrder = og->drawOrder();
mapscene.cpp:        for (MapObject *object : og->objects()) {
mapscene.cpp:                item->setZValue(item->y());
mapscene.cpp:                item->setZValue(objectIndex);
mapscene.cpp:    } else if (ImageLayer *il = layer->asImageLayer()) {
mapscene.cpp:    layerItem->setVisible(layer->isVisible());
mapscene.cpp:    const QSize mapSize = mMapDocument->renderer()->mapSize();
mapscene.cpp:    QMargins margins = mMapDocument->map()->computeLayerOffsetMargins();
mapscene.cpp:    sceneRect.adjust(-margins.left(),
mapscene.cpp:                     -margins.top(),
mapscene.cpp:    mDarkRectangle->setRect(sceneRect);
mapscene.cpp:    const int currentLayerIndex = mMapDocument->currentLayerIndex();
mapscene.cpp:    if (!mHighlightCurrentLayer || currentLayerIndex == -1) {
mapscene.cpp:        mDarkRectangle->setVisible(false);
mapscene.cpp:            const Layer *layer = mMapDocument->map()->layerAt(i);
mapscene.cpp:            mLayerItems.at(i)->setOpacity(layer->opacity());
mapscene.cpp:    mDarkRectangle->setZValue(currentLayerIndex - 0.5);
mapscene.cpp:    mDarkRectangle->setVisible(true);
mapscene.cpp:        const Layer *layer = mMapDocument->map()->layerAt(i);
mapscene.cpp:        mLayerItems.at(i)->setOpacity(layer->opacity() * multiplier);
mapscene.cpp:    const MapRenderer *renderer = mMapDocument->renderer();
mapscene.cpp:    const QMargins margins = mMapDocument->map()->drawMargins();
mapscene.cpp:        QRectF boundingRect = renderer->boundingRect(r);
mapscene.cpp:        boundingRect.adjust(-margins.left(),
mapscene.cpp:                            -margins.top(),
mapscene.cpp:        boundingRect.translate(layer->offset());
mapscene.cpp:    mActiveTool->activate(this);
mapscene.cpp:        mActiveTool->modifiersChanged(mCurrentModifiers);
mapscene.cpp:        mActiveTool->mouseEntered();
mapscene.cpp:        mActiveTool->mouseMoved(mLastMousePos, Qt::KeyboardModifiers());
mapscene.cpp:        mActiveTool->mouseLeft();
mapscene.cpp:    mActiveTool->deactivate(this);
mapscene.cpp:            tli->syncWithTileLayer();
mapscene.cpp:        item->syncWithMapObject();
mapscene.cpp:    const Map *map = mMapDocument->map();
mapscene.cpp:    if (map->backgroundColor().isValid())
mapscene.cpp:        setBackgroundBrush(map->backgroundColor());
mapscene.cpp:    if (contains(mMapDocument->map()->tilesets(), tileset))
mapscene.cpp:    const int index = mMapDocument->map()->layers().indexOf(tileLayer);
mapscene.cpp:    item->syncWithTileLayer();
mapscene.cpp:    Layer *layer = mMapDocument->map()->layerAt(index);
mapscene.cpp:        item->setZValue(z++);
mapscene.cpp:    const Layer *layer = mMapDocument->map()->layerAt(index);
mapscene.cpp:    layerItem->setVisible(layer->isVisible());
mapscene.cpp:    if (mHighlightCurrentLayer && mMapDocument->currentLayerIndex() < index)
mapscene.cpp:    layerItem->setOpacity(layer->opacity() * multiplier);
mapscene.cpp:    layerItem->setPos(layer->offset());
mapscene.cpp:    objectsChanged(objectGroup->objects());
mapscene.cpp:    objectsIndexChanged(objectGroup, 0, objectGroup->objectCount() - 1);
mapscene.cpp:    const int index = mMapDocument->map()->layers().indexOf(imageLayer);
mapscene.cpp:    item->syncWithImageLayer();
mapscene.cpp:    item->update();
mapscene.cpp:            tli->syncWithTileLayer();
mapscene.cpp:        const Cell &cell = item->mapObject()->cell();
mapscene.cpp:        if (!cell.isEmpty() && cell.tile->tileset() == tileset)
mapscene.cpp:            item->syncWithMapObject();
mapscene.cpp:            if (ogi->objectGroup() == objectGroup) {
mapscene.cpp:    const ObjectGroup::DrawOrder drawOrder = objectGroup->drawOrder();
mapscene.cpp:        MapObject *object = objectGroup->objectAt(i);
mapscene.cpp:            item->setZValue(item->y());
mapscene.cpp:            item->setZValue(i);
mapscene.cpp:        item->syncWithMapObject();
mapscene.cpp:    if (objectGroup->drawOrder() != ObjectGroup::IndexOrder)
mapscene.cpp:        MapObjectItem *item = itemForObject(objectGroup->objectAt(i));
mapscene.cpp:        item->setZValue(i);
mapscene.cpp:    const QList<MapObject *> &objects = mMapDocument->selectedObjects();
mapscene.cpp:        item->syncWithMapObject();
mapscene.cpp:        mMapDocument->renderer()->setObjectLineWidth(lineWidth);
mapscene.cpp:                item->syncWithMapObject();
mapscene.cpp:        mMapDocument->renderer()->setFlag(ShowTileObjectOutlines, enabled);
mapscene.cpp:    if (Layer *layer = mMapDocument->currentLayer()) {
mapscene.cpp:        offset = layer->offset();
mapscene.cpp:        painter->translate(offset);
mapscene.cpp:    mMapDocument->renderer()->drawGrid(painter,
mapscene.cpp:                                       rect.translated(-offset),
mapscene.cpp:                                       prefs->gridColor());
mapscene.cpp:    switch (event->type()) {
mapscene.cpp:            mActiveTool->mouseEntered();
mapscene.cpp:            mActiveTool->mouseLeft();
mapscene.cpp:        mActiveTool->keyPressed(event);
mapscene.cpp:    if (!(mActiveTool && event->isAccepted()))
mapscene.cpp:    mLastMousePos = mouseEvent->scenePos();
mapscene.cpp:    if (mouseEvent->isAccepted())
mapscene.cpp:        mActiveTool->mouseMoved(mouseEvent->scenePos(),
mapscene.cpp:                                mouseEvent->modifiers());
mapscene.cpp:        mouseEvent->accept();
mapscene.cpp:    if (mouseEvent->isAccepted())
mapscene.cpp:        mouseEvent->accept();
mapscene.cpp:        mActiveTool->mousePressed(mouseEvent);
mapscene.cpp:    if (mouseEvent->isAccepted())
mapscene.cpp:        mouseEvent->accept();
mapscene.cpp:        mActiveTool->mouseReleased(mouseEvent);
mapscene.cpp:    event->ignore();
mapscene.cpp:    switch (event->type()) {
mapscene.cpp:            Qt::KeyboardModifiers newModifiers = keyEvent->modifiers();
mapscene.cpp:                mActiveTool->modifiersChanged(newModifiers);
createscalableobjecttool.cpp:    const MapRenderer *renderer = mapDocument()->renderer();
createscalableobjecttool.cpp:    const QPointF pixelCoords = renderer->screenToPixelCoords(pos);
createscalableobjecttool.cpp:    const QPointF objectPos = mNewMapObjectItem->mapObject()->position();
createscalableobjecttool.cpp:    QPointF newSize(qMax(qreal(0), pixelCoords.x() - objectPos.x()),
createscalableobjecttool.cpp:                    qMax(qreal(0), pixelCoords.y() - objectPos.y()));
createscalableobjecttool.cpp:    mNewMapObjectItem->resizeObject(QSizeF(newSize.x(), newSize.y()));
createscalableobjecttool.cpp:    if (event->button() == Qt::RightButton)
createscalableobjecttool.cpp:    if (event->button() == Qt::LeftButton)
terraindock.h: * Copyright 2008-2012, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
moc_tmxmapformat.cpp:        - idx * sizeof(QByteArrayData) \
moc_tmxmapformat.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tmxmapformat.cpp:        - idx * sizeof(QByteArrayData) \
moc_tmxmapformat.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
Binary file newtilesetdialog.o matches
Binary file preferences.o matches
utils.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
utils.cpp:    Q_ASSERT(!widget->objectName().isEmpty());
utils.cpp:    const QString key = widget->objectName() + QLatin1String("/Geometry");
utils.cpp:    const QSettings *settings = Internal::Preferences::instance()->settings();
utils.cpp:    widget->restoreGeometry(settings->value(key).toByteArray());
utils.cpp:    Q_ASSERT(!widget->objectName().isEmpty());
utils.cpp:    const QString key = widget->objectName() + QLatin1String("/Geometry");
utils.cpp:    QSettings *settings = Internal::Preferences::instance()->settings();
utils.cpp:    settings->setValue(key, widget->saveGeometry());
bucketfilltool.cpp: * Copyright 2009-2010, Jeff Bland <jksb@member.fsf.org>
bucketfilltool.cpp:                               ":images/22x22/stock-tool-bucket-fill.png")),
bucketfilltool.cpp:    TileLayer *stampLayer = static_cast<TileLayer*>(variation->layerAt(0));
bucketfilltool.cpp:    if (!stampLayer || stampLayer->isEmpty())
bucketfilltool.cpp:    if (stampLayer->width() == 1 && stampLayer->height() == 1 && !shiftPressed &&
bucketfilltool.cpp:            stampLayer->cellAt(0, 0) == regionComputer.cellAt(tilePos.x(),
bucketfilltool.cpp:            mFillRegion = mapDocument()->selectedArea();
bucketfilltool.cpp:                mFillRegion = tileLayer->bounds();
bucketfilltool.cpp:            mapDocument()->unifyTilesets(variation, mMissingTilesets);
bucketfilltool.cpp:        brushItem()->setTileLayer(mFillOverlay);
bucketfilltool.cpp:    if (event->button() != Qt::LeftButton || mFillRegion.isEmpty())
bucketfilltool.cpp:    if (!brushItem()->isVisible())
bucketfilltool.cpp:                                         brushItem()->tileLayer());
bucketfilltool.cpp:    mapDocument()->undoStack()->push(fillTiles);
bucketfilltool.cpp:    mapDocument()->emitRegionEdited(fillRegion, currentTileLayer());
bucketfilltool.cpp:    if (mIsActive && brushItem()->isVisible())
bucketfilltool.cpp:    brushItem()->clear();
bucketfilltool.cpp:    brushItem()->setTileRegion(QRegion());
bucketfilltool.cpp:                tileLayer->setCell(_x - tileLayer->x(),
bucketfilltool.cpp:                                   _y - tileLayer->y(),
bucketfilltool.cpp:        mapDocument()->unifyTilesets(variation.map, mMissingTilesets);
bucketfilltool.cpp:        for (int x = 0; x < tileLayer->width(); x++) {
bucketfilltool.cpp:            for (int y = 0; y < tileLayer->height(); y++) {
bucketfilltool.cpp:                const Cell &cell = tileLayer->cellAt(x, y);
bucketfilltool.cpp:                    mRandomCellPicker.add(cell, cell.tile->probability());
Binary file moc_abstracttiletool.o matches
ui_newmapdialog.h:        if (NewMapDialog->objectName().isEmpty())
ui_newmapdialog.h:            NewMapDialog->setObjectName(QStringLiteral("NewMapDialog"));
ui_newmapdialog.h:        NewMapDialog->resize(371, 323);
ui_newmapdialog.h:        gridLayout_3->setObjectName(QStringLiteral("gridLayout_3"));
ui_newmapdialog.h:        gridLayout_3->setSizeConstraint(QLayout::SetFixedSize);
ui_newmapdialog.h:        groupBox_3->setObjectName(QStringLiteral("groupBox_3"));
ui_newmapdialog.h:        gridLayout_2->setObjectName(QStringLiteral("gridLayout_2"));
ui_newmapdialog.h:        label->setObjectName(QStringLiteral("label"));
ui_newmapdialog.h:        gridLayout_2->addWidget(label, 0, 0, 1, 1);
ui_newmapdialog.h:        mapWidth->setObjectName(QStringLiteral("mapWidth"));
ui_newmapdialog.h:        mapWidth->setMinimum(1);
ui_newmapdialog.h:        mapWidth->setMaximum(99999);
ui_newmapdialog.h:        mapWidth->setValue(100);
ui_newmapdialog.h:        gridLayout_2->addWidget(mapWidth, 0, 1, 1, 1);
ui_newmapdialog.h:        label_2->setObjectName(QStringLiteral("label_2"));
ui_newmapdialog.h:        gridLayout_2->addWidget(label_2, 1, 0, 1, 1);
ui_newmapdialog.h:        mapHeight->setObjectName(QStringLiteral("mapHeight"));
ui_newmapdialog.h:        mapHeight->setMinimum(1);
ui_newmapdialog.h:        mapHeight->setMaximum(99999);
ui_newmapdialog.h:        mapHeight->setValue(100);
ui_newmapdialog.h:        gridLayout_2->addWidget(mapHeight, 1, 1, 1, 1);
ui_newmapdialog.h:        pixelSizeLabel->setObjectName(QStringLiteral("pixelSizeLabel"));
ui_newmapdialog.h:        pixelSizeLabel->setText(QStringLiteral("3200 x 3200 pixels"));
ui_newmapdialog.h:        gridLayout_2->addWidget(pixelSizeLabel, 2, 0, 1, 2);
ui_newmapdialog.h:        gridLayout_3->addWidget(groupBox_3, 1, 0, 1, 1);
ui_newmapdialog.h:        groupBox_2->setObjectName(QStringLiteral("groupBox_2"));
ui_newmapdialog.h:        gridLayout->setObjectName(QStringLiteral("gridLayout"));
ui_newmapdialog.h:        label_3->setObjectName(QStringLiteral("label_3"));
ui_newmapdialog.h:        gridLayout->addWidget(label_3, 0, 0, 1, 1);
ui_newmapdialog.h:        tileWidth->setObjectName(QStringLiteral("tileWidth"));
ui_newmapdialog.h:        tileWidth->setMinimum(1);
ui_newmapdialog.h:        tileWidth->setMaximum(9999);
ui_newmapdialog.h:        tileWidth->setValue(32);
ui_newmapdialog.h:        gridLayout->addWidget(tileWidth, 0, 1, 1, 1);
ui_newmapdialog.h:        label_4->setObjectName(QStringLiteral("label_4"));
ui_newmapdialog.h:        gridLayout->addWidget(label_4, 1, 0, 1, 1);
ui_newmapdialog.h:        tileHeight->setObjectName(QStringLiteral("tileHeight"));
ui_newmapdialog.h:        tileHeight->setMinimum(1);
ui_newmapdialog.h:        tileHeight->setMaximum(9999);
ui_newmapdialog.h:        tileHeight->setValue(32);
ui_newmapdialog.h:        gridLayout->addWidget(tileHeight, 1, 1, 1, 1);
ui_newmapdialog.h:        gridLayout->addItem(verticalSpacer_2, 2, 0, 1, 2);
ui_newmapdialog.h:        gridLayout_3->addWidget(groupBox_2, 1, 1, 1, 1);
ui_newmapdialog.h:        gridLayout_3->addItem(verticalSpacer, 2, 0, 1, 1);
ui_newmapdialog.h:        buttonBox->setObjectName(QStringLiteral("buttonBox"));
ui_newmapdialog.h:        buttonBox->setOrientation(Qt::Horizontal);
ui_newmapdialog.h:        buttonBox->setStandardButtons(QDialogButtonBox::Cancel|QDialogButtonBox::Ok);
ui_newmapdialog.h:        gridLayout_3->addWidget(buttonBox, 3, 0, 1, 2);
ui_newmapdialog.h:        groupBox->setObjectName(QStringLiteral("groupBox"));
ui_newmapdialog.h:        gridLayout_4->setObjectName(QStringLiteral("gridLayout_4"));
ui_newmapdialog.h:        label_5->setObjectName(QStringLiteral("label_5"));
ui_newmapdialog.h:        gridLayout_4->addWidget(label_5, 0, 0, 1, 1);
ui_newmapdialog.h:        orientation->setObjectName(QStringLiteral("orientation"));
ui_newmapdialog.h:        sizePolicy.setHeightForWidth(orientation->sizePolicy().hasHeightForWidth());
ui_newmapdialog.h:        orientation->setSizePolicy(sizePolicy);
ui_newmapdialog.h:        gridLayout_4->addWidget(orientation, 0, 1, 1, 1);
ui_newmapdialog.h:        layerFormatLabel->setObjectName(QStringLiteral("layerFormatLabel"));
ui_newmapdialog.h:        gridLayout_4->addWidget(layerFormatLabel, 1, 0, 1, 1);
ui_newmapdialog.h:        layerFormat->setObjectName(QStringLiteral("layerFormat"));
ui_newmapdialog.h:        gridLayout_4->addWidget(layerFormat, 1, 1, 1, 1);
ui_newmapdialog.h:        renderOrderLabel->setObjectName(QStringLiteral("renderOrderLabel"));
ui_newmapdialog.h:        gridLayout_4->addWidget(renderOrderLabel, 2, 0, 1, 1);
ui_newmapdialog.h:        renderOrder->setObjectName(QStringLiteral("renderOrder"));
ui_newmapdialog.h:        gridLayout_4->addWidget(renderOrder, 2, 1, 1, 1);
ui_newmapdialog.h:        gridLayout_3->addWidget(groupBox, 0, 0, 1, 2);
ui_newmapdialog.h:        label->setBuddy(mapWidth);
ui_newmapdialog.h:        label_2->setBuddy(mapHeight);
ui_newmapdialog.h:        label_3->setBuddy(tileWidth);
ui_newmapdialog.h:        label_4->setBuddy(tileHeight);
ui_newmapdialog.h:        label_5->setBuddy(orientation);
ui_newmapdialog.h:        layerFormatLabel->setBuddy(layerFormat);
ui_newmapdialog.h:        renderOrderLabel->setBuddy(renderOrder);
ui_newmapdialog.h:        NewMapDialog->setWindowTitle(QApplication::translate("NewMapDialog", "New Map", 0));
ui_newmapdialog.h:        groupBox_3->setTitle(QApplication::translate("NewMapDialog", "Map size", 0));
ui_newmapdialog.h:        label->setText(QApplication::translate("NewMapDialog", "Width:", 0));
ui_newmapdialog.h:        mapWidth->setSuffix(QApplication::translate("NewMapDialog", " tiles", 0));
ui_newmapdialog.h:        label_2->setText(QApplication::translate("NewMapDialog", "Height:", 0));
ui_newmapdialog.h:        mapHeight->setSuffix(QApplication::translate("NewMapDialog", " tiles", 0));
ui_newmapdialog.h:        groupBox_2->setTitle(QApplication::translate("NewMapDialog", "Tile size", 0));
ui_newmapdialog.h:        label_3->setText(QApplication::translate("NewMapDialog", "Width:", 0));
ui_newmapdialog.h:        tileWidth->setSuffix(QApplication::translate("NewMapDialog", " px", 0));
ui_newmapdialog.h:        label_4->setText(QApplication::translate("NewMapDialog", "Height:", 0));
ui_newmapdialog.h:        tileHeight->setSuffix(QApplication::translate("NewMapDialog", " px", 0));
ui_newmapdialog.h:        groupBox->setTitle(QApplication::translate("NewMapDialog", "Map", 0));
ui_newmapdialog.h:        label_5->setText(QApplication::translate("NewMapDialog", "Orientation:", 0));
ui_newmapdialog.h:        layerFormatLabel->setText(QApplication::translate("NewMapDialog", "Tile layer format:", 0));
ui_newmapdialog.h:        renderOrderLabel->setText(QApplication::translate("NewMapDialog", "Tile render order:", 0));
Binary file moc_undodock.o matches
Binary file moc_tileselectiontool.o matches
resizemap.cpp:    Map *map = mMapDocument->map();
resizemap.cpp:    QSize oldSize(map->width(), map->height());
resizemap.cpp:    map->setWidth(mSize.width());
resizemap.cpp:    map->setHeight(mSize.height());
resizemap.cpp:    mMapDocument->emitMapChanged();
tileselectiontool.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tileselectiontool.cpp:                               ":images/22x22/stock-tool-rect-select.png")),
tileselectiontool.cpp:        brushItem()->setTileRegion(selectedArea());
tileselectiontool.cpp:    setStatusInfo(tr("%1, %2 - Rectangle: (%3 x %4)")
tileselectiontool.cpp:    const Qt::MouseButton button = event->button();
tileselectiontool.cpp:    const Qt::KeyboardModifiers modifiers = event->modifiers();
tileselectiontool.cpp:        brushItem()->setTileRegion(QRegion());
tileselectiontool.cpp:    if (event->button() == Qt::LeftButton) {
tileselectiontool.cpp:        QRegion selection = document->selectedArea();
tileselectiontool.cpp:        case Subtract:  selection -= area; break;
tileselectiontool.cpp:        if (selection != document->selectedArea()) {
tileselectiontool.cpp:            document->undoStack()->push(cmd);
tileselectiontool.cpp:        brushItem()->setTileRegion(QRegion());
tileselectiontool.cpp:    const QSize size(qAbs(tilePos.x() - mSelectionStart.x()),
tileselectiontool.cpp:                     qAbs(tilePos.y() - mSelectionStart.y()));
moc_stampbrush.cpp:        - idx * sizeof(QByteArrayData) \
moc_stampbrush.cpp:        case 0: _t->stampCaptured((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_stampbrush.cpp:        case 1: _t->setRandom((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_stampbrush.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_stampbrush.cpp:        _id -= 2;
moc_stampbrush.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_stampbrush.cpp:        _id -= 2;
abstracttiletool.h: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file renamelayer.o matches
Binary file aboutdialog.o matches
Binary file changetileobjectgroup.o matches
moc_qtbuttonpropertybrowser.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtbuttonpropertybrowser.cpp:        case 0: _t->collapsed((*reinterpret_cast< QtBrowserItem*(*)>(_a[1]))); break;
moc_qtbuttonpropertybrowser.cpp:        case 1: _t->expanded((*reinterpret_cast< QtBrowserItem*(*)>(_a[1]))); break;
moc_qtbuttonpropertybrowser.cpp:        case 2: _t->d_func()->slotUpdate(); break;
moc_qtbuttonpropertybrowser.cpp:        case 3: _t->d_func()->slotEditorDestroyed(); break;
moc_qtbuttonpropertybrowser.cpp:        case 4: _t->d_func()->slotToggled((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_qtbuttonpropertybrowser.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtbuttonpropertybrowser.cpp:        _id -= 5;
moc_qtbuttonpropertybrowser.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtbuttonpropertybrowser.cpp:        _id -= 5;
Binary file addremovetileset.o matches
patreondialog.ui:<?xml version="1.0" encoding="UTF-8"?>
editpolygontool.cpp:    MapObject *mapObject() const { return mMapObjectItem->mapObject(); }
editpolygontool.cpp:    MapObject *mapObject = mMapObjectItem->mapObject();
editpolygontool.cpp:    QPolygonF polygon = mapObject->polygon();
editpolygontool.cpp:    polygon[mPointIndex] = pos - mapObject->position();
editpolygontool.cpp:    mMapObjectItem->setPolygon(polygon);
editpolygontool.cpp:    return QRectF(-5, -5, 10 + 1, 10 + 1);
editpolygontool.cpp:    painter->setPen(Qt::black);
editpolygontool.cpp:        painter->setBrush(QApplication::palette().highlight());
editpolygontool.cpp:        painter->drawRect(QRectF(-4, -4, 8, 8));
editpolygontool.cpp:        painter->setBrush(Qt::lightGray);
editpolygontool.cpp:        painter->drawRect(QRectF(-3, -3, 6, 6));
editpolygontool.cpp:          QIcon(QLatin1String(":images/24x24/tool-edit-polygons.png")),
editpolygontool.cpp:        const int dragDistance = (mScreenStart - screenPos).manhattanLength();
editpolygontool.cpp:        mSelectionRectangle->setRectangle(QRectF(mStart, pos).normalized());
editpolygontool.cpp:    if (QWidget *widget = event->widget())
editpolygontool.cpp:        if (QGraphicsView *view = static_cast<QGraphicsView*>(widget->parent()))
editpolygontool.cpp:            return view->transform();
editpolygontool.cpp:    switch (event->button()) {
editpolygontool.cpp:        mStart = event->scenePos();
editpolygontool.cpp:        mScreenStart = event->screenPos();
editpolygontool.cpp:        const QList<QGraphicsItem *> items = mapScene()->items(mStart,
editpolygontool.cpp:        const QList<QGraphicsItem *> items = mapScene()->items(event->scenePos(),
editpolygontool.cpp:                                  event->screenPos());
editpolygontool.cpp:    if (event->button() != Qt::LeftButton)
editpolygontool.cpp:            const Qt::KeyboardModifiers modifiers = event->modifiers();
editpolygontool.cpp:            QSet<MapObjectItem*> selection = mapScene()->selectedObjectItems();
editpolygontool.cpp:            const Qt::KeyboardModifiers modifiers = event->modifiers();
editpolygontool.cpp:            mapScene()->setSelectedObjectItems(selection);
editpolygontool.cpp:            mapScene()->setSelectedObjectItems(QSet<MapObjectItem*>());
editpolygontool.cpp:        mapScene()->removeItem(mSelectionRectangle);
editpolygontool.cpp:        finishMoving(event->scenePos());
editpolygontool.cpp:            handle->setSelected(false);
editpolygontool.cpp:            handle->setSelected(true);
editpolygontool.cpp:    const QSet<MapObjectItem*> &selection = mapScene()->selectedObjectItems();
editpolygontool.cpp:                if (handle->isSelected())
editpolygontool.cpp:    MapRenderer *renderer = mapDocument()->renderer();
editpolygontool.cpp:        const MapObject *object = item->mapObject();
editpolygontool.cpp:        if (!object->cell().isEmpty())
editpolygontool.cpp:        QPolygonF polygon = object->polygon();
editpolygontool.cpp:        polygon.translate(object->position());
editpolygontool.cpp:            mapScene()->addItem(handle);
editpolygontool.cpp:            if (handle->isSelected())
editpolygontool.cpp:            const QPointF handlePos = renderer->pixelToScreenCoords(point);
editpolygontool.cpp:            const QPointF internalHandlePos = handlePos - item->pos();
editpolygontool.cpp:            pointHandles.at(i)->setPos(item->mapToScene(internalHandlePos));
editpolygontool.cpp:    QRectF rect = QRectF(mStart, event->scenePos()).normalized();
editpolygontool.cpp:    const QSet<MapObjectItem*> oldSelection = mapScene()->selectedObjectItems();
editpolygontool.cpp:        foreach (QGraphicsItem *item, mapScene()->items(rect,
editpolygontool.cpp:        if (event->modifiers() & (Qt::ControlModifier | Qt::ShiftModifier)) {
editpolygontool.cpp:        mapScene()->setSelectedObjectItems(newSelection);
editpolygontool.cpp:        foreach (QGraphicsItem *item, mapScene()->items(rect,
editpolygontool.cpp:        if (event->modifiers() & (Qt::ControlModifier | Qt::ShiftModifier))
editpolygontool.cpp:    mapScene()->addItem(mSelectionRectangle);
editpolygontool.cpp:    MapRenderer *renderer = mapDocument()->renderer();
editpolygontool.cpp:    mAlignPosition = renderer->screenToPixelCoords((*mSelectedHandles.begin())->pos());
editpolygontool.cpp:        const QPointF pos = renderer->screenToPixelCoords(handle->pos());
editpolygontool.cpp:        mOldHandlePositions.append(handle->pos());
editpolygontool.cpp:        MapObject *mapObject = handle->mapObject();
editpolygontool.cpp:            mOldPolygons.insert(mapObject, mapObject->polygon());
editpolygontool.cpp:    MapRenderer *renderer = mapDocument()->renderer();
editpolygontool.cpp:    QPointF diff = pos - mStart;
editpolygontool.cpp:        const QPointF alignScreenPos = renderer->pixelToScreenCoords(mAlignPosition);
editpolygontool.cpp:        QPointF newAlignPixelPos = renderer->screenToPixelCoords(newAlignScreenPos);
editpolygontool.cpp:        diff = renderer->pixelToScreenCoords(newAlignPixelPos) - alignScreenPos;
editpolygontool.cpp:        handle->setPos(newScreenPos);
editpolygontool.cpp:        const MapObjectItem *item = handle->mapObjectItem();
editpolygontool.cpp:        const QPointF newInternalPos = item->mapFromScene(newScreenPos);
editpolygontool.cpp:        const QPointF newScenePos = item->pos() + newInternalPos;
editpolygontool.cpp:        const QPointF newPixelPos = renderer->screenToPixelCoords(newScenePos);
editpolygontool.cpp:        MapObject *mapObject = item->mapObject();
editpolygontool.cpp:        QPolygonF polygon = mapObject->polygon();
editpolygontool.cpp:        polygon[handle->pointIndex()] = newPixelPos - mapObject->position();
editpolygontool.cpp:        mapDocument()->mapObjectModel()->setObjectPolygon(mapObject, polygon);
editpolygontool.cpp:    if (mStart == pos || mOldPolygons.isEmpty()) // Move is a no-op
editpolygontool.cpp:    QUndoStack *undoStack = mapDocument()->undoStack();
editpolygontool.cpp:    undoStack->beginMacro(tr("Move %n Point(s)", "", mSelectedHandles.size()));
editpolygontool.cpp:        undoStack->push(new ChangePolygon(mapDocument(), i.key(), i.value()));
editpolygontool.cpp:    undoStack->endMacro();
editpolygontool.cpp:    QIcon delIcon(QLatin1String(":images/16x16/edit-delete.png"));
editpolygontool.cpp:    Utils::setThemeIcon(deleteNodesAction, "edit-delete");
editpolygontool.cpp:    joinNodesAction->setEnabled(n > 1);
editpolygontool.cpp:    splitSegmentsAction->setEnabled(n > 1);
editpolygontool.cpp:        RangeSet<int> &pointIndexes = result[handle->mapObject()];
editpolygontool.cpp:        pointIndexes.insert(handle->pointIndex());
editpolygontool.cpp:    QUndoStack *undoStack = mapDocument()->undoStack();
editpolygontool.cpp:    undoStack->beginMacro(delText);
editpolygontool.cpp:        QPolygonF oldPolygon = object->polygon();
editpolygontool.cpp:            --it;
editpolygontool.cpp:            undoStack->push(new RemoveMapObject(mapDocument(), object));
editpolygontool.cpp:            undoStack->push(new ChangePolygon(mapDocument(), object,
editpolygontool.cpp:    undoStack->endMacro();
editpolygontool.cpp:    --lastRange; // We know there is at least one range
editpolygontool.cpp:    if (firstRange.first() == 0 && lastRange.last() == n - 1) {
editpolygontool.cpp:            result.remove(1, firstRange.length() - 1);
editpolygontool.cpp:            indexOffset = firstRange.length() - 1;
editpolygontool.cpp:            --it;
editpolygontool.cpp:        --it;
editpolygontool.cpp:            averagePoint += polygon.at(i - indexOffset);
editpolygontool.cpp:        result.remove(it.first() + 1 - indexOffset, it.length() - 1);
editpolygontool.cpp:        result.replace(it.first() - indexOffset, averagePoint);
editpolygontool.cpp:        --lastRange; // We know there is at least one range
editpolygontool.cpp:        if (firstRange.first() == 0 && lastRange.last() == n - 1) {
editpolygontool.cpp:        --it;
editpolygontool.cpp:        for (int i = it.last(); i > it.first(); --i) {
editpolygontool.cpp:            const QPointF splitPoint = (result.at(i) + result.at(i - 1)) / 2;
editpolygontool.cpp:    QUndoStack *undoStack = mapDocument()->undoStack();
editpolygontool.cpp:        const bool closed = object->shape() == MapObject::Polygon;
editpolygontool.cpp:        QPolygonF oldPolygon = object->polygon();
editpolygontool.cpp:                undoStack->beginMacro(tr("Join Nodes"));
editpolygontool.cpp:            undoStack->push(new ChangePolygon(mapDocument(), object,
editpolygontool.cpp:        undoStack->endMacro();
editpolygontool.cpp:    QUndoStack *undoStack = mapDocument()->undoStack();
editpolygontool.cpp:        const bool closed = object->shape() == MapObject::Polygon;
editpolygontool.cpp:        QPolygonF oldPolygon = object->polygon();
editpolygontool.cpp:                undoStack->beginMacro(tr("Split Segments"));
editpolygontool.cpp:            undoStack->push(new ChangePolygon(mapDocument(), object,
editpolygontool.cpp:        undoStack->endMacro();
ui_exportasimagedialog.h:        if (ExportAsImageDialog->objectName().isEmpty())
ui_exportasimagedialog.h:            ExportAsImageDialog->setObjectName(QStringLiteral("ExportAsImageDialog"));
ui_exportasimagedialog.h:        ExportAsImageDialog->resize(337, 231);
ui_exportasimagedialog.h:        verticalLayout_2->setObjectName(QStringLiteral("verticalLayout_2"));
ui_exportasimagedialog.h:        groupBox->setObjectName(QStringLiteral("groupBox"));
ui_exportasimagedialog.h:        horizontalLayout->setObjectName(QStringLiteral("horizontalLayout"));
ui_exportasimagedialog.h:        label->setObjectName(QStringLiteral("label"));
ui_exportasimagedialog.h:        horizontalLayout->addWidget(label);
ui_exportasimagedialog.h:        fileNameEdit->setObjectName(QStringLiteral("fileNameEdit"));
ui_exportasimagedialog.h:        horizontalLayout->addWidget(fileNameEdit);
ui_exportasimagedialog.h:        browseButton->setObjectName(QStringLiteral("browseButton"));
ui_exportasimagedialog.h:        horizontalLayout->addWidget(browseButton);
ui_exportasimagedialog.h:        verticalLayout_2->addWidget(groupBox);
ui_exportasimagedialog.h:        groupBox_2->setObjectName(QStringLiteral("groupBox_2"));
ui_exportasimagedialog.h:        verticalLayout->setObjectName(QStringLiteral("verticalLayout"));
ui_exportasimagedialog.h:        visibleLayersOnly->setObjectName(QStringLiteral("visibleLayersOnly"));
ui_exportasimagedialog.h:        visibleLayersOnly->setChecked(true);
ui_exportasimagedialog.h:        verticalLayout->addWidget(visibleLayersOnly);
ui_exportasimagedialog.h:        currentZoomLevel->setObjectName(QStringLiteral("currentZoomLevel"));
ui_exportasimagedialog.h:        currentZoomLevel->setChecked(true);
ui_exportasimagedialog.h:        verticalLayout->addWidget(currentZoomLevel);
ui_exportasimagedialog.h:        drawTileGrid->setObjectName(QStringLiteral("drawTileGrid"));
ui_exportasimagedialog.h:        verticalLayout->addWidget(drawTileGrid);
ui_exportasimagedialog.h:        includeBackgroundColor->setObjectName(QStringLiteral("includeBackgroundColor"));
ui_exportasimagedialog.h:        verticalLayout->addWidget(includeBackgroundColor);
ui_exportasimagedialog.h:        verticalLayout_2->addWidget(groupBox_2);
ui_exportasimagedialog.h:        verticalLayout_2->addItem(verticalSpacer);
ui_exportasimagedialog.h:        buttonBox->setObjectName(QStringLiteral("buttonBox"));
ui_exportasimagedialog.h:        buttonBox->setOrientation(Qt::Horizontal);
ui_exportasimagedialog.h:        buttonBox->setStandardButtons(QDialogButtonBox::Cancel|QDialogButtonBox::Save);
ui_exportasimagedialog.h:        verticalLayout_2->addWidget(buttonBox);
ui_exportasimagedialog.h:        label->setBuddy(fileNameEdit);
ui_exportasimagedialog.h:        ExportAsImageDialog->setWindowTitle(QApplication::translate("ExportAsImageDialog", "Export As Image", 0));
ui_exportasimagedialog.h:        groupBox->setTitle(QApplication::translate("ExportAsImageDialog", "Location", 0));
ui_exportasimagedialog.h:        label->setText(QApplication::translate("ExportAsImageDialog", "Name:", 0));
ui_exportasimagedialog.h:        browseButton->setText(QApplication::translate("ExportAsImageDialog", "&Browse...", 0));
ui_exportasimagedialog.h:        groupBox_2->setTitle(QApplication::translate("ExportAsImageDialog", "Settings", 0));
ui_exportasimagedialog.h:        visibleLayersOnly->setText(QApplication::translate("ExportAsImageDialog", "Only include &visible layers", 0));
ui_exportasimagedialog.h:        currentZoomLevel->setText(QApplication::translate("ExportAsImageDialog", "Use current &zoom level", 0));
ui_exportasimagedialog.h:        drawTileGrid->setText(QApplication::translate("ExportAsImageDialog", "&Draw tile grid", 0));
ui_exportasimagedialog.h:        includeBackgroundColor->setText(QApplication::translate("ExportAsImageDialog", "&Include background color", 0));
Binary file brushitem.o matches
moc_qttreepropertybrowser.cpp:        - idx * sizeof(QByteArrayData) \
moc_qttreepropertybrowser.cpp:        case 0: _t->collapsed((*reinterpret_cast< QtBrowserItem*(*)>(_a[1]))); break;
moc_qttreepropertybrowser.cpp:        case 1: _t->expanded((*reinterpret_cast< QtBrowserItem*(*)>(_a[1]))); break;
moc_qttreepropertybrowser.cpp:        case 2: _t->d_func()->slotCollapsed((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_qttreepropertybrowser.cpp:        case 3: _t->d_func()->slotExpanded((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_qttreepropertybrowser.cpp:        case 4: _t->d_func()->slotCurrentBrowserItemChanged((*reinterpret_cast< QtBrowserItem*(*)>(_a[1]))); break;
moc_qttreepropertybrowser.cpp:        case 5: _t->d_func()->slotCurrentTreeItemChanged((*reinterpret_cast< QTreeWidgetItem*(*)>(_a[1])),(*reinterpret_cast< QTreeWidgetItem*(*)>(_a[2]))); break;
moc_qttreepropertybrowser.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qttreepropertybrowser.cpp:        _id -= 6;
moc_qttreepropertybrowser.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qttreepropertybrowser.cpp:        _id -= 6;
moc_qttreepropertybrowser.cpp:        _id -= 7;
moc_qttreepropertybrowser.cpp:        _id -= 7;
moc_qttreepropertybrowser.cpp:        _id -= 7;
moc_qttreepropertybrowser.cpp:        _id -= 7;
moc_qttreepropertybrowser.cpp:        _id -= 7;
moc_qttreepropertybrowser.cpp:        _id -= 7;
moc_qttreepropertybrowser.cpp:        _id -= 7;
moc_qttreepropertybrowser.cpp:        _id -= 7;
moc_qttreepropertybrowser.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qttreepropertybrowser.cpp:        _id -= 7;
movemapobjecttogroup.cpp:    , mOldObjectGroup(mapObject->objectGroup())
movemapobjecttogroup.cpp:    mMapDocument->mapObjectModel()->removeObject(mNewObjectGroup, mMapObject);
movemapobjecttogroup.cpp:    mMapDocument->mapObjectModel()->insertObject(mOldObjectGroup, -1, mMapObject);
movemapobjecttogroup.cpp:    mMapDocument->mapObjectModel()->removeObject(mOldObjectGroup, mMapObject);
movemapobjecttogroup.cpp:    mMapDocument->mapObjectModel()->insertObject(mNewObjectGroup, -1, mMapObject);
Binary file addremovemapobject.o matches
preferences.h: * Copyright 2009-2011, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
moc_propertiesdock.cpp:        - idx * sizeof(QByteArrayData) \
moc_propertiesdock.cpp:        case 0: _t->bringToFront(); break;
moc_propertiesdock.cpp:        case 1: _t->mapDocumentChanged((*reinterpret_cast< MapDocument*(*)>(_a[1]))); break;
moc_propertiesdock.cpp:        case 2: _t->currentObjectChanged((*reinterpret_cast< Object*(*)>(_a[1]))); break;
moc_propertiesdock.cpp:        case 3: _t->currentItemChanged((*reinterpret_cast< QtBrowserItem*(*)>(_a[1]))); break;
moc_propertiesdock.cpp:        case 4: _t->tilesetFileNameChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_propertiesdock.cpp:        case 5: _t->addProperty(); break;
moc_propertiesdock.cpp:        case 6: _t->addProperty((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_propertiesdock.cpp:        case 7: _t->removeProperty(); break;
moc_propertiesdock.cpp:        case 8: _t->renameProperty(); break;
moc_propertiesdock.cpp:        case 9: _t->renameProperty((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_propertiesdock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_propertiesdock.cpp:        _id -= 10;
moc_propertiesdock.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_propertiesdock.cpp:        _id -= 10;
createtileobjecttool.cpp:    setIcon(QIcon(QLatin1String(":images/24x24/insert-image.png")));
createtileobjecttool.cpp:    Utils::setThemeIcon(this, "insert-image");
createtileobjecttool.cpp:    const MapRenderer *renderer = mapDocument()->renderer();
createtileobjecttool.cpp:    const QSize imgSize = mNewMapObjectItem->mapObject()->cell().tile->size();
createtileobjecttool.cpp:    const QPointF diff(-imgSize.width() / 2, imgSize.height() / 2);
createtileobjecttool.cpp:    QPointF pixelCoords = renderer->screenToPixelCoords(pos + diff);
createtileobjecttool.cpp:    mNewMapObjectItem->mapObject()->setPosition(pixelCoords);
createtileobjecttool.cpp:    mNewMapObjectItem->syncWithMapObject();
createtileobjecttool.cpp:    mNewMapObjectItem->setZValue(10000); // sync may change it
createtileobjecttool.cpp:    mNewMapObjectItem->setOpacity(0.75);
createtileobjecttool.cpp:    if (event->button() == Qt::RightButton)
createtileobjecttool.cpp:    if (event->button() == Qt::LeftButton)
createtileobjecttool.cpp:        mNewMapObjectItem->setOpacity(0.75);
createtileobjecttool.cpp:    newMapObject->setShape(MapObject::Rectangle);
createtileobjecttool.cpp:    newMapObject->setCell(Cell(mTile));
createtileobjecttool.cpp:    newMapObject->setSize(mTile->size());
Binary file moc_tilesetview.o matches
geometry.cpp: * Copyright 2010-2011, Stefan Beller <stefanbeller@googlemail.com>
geometry.cpp:    int radiusX = x0 > x1 ? x0 - x1 : x1 - x0;
geometry.cpp:    int radiusY = y0 > y1 ? y0 - y1 : y1 - y0;
geometry.cpp:    xChange = radiusY * radiusY * (1 - 2 * radiusX);
geometry.cpp:        ret += QPoint(x0 - x, y0 + y);
geometry.cpp:        ret += QPoint(x0 + x, y0 - y);
geometry.cpp:        ret += QPoint(x0 - x, y0 - y);
geometry.cpp:            x--;
geometry.cpp:            stoppingX -= twoYSquare;
geometry.cpp:    yChange = radiusX * radiusX * (1 - 2 * radiusY);
geometry.cpp:        ret += QPoint(x0 - x, y0 + y);
geometry.cpp:        ret += QPoint(x0 + x, y0 - y);
geometry.cpp:        ret += QPoint(x0 - x, y0 - y);
geometry.cpp:            y--;
geometry.cpp:            stoppingY -= twoXSquare;
geometry.cpp:    const bool steep = qAbs(y1 - y0) > qAbs(x1 - x0);
geometry.cpp:    const int deltax = x1 - x0;
geometry.cpp:    const int deltay = qAbs(y1 - y0);
geometry.cpp:        ystep = -1;
geometry.cpp:        error = error - deltay;
geometry.cpp:    if (region.intersects(rect.adjusted(0, -1, 0, 1)))
geometry.cpp:    if (region.intersects(rect.adjusted(-1, 0, 1, 0)))
geometry.cpp:            for (int i = rects.size() - 1; i >= 0; --i) {
Binary file moc_preferencesdialog.o matches
Binary file changetileterrain.o matches
Binary file moc_tilesetmanager.o matches
Binary file movelayer.o matches
moc_createmultipointobjecttool.cpp:        - idx * sizeof(QByteArrayData) \
moc_createmultipointobjecttool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
zoomable.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
zoomable.cpp:    if (delta <= -120) {
zoomable.cpp:        // We're dealing with a finer-resolution mouse. Allow it to have finer
zoomable.cpp:    if (!(pinch->changeFlags() & QPinchGesture::ScaleFactorChanged))
zoomable.cpp:    switch (pinch->state()) {
zoomable.cpp:        qreal factor = pinch->scaleFactor();
zoomable.cpp:    for (int i = mZoomFactors.count() - 1; i >= 0; --i) {
zoomable.cpp:        mComboBox->disconnect(this);
zoomable.cpp:        if (mComboBox->lineEdit())
zoomable.cpp:            mComboBox->lineEdit()->disconnect(this);
zoomable.cpp:        mComboBox->setValidator(0);
zoomable.cpp:        mComboBox->clear();
zoomable.cpp:            mComboBox->addItem(scaleToString(scale), scale);
zoomable.cpp:        mComboBox->setEditable(true);
zoomable.cpp:        mComboBox->setInsertPolicy(QComboBox::NoInsert);
zoomable.cpp:        connect(mComboBox->lineEdit(), SIGNAL(editingFinished()),
zoomable.cpp:        mComboBox->setValidator(mComboValidator);
zoomable.cpp:    setScale(mComboBox->itemData(index).toReal());
zoomable.cpp:    int pos = mComboRegExp.indexIn(mComboBox->currentText());
zoomable.cpp:    Q_ASSERT(pos != -1);
zoomable.cpp:    int index = mComboBox->findData(mScale);
zoomable.cpp:    // For a custom scale, the current index must be set to -1
zoomable.cpp:    mComboBox->setCurrentIndex(index);
zoomable.cpp:    mComboBox->setEditText(scaleToString(mScale));
abstractimagetool.cpp:    event->ignore();
abstractimagetool.cpp:    const QPointF tilePosF = mapDocument()->renderer()->screenToTileCoords(pos);
abstractimagetool.cpp:    return dynamic_cast<ImageLayer*>(mapDocument()->currentLayer());
Binary file moc_createobjecttool.o matches
Binary file createpolylineobjecttool.o matches
selectionrectangle.cpp:    return mRectangle.adjusted(-1, -1, 2, 2);
selectionrectangle.cpp:    painter->setPen(pen);
selectionrectangle.cpp:    painter->drawRect(mRectangle.translated(1, 1));
selectionrectangle.cpp:    painter->setPen(pen);
selectionrectangle.cpp:    painter->setBrush(highlight);
selectionrectangle.cpp:    painter->drawRect(mRectangle);
moc_tilestampsdock.cpp:        - idx * sizeof(QByteArrayData) \
moc_tilestampsdock.cpp:        case 0: _t->setStamp((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_tilestampsdock.cpp:        case 1: _t->currentRowChanged((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_tilestampsdock.cpp:        case 2: _t->showContextMenu((*reinterpret_cast< QPoint(*)>(_a[1]))); break;
moc_tilestampsdock.cpp:        case 3: _t->newStamp(); break;
moc_tilestampsdock.cpp:        case 4: _t->delete_(); break;
moc_tilestampsdock.cpp:        case 5: _t->duplicate(); break;
moc_tilestampsdock.cpp:        case 6: _t->addVariation(); break;
moc_tilestampsdock.cpp:        case 7: _t->chooseFolder(); break;
moc_tilestampsdock.cpp:        case 8: _t->ensureStampVisible((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_tilestampsdock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tilestampsdock.cpp:        _id -= 9;
moc_tilestampsdock.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tilestampsdock.cpp:        _id -= 9;
moc_tilestampsdock.cpp:        - idx * sizeof(QByteArrayData) \
moc_tilestampsdock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
Binary file resizedialog.o matches
moc_movabletabwidget.cpp:        - idx * sizeof(QByteArrayData) \
moc_movabletabwidget.cpp:        case 0: _t->tabMoved((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_movabletabwidget.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_movabletabwidget.cpp:        _id -= 1;
moc_movabletabwidget.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_movabletabwidget.cpp:        _id -= 1;
Binary file moc_toolmanager.o matches
Binary file createellipseobjecttool.o matches
Binary file moc_tilecollisioneditor.o matches
Binary file moc_createtileobjecttool.o matches
tilepainter.h: * Copyright 2009-2011, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
commanddatamodel.cpp:const char *commandMimeType = "application/x-tiled-commandptr";
commanddatamodel.cpp:        command.command = QLatin1String("open -t %mapfile");
commanddatamodel.cpp:            if (i->row() > row)
commanddatamodel.cpp:                *i = i->sibling(i->row() - 1, i->column());
commanddatamodel.cpp:            QAction *action = menu->addAction(tr("Move Up"));
commanddatamodel.cpp:            mapper->setMapping(action, row);
commanddatamodel.cpp:            QAction *action = menu->addAction(tr("Move Down"));
commanddatamodel.cpp:            mapper->setMapping(action, row + 1);
commanddatamodel.cpp:        menu->addSeparator();
commanddatamodel.cpp:            QAction *action = menu->addAction(tr("Execute"));
commanddatamodel.cpp:            mapper->setMapping(action, row);
commanddatamodel.cpp:            QAction *action = menu->addAction(tr("Execute in Terminal"));
commanddatamodel.cpp:            mapper->setMapping(action, row);
commanddatamodel.cpp:        menu->addSeparator();
commanddatamodel.cpp:            QAction *action = menu->addAction(tr("Delete"));
commanddatamodel.cpp:            mapper->setMapping(action, row);
commanddatamodel.cpp:    int row = -1;
commanddatamodel.cpp:        if (row != -1 && index.row() != row)
commanddatamodel.cpp:    mimeData->setText(command.finalCommand());
commanddatamodel.cpp:    // will result in a no-op instead of moving the wrong thing.
commanddatamodel.cpp:    mimeData->setData(QLatin1String(commandMimeType),
commanddatamodel.cpp:    if (data->hasFormat(QLatin1String(commandMimeType))) {
commanddatamodel.cpp:        const QByteArray byteData = data->data(QLatin1String(commandMimeType));
commanddatamodel.cpp:                    append(Command(addr->isEnabled,
commanddatamodel.cpp:                                   tr("%1 (copy)").arg(addr->name),
commanddatamodel.cpp:                                   addr->command));
commanddatamodel.cpp:    if (data->hasText()) {
commanddatamodel.cpp:            return setData(parent, data->text(), Qt::EditRole);
commanddatamodel.cpp:            append(Command(true, tr("New command"), data->text()));
commanddatamodel.cpp:    if (commandIndex - newIndex == 1 || newIndex - commandIndex == 1)
commanddatamodel.cpp:    move(commandIndex, commandIndex - 1);
createellipseobjecttool.cpp:    setIcon(QIcon(QLatin1String(":images/24x24/insert-ellipse.png")));
createellipseobjecttool.cpp:    Utils::setThemeIcon(this, "insert-ellipse");
createellipseobjecttool.cpp:    newMapObject->setShape(MapObject::Ellipse);
main.cpp: * Copyright 2008-2011, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
main.cpp:                QLatin1String("--version"),
main.cpp:                QLatin1String("--quit"),
main.cpp:                QLatin1String("--disable-opengl"),
main.cpp:                QLatin1String("--export-map"),
main.cpp:                QLatin1String("--export-formats"),
main.cpp:    PluginManager::instance()->loadPlugins();
main.cpp:        if (format->hasCapabilities(MapFormat::Write))
main.cpp:            qWarning() << " " << format->nameFilter();
main.cpp:    QString baseName = QApplication::style()->objectName();
main.cpp:    languageManager->installTranslators();
main.cpp:        Preferences::instance()->setUseOpenGL(false);
main.cpp:    PluginManager::instance()->loadPlugins();
main.cpp:                                                                 "Export syntax is --export-map [format] <tmx file> <target file>"));
main.cpp:                if (!format->hasCapabilities(MapFormat::Write))
main.cpp:                if (format->nameFilter().compare(*filter, Qt::CaseInsensitive) == 0) {
main.cpp:                                                                     "Format not recognized (see --export-formats)"));
main.cpp:                if (!format->hasCapabilities(MapFormat::Write))
main.cpp:                if (format->nameFilter().contains(suffix, Qt::CaseInsensitive)) {
main.cpp:                                                                             "Non-unique file extension. Can't determine correct export format."));
main.cpp:        bool success = chosenFormat->write(map.data(), targetFile);
main.cpp:    } else if (Preferences::instance()->openLastFilesOnStartup()) {
Binary file editterraindialog.o matches
resizedialog.ui:<?xml version="1.0" encoding="UTF-8"?>
resizedialog.ui:         <number>-99999</number>
resizedialog.ui:         <number>-99999</number>
moc_terrainview.cpp:        - idx * sizeof(QByteArrayData) \
moc_terrainview.cpp:        case 0: _t->editTerrainProperties(); break;
moc_terrainview.cpp:        case 1: _t->adjustScale(); break;
moc_terrainview.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_terrainview.cpp:        _id -= 2;
moc_terrainview.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_terrainview.cpp:        _id -= 2;
moc_commanddialog.cpp:        - idx * sizeof(QByteArrayData) \
moc_commanddialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_commanddialog.cpp:        - idx * sizeof(QByteArrayData) \
moc_commanddialog.cpp:        case 0: _t->contextMenuEvent((*reinterpret_cast< QContextMenuEvent*(*)>(_a[1]))); break;
moc_commanddialog.cpp:        case 1: _t->handleRowsRemoved((*reinterpret_cast< const QModelIndex(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_commanddialog.cpp:        case 2: _t->removeSelectedCommands(); break;
moc_commanddialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_commanddialog.cpp:        _id -= 3;
moc_commanddialog.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_commanddialog.cpp:        _id -= 3;
moc_createtileobjecttool.cpp:        - idx * sizeof(QByteArrayData) \
moc_createtileobjecttool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_toolmanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_toolmanager.cpp:        case 0: _t->selectedToolChanged((*reinterpret_cast< AbstractTool*(*)>(_a[1]))); break;
moc_toolmanager.cpp:        case 1: _t->statusInfoChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_toolmanager.cpp:        case 2: _t->actionTriggered((*reinterpret_cast< QAction*(*)>(_a[1]))); break;
moc_toolmanager.cpp:        case 3: _t->toolEnabledChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_toolmanager.cpp:        case 4: _t->selectEnabledTool(); break;
moc_toolmanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_toolmanager.cpp:        _id -= 5;
moc_toolmanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_toolmanager.cpp:        _id -= 5;
qtpropertymanager.moc:        - idx * sizeof(QByteArrayData) \
qtpropertymanager.moc:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
qtpropertymanager.moc:        _id -= 1;
qtpropertymanager.moc:        _id -= 1;
qtpropertymanager.moc:        _id -= 1;
qtpropertymanager.moc:        _id -= 1;
qtpropertymanager.moc:        _id -= 1;
qtpropertymanager.moc:        _id -= 1;
qtpropertymanager.moc:        _id -= 1;
qtpropertymanager.moc:        _id -= 1;
qtpropertymanager.moc:            *reinterpret_cast<int*>(_a[0]) = -1;
qtpropertymanager.moc:        _id -= 1;
terrainmodel.cpp: * Copyright 2008-2012, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
terrainmodel.cpp:    int row = indexOf(mMapDocument->map()->tilesets(), tileset);
terrainmodel.cpp:    Q_ASSERT(row != -1);
terrainmodel.cpp:    Tileset *tileset = terrain->tileset();
terrainmodel.cpp:    int row = tileset->terrains().indexOf(terrain);
terrainmodel.cpp:        return index(terrain->tileset());
terrainmodel.cpp:        return mMapDocument->map()->tilesetCount();
terrainmodel.cpp:        return tileset->terrainCount();
terrainmodel.cpp:            return terrain->name();
terrainmodel.cpp:            if (Tile *imageTile = terrain->imageTile())
terrainmodel.cpp:                return imageTile->image();
terrainmodel.cpp:            return tileset->name();
terrainmodel.cpp:        if (terrain->name() != newName) {
terrainmodel.cpp:                                                      terrain->tileset(),
terrainmodel.cpp:                                                      terrain->id(),
terrainmodel.cpp:            mMapDocument->undoStack()->push(rename);
terrainmodel.cpp:    if (index.row() >= mMapDocument->map()->tilesetCount())
terrainmodel.cpp:    return mMapDocument->map()->tilesetAt(index.row()).data();
terrainmodel.cpp:        return tileset->terrain(index.row());
terrainmodel.cpp:    tileset->insertTerrain(index, terrain);
terrainmodel.cpp:    Terrain *terrain = tileset->takeTerrainAt(index);
terrainmodel.cpp:    Terrain *terrain = tileset->terrain(index);
terrainmodel.cpp:    terrain->setName(name);
terrainmodel.cpp:    Terrain *terrain = tileset->terrain(index);
terrainmodel.cpp:    terrain->setImageTileId(tileId);
terrainmodel.cpp:    emit terrainChanged(terrain->tileset(), index.row());
abstracttool.cpp: * Copyright 2009-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
abstracttool.cpp:    event->ignore();
objectselectiontool.h: * Copyright 2010-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
abstracttool.h: * Copyright 2009-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file moc_objecttypesmodel.o matches
mapdocument.cpp: * Copyright 2008-2014, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
mapdocument.cpp:    mCurrentLayerIndex = (map->layerCount() == 0) ? -1 : 0;
mapdocument.cpp:    mLayerModel->setMapDocument(this);
mapdocument.cpp:    mMapObjectModel->setMapDocument(this);
mapdocument.cpp:    tilesetManager->addReferences(mMap->tilesets());
mapdocument.cpp:    tilesetManager->removeReferences(mMap->tilesets());
mapdocument.cpp:    if (!mapFormat->write(map(), fileName)) {
mapdocument.cpp:            *error = mapFormat->errorString();
mapdocument.cpp:    undoStack()->setClean();
mapdocument.cpp:            if (format->supportsFile(fileName)) {
mapdocument.cpp:        map = mapFormat->read(fileName);
mapdocument.cpp:        errorString = mapFormat->errorString();
mapdocument.cpp:        mapDocument->setReaderFormat(mapFormat);
mapdocument.cpp:        if (mapFormat->hasCapabilities(MapFormat::Write))
mapdocument.cpp:            mapDocument->setWriterFormat(mapFormat);
mapdocument.cpp:    return !mUndoStack->isClean();
mapdocument.cpp:    Q_ASSERT(index >= -1 && index < mMap->layerCount());
mapdocument.cpp:    if (changed && mCurrentLayerIndex != -1)
mapdocument.cpp:    if (mCurrentLayerIndex == -1)
mapdocument.cpp:    return mMap->layerAt(mCurrentLayerIndex);
mapdocument.cpp: * non-empty area of overlap, but we should also consider overlap with empty
mapdocument.cpp:    QRectF boundingRect = renderer->boundingRect(object);
mapdocument.cpp:    if (object->rotation() != 0) {
mapdocument.cpp:        QPointF pos = renderer->pixelToScreenCoords(object->position());
mapdocument.cpp:        boundingRect.translate(-pos);
mapdocument.cpp:        transform.rotate(object->rotation());
mapdocument.cpp:    const QRect newArea = QRect(-offset, size);
mapdocument.cpp:    const QRectF visibleArea = mRenderer->boundingRect(newArea);
mapdocument.cpp:    const QPointF origin = mRenderer->tileToPixelCoords(QPointF());
mapdocument.cpp:    const QPointF newOrigin = mRenderer->tileToPixelCoords(-offset);
mapdocument.cpp:    const QPointF pixelOffset = origin - newOrigin;
mapdocument.cpp:    mUndoStack->beginMacro(tr("Resize Map"));
mapdocument.cpp:    for (int i = 0; i < mMap->layerCount(); ++i) {
mapdocument.cpp:        Layer *layer = mMap->layerAt(i);
mapdocument.cpp:        switch (layer->layerType()) {
mapdocument.cpp:            mUndoStack->push(new ResizeTileLayer(this, tileLayer, size, offset));
mapdocument.cpp:            foreach (MapObject *o, objectGroup->objects()) {
mapdocument.cpp:                    mUndoStack->push(new RemoveMapObject(this, o));
mapdocument.cpp:                    QPointF oldPos = o->position();
mapdocument.cpp:                    mUndoStack->push(new MoveMapObject(this, o, newPos, oldPos));
mapdocument.cpp:    mUndoStack->push(new ResizeMap(this, size));
mapdocument.cpp:    mUndoStack->push(new ChangeSelectedArea(this, movedSelection));
mapdocument.cpp:    mUndoStack->endMacro();
mapdocument.cpp:        mUndoStack->push(new OffsetLayer(this, layerIndexes.first(), offset,
mapdocument.cpp:        mUndoStack->beginMacro(tr("Offset Map"));
mapdocument.cpp:            mUndoStack->push(new OffsetLayer(this, layerIndex, offset,
mapdocument.cpp:        mUndoStack->endMacro();
mapdocument.cpp:    mUndoStack->push(new FlipMapObjects(this, mSelectedObjects, direction));
mapdocument.cpp:    mUndoStack->beginMacro(tr("Rotate %n Object(s)", "",
mapdocument.cpp:        const qreal oldRotation = mapObject->rotation();
mapdocument.cpp:            newRotation -= 90;
mapdocument.cpp:            if (newRotation < -180)
mapdocument.cpp:                newRotation -= 360;
mapdocument.cpp:        mUndoStack->push(new RotateMapObject(this, mapObject,
mapdocument.cpp:    mUndoStack->endMacro();
mapdocument.cpp:        name = tr("Tile Layer %1").arg(mMap->tileLayerCount() + 1);
mapdocument.cpp:        layer = new TileLayer(name, 0, 0, mMap->width(), mMap->height());
mapdocument.cpp:        name = tr("Object Layer %1").arg(mMap->objectGroupCount() + 1);
mapdocument.cpp:        layer = new ObjectGroup(name, 0, 0, mMap->width(), mMap->height());
mapdocument.cpp:        name = tr("Image Layer %1").arg(mMap->imageLayerCount() + 1);
mapdocument.cpp:        layer = new ImageLayer(name, 0, 0, mMap->width(), mMap->height());
mapdocument.cpp:    const int index = mMap->layerCount();
mapdocument.cpp:    mUndoStack->push(new AddLayer(this, index, layer));
mapdocument.cpp:    if (mCurrentLayerIndex == -1)
mapdocument.cpp:    Layer *duplicate = mMap->layerAt(mCurrentLayerIndex)->clone();
mapdocument.cpp:    duplicate->setName(tr("Copy of %1").arg(duplicate->name()));
mapdocument.cpp:    cmd->setText(tr("Duplicate Layer"));
mapdocument.cpp:    mUndoStack->push(cmd);
mapdocument.cpp:    Layer *upperLayer = mMap->layerAt(mCurrentLayerIndex);
mapdocument.cpp:    Layer *lowerLayer = mMap->layerAt(mCurrentLayerIndex - 1);
mapdocument.cpp:    if (!lowerLayer->canMergeWith(upperLayer))
mapdocument.cpp:    Layer *merged = lowerLayer->mergedWith(upperLayer);
mapdocument.cpp:    mUndoStack->beginMacro(tr("Merge Layer Down"));
mapdocument.cpp:    mUndoStack->push(new AddLayer(this, mCurrentLayerIndex - 1, merged));
mapdocument.cpp:    mUndoStack->push(new RemoveLayer(this, mCurrentLayerIndex));
mapdocument.cpp:    mUndoStack->push(new RemoveLayer(this, mCurrentLayerIndex));
mapdocument.cpp:    mUndoStack->endMacro();
mapdocument.cpp:    if (index < 0 || index >= mMap->layerCount() - 1)
mapdocument.cpp:    mUndoStack->push(new MoveLayer(this, index, MoveLayer::Up));
mapdocument.cpp:    if (index < 1 || index >= mMap->layerCount())
mapdocument.cpp:    mUndoStack->push(new MoveLayer(this, index, MoveLayer::Down));
mapdocument.cpp:    if (index < 0 || index >= mMap->layerCount())
mapdocument.cpp:    mUndoStack->push(new RemoveLayer(this, index));
mapdocument.cpp:    mLayerModel->toggleOtherLayers(index);
mapdocument.cpp:    mMap->insertTileset(index, tileset);
mapdocument.cpp:    tilesetManager->addReference(tileset);
mapdocument.cpp:    if (object->typeId() == Object::TileType
mapdocument.cpp:            && tileset == static_cast<Tile*>(object)->tileset())
mapdocument.cpp:    if (object->typeId() == Object::TerrainType
mapdocument.cpp:            && tileset == static_cast<Terrain*>(object)->tileset())
mapdocument.cpp:    SharedTileset tileset = mMap->tilesets().at(index);
mapdocument.cpp:    mMap->removeTilesetAt(index);
mapdocument.cpp:    tilesetManager->removeReference(tileset);
mapdocument.cpp:    SharedTileset tileset = mMap->tilesets().at(from);
mapdocument.cpp:    mMap->removeTilesetAt(from);
mapdocument.cpp:    mMap->insertTileset(to, tileset);
mapdocument.cpp:        if (mCurrentObject->typeId() == Object::MapObjectType && !mSelectedObjects.isEmpty()) {
mapdocument.cpp:        } else if (mCurrentObject->typeId() == Object::TileType && !mSelectedTiles.isEmpty()) {
mapdocument.cpp:    const QVector<SharedTileset> &existingTilesets = mMap->tilesets();
mapdocument.cpp:    foreach (const SharedTileset &tileset, map->tilesets()) {
mapdocument.cpp:        SharedTileset replacement = tileset->findSimilarTileset(existingTilesets);
mapdocument.cpp:        const int sharedTileCount = qMin(tileset->tileCount(),
mapdocument.cpp:                                         replacement->tileCount());
mapdocument.cpp:            Tile *replacementTile = replacement->tileAt(i);
mapdocument.cpp:            Properties properties = replacementTile->properties();
mapdocument.cpp:            properties.merge(tileset->tileAt(i)->properties());
mapdocument.cpp:        map->replaceTileset(tileset, replacement);
mapdocument.cpp:        tilesetManager->addReference(replacement);
mapdocument.cpp:        tilesetManager->removeReference(tileset);
mapdocument.cpp:        mUndoStack->beginMacro(tr("Tileset Changes"));
mapdocument.cpp:            mUndoStack->push(command);
mapdocument.cpp:        mUndoStack->endMacro();
mapdocument.cpp:    const QVector<SharedTileset> &existingTilesets = mMap->tilesets();
mapdocument.cpp:    foreach (const SharedTileset &tileset, map->tilesets()) {
mapdocument.cpp:        SharedTileset replacement = tileset->findSimilarTileset(existingTilesets);
mapdocument.cpp:        map->replaceTileset(tileset, replacement);
mapdocument.cpp:        tilesetManager->addReference(replacement);
mapdocument.cpp:        tilesetManager->removeReference(tileset);
mapdocument.cpp:    Q_ASSERT(contains(mMap->tilesets(), tileset));
mapdocument.cpp:    ObjectGroup *objectGroup = mMapObjectModel->toObjectGroup(parent);
mapdocument.cpp:    ObjectGroup *objectGroup = mMapObjectModel->toObjectGroup(parent);
mapdocument.cpp:    const int lastIndex = objectGroup->objectCount() - 1;
mapdocument.cpp:    ObjectGroup *objectGroup = mMapObjectModel->toObjectGroup(parent);
mapdocument.cpp:    const int last = qMax(end, row - 1);
mapdocument.cpp:    if (mMap->layerCount() == 1)
mapdocument.cpp:    Layer *layer = mMap->layerAt(index);
mapdocument.cpp:        deselectObjects(og->objects());
mapdocument.cpp:    bool currentLayerRemoved = mCurrentLayerIndex == mMap->layerCount();
mapdocument.cpp:        mCurrentLayerIndex = mCurrentLayerIndex - 1;
mapdocument.cpp:    if (mCurrentObject && mCurrentObject->typeId() == Object::MapObjectType)
mapdocument.cpp:    tileset->setFileName(fileName);
mapdocument.cpp:    tileset->setName(name);
mapdocument.cpp:    tileset->setTileOffset(tileOffset);
mapdocument.cpp:    mMap->recomputeDrawMargins();
mapdocument.cpp:    mUndoStack->beginMacro(tr("Duplicate %n Object(s)", "", objects.size()));
mapdocument.cpp:        MapObject *clone = mapObject->clone();
mapdocument.cpp:        mUndoStack->push(new AddMapObject(this,
mapdocument.cpp:                                          mapObject->objectGroup(),
mapdocument.cpp:    mUndoStack->endMacro();
mapdocument.cpp:    mUndoStack->beginMacro(tr("Remove %n Object(s)", "", objects.size()));
mapdocument.cpp:        mUndoStack->push(new RemoveMapObject(this, mapObject));
mapdocument.cpp:    mUndoStack->endMacro();
mapdocument.cpp:    mUndoStack->beginMacro(tr("Move %n Object(s) to Layer", "",
mapdocument.cpp:        if (mapObject->objectGroup() == objectGroup)
mapdocument.cpp:        mUndoStack->push(new MoveMapObjectToGroup(this,
mapdocument.cpp:    mUndoStack->endMacro();
mapdocument.cpp:    const bool hadProperty = object->hasProperty(name);
mapdocument.cpp:    object->setProperty(name, value);
mapdocument.cpp:    object->setProperties(properties);
mapdocument.cpp:    object->removeProperty(name);
mapdocument.cpp:    switch (mMap->orientation()) {
Binary file exportasimagedialog.o matches
movetileset.cpp:    mMapDocument->moveTileset(mTo, mFrom);
movetileset.cpp:    mMapDocument->moveTileset(mFrom, mTo);
movetileset.cpp:    if (mMapDocument != o->mMapDocument)
movetileset.cpp:    const bool otherIsOneStep = qAbs(o->mFrom - o->mTo) == 1;
movetileset.cpp:    const bool isOneStep = qAbs(mFrom - mTo) == 1;
movetileset.cpp:    if (mTo == mFrom) {              // This command is a no-op
movetileset.cpp:        mTo = o->mTo;
movetileset.cpp:        mFrom = o->mFrom;
movetileset.cpp:    } else if (o->mTo == o->mFrom) { // The other command is a no-op
movetileset.cpp:    } else if (o->mFrom == mTo) {    // Regular transitive relation logic
movetileset.cpp:        mTo = o->mTo;
movetileset.cpp:    } else if (otherIsOneStep && o->mTo == mTo) { // Consider other swapped
movetileset.cpp:        mTo = o->mFrom;
movetileset.cpp:    } else if (isOneStep && o->mFrom == mFrom) {  // Consider this swapped
movetileset.cpp:        mTo = o->mTo;
movetileset.cpp:    } else if (otherIsOneStep && isOneStep && o->mTo == mFrom) { // Swap both
movetileset.cpp:        mTo = o->mFrom;
automapperwrapper.h: * Copyright 2010-2011, Stefan Beller, stefanbeller@googlemail.com
ui_newtilesetdialog.h:        if (NewTilesetDialog->objectName().isEmpty())
ui_newtilesetdialog.h:            NewTilesetDialog->setObjectName(QStringLiteral("NewTilesetDialog"));
ui_newtilesetdialog.h:        NewTilesetDialog->resize(387, 314);
ui_newtilesetdialog.h:        verticalLayout->setObjectName(QStringLiteral("verticalLayout"));
ui_newtilesetdialog.h:        verticalLayout->setSizeConstraint(QLayout::SetMinAndMaxSize);
ui_newtilesetdialog.h:        tilesetGroupBox->setObjectName(QStringLiteral("tilesetGroupBox"));
ui_newtilesetdialog.h:        sizePolicy.setHeightForWidth(tilesetGroupBox->sizePolicy().hasHeightForWidth());
ui_newtilesetdialog.h:        tilesetGroupBox->setSizePolicy(sizePolicy);
ui_newtilesetdialog.h:        gridLayout_2->setObjectName(QStringLiteral("gridLayout_2"));
ui_newtilesetdialog.h:        tilesetType->setObjectName(QStringLiteral("tilesetType"));
ui_newtilesetdialog.h:        sizePolicy1.setHeightForWidth(tilesetType->sizePolicy().hasHeightForWidth());
ui_newtilesetdialog.h:        tilesetType->setSizePolicy(sizePolicy1);
ui_newtilesetdialog.h:        gridLayout_2->addWidget(tilesetType, 1, 1, 1, 1);
ui_newtilesetdialog.h:        typeLabel->setObjectName(QStringLiteral("typeLabel"));
ui_newtilesetdialog.h:        gridLayout_2->addWidget(typeLabel, 1, 0, 1, 1);
ui_newtilesetdialog.h:        nameLabel->setObjectName(QStringLiteral("nameLabel"));
ui_newtilesetdialog.h:        gridLayout_2->addWidget(nameLabel, 0, 0, 1, 1);
ui_newtilesetdialog.h:        name->setObjectName(QStringLiteral("name"));
ui_newtilesetdialog.h:        sizePolicy2.setHeightForWidth(name->sizePolicy().hasHeightForWidth());
ui_newtilesetdialog.h:        name->setSizePolicy(sizePolicy2);
ui_newtilesetdialog.h:        gridLayout_2->addWidget(name, 0, 1, 1, 1);
ui_newtilesetdialog.h:        verticalLayout->addWidget(tilesetGroupBox);
ui_newtilesetdialog.h:        imageGroupBox->setObjectName(QStringLiteral("imageGroupBox"));
ui_newtilesetdialog.h:        sizePolicy.setHeightForWidth(imageGroupBox->sizePolicy().hasHeightForWidth());
ui_newtilesetdialog.h:        imageGroupBox->setSizePolicy(sizePolicy);
ui_newtilesetdialog.h:        imageGroupBox->setCheckable(false);
ui_newtilesetdialog.h:        gridLayout->setObjectName(QStringLiteral("gridLayout"));
ui_newtilesetdialog.h:        sourceLabel->setObjectName(QStringLiteral("sourceLabel"));
ui_newtilesetdialog.h:        sizePolicy3.setHeightForWidth(sourceLabel->sizePolicy().hasHeightForWidth());
ui_newtilesetdialog.h:        sourceLabel->setSizePolicy(sizePolicy3);
ui_newtilesetdialog.h:        gridLayout->addWidget(sourceLabel, 0, 0, 1, 1);
ui_newtilesetdialog.h:        browseButton->setObjectName(QStringLiteral("browseButton"));
ui_newtilesetdialog.h:        gridLayout->addWidget(browseButton, 0, 4, 1, 1);
ui_newtilesetdialog.h:        useTransparentColor->setObjectName(QStringLiteral("useTransparentColor"));
ui_newtilesetdialog.h:        gridLayout->addWidget(useTransparentColor, 1, 0, 1, 2);
ui_newtilesetdialog.h:        colorButton->setObjectName(QStringLiteral("colorButton"));
ui_newtilesetdialog.h:        colorButton->setEnabled(false);
ui_newtilesetdialog.h:        gridLayout->addWidget(colorButton, 1, 2, 1, 1);
ui_newtilesetdialog.h:        gridLayout->addItem(horizontalSpacer_2, 1, 3, 1, 1);
ui_newtilesetdialog.h:        gridLayout_3->setObjectName(QStringLiteral("gridLayout_3"));
ui_newtilesetdialog.h:        tileHeight->setObjectName(QStringLiteral("tileHeight"));
ui_newtilesetdialog.h:        tileHeight->setMinimum(1);
ui_newtilesetdialog.h:        tileHeight->setMaximum(9999);
ui_newtilesetdialog.h:        tileHeight->setValue(32);
ui_newtilesetdialog.h:        gridLayout_3->addWidget(tileHeight, 1, 1, 1, 1);
ui_newtilesetdialog.h:        tileHeightLabel->setObjectName(QStringLiteral("tileHeightLabel"));
ui_newtilesetdialog.h:        gridLayout_3->addWidget(tileHeightLabel, 1, 0, 1, 1);
ui_newtilesetdialog.h:        gridLayout_3->addItem(horizontalSpacer, 1, 2, 1, 1);
ui_newtilesetdialog.h:        tileWidth->setObjectName(QStringLiteral("tileWidth"));
ui_newtilesetdialog.h:        tileWidth->setEnabled(true);
ui_newtilesetdialog.h:        tileWidth->setMinimum(1);
ui_newtilesetdialog.h:        tileWidth->setMaximum(9999);
ui_newtilesetdialog.h:        tileWidth->setValue(32);
ui_newtilesetdialog.h:        gridLayout_3->addWidget(tileWidth, 0, 1, 1, 1);
ui_newtilesetdialog.h:        marginLabel->setObjectName(QStringLiteral("marginLabel"));
ui_newtilesetdialog.h:        gridLayout_3->addWidget(marginLabel, 0, 3, 1, 1);
ui_newtilesetdialog.h:        margin->setObjectName(QStringLiteral("margin"));
ui_newtilesetdialog.h:        margin->setMinimum(0);
ui_newtilesetdialog.h:        margin->setMaximum(9999);
ui_newtilesetdialog.h:        margin->setValue(0);
ui_newtilesetdialog.h:        gridLayout_3->addWidget(margin, 0, 4, 1, 1);
ui_newtilesetdialog.h:        spacing->setObjectName(QStringLiteral("spacing"));
ui_newtilesetdialog.h:        spacing->setMinimum(0);
ui_newtilesetdialog.h:        spacing->setMaximum(9999);
ui_newtilesetdialog.h:        spacing->setValue(0);
ui_newtilesetdialog.h:        gridLayout_3->addWidget(spacing, 1, 4, 1, 1);
ui_newtilesetdialog.h:        tileWidthLabel->setObjectName(QStringLiteral("tileWidthLabel"));
ui_newtilesetdialog.h:        gridLayout_3->addWidget(tileWidthLabel, 0, 0, 1, 1);
ui_newtilesetdialog.h:        spacingLabel->setObjectName(QStringLiteral("spacingLabel"));
ui_newtilesetdialog.h:        gridLayout_3->addWidget(spacingLabel, 1, 3, 1, 1);
ui_newtilesetdialog.h:        gridLayout_3->addItem(horizontalSpacer_3, 1, 5, 1, 1);
ui_newtilesetdialog.h:        gridLayout->addLayout(gridLayout_3, 2, 0, 1, 5);
ui_newtilesetdialog.h:        image->setObjectName(QStringLiteral("image"));
ui_newtilesetdialog.h:        gridLayout->addWidget(image, 0, 1, 1, 3);
ui_newtilesetdialog.h:        verticalLayout->addWidget(imageGroupBox);
ui_newtilesetdialog.h:        buttonBox->setObjectName(QStringLiteral("buttonBox"));
ui_newtilesetdialog.h:        buttonBox->setOrientation(Qt::Horizontal);
ui_newtilesetdialog.h:        buttonBox->setStandardButtons(QDialogButtonBox::Cancel|QDialogButtonBox::Ok);
ui_newtilesetdialog.h:        verticalLayout->addWidget(buttonBox);
ui_newtilesetdialog.h:        nameLabel->setBuddy(name);
ui_newtilesetdialog.h:        NewTilesetDialog->setWindowTitle(QApplication::translate("NewTilesetDialog", "New Tileset", 0));
ui_newtilesetdialog.h:        tilesetGroupBox->setTitle(QApplication::translate("NewTilesetDialog", "Tileset", 0));
ui_newtilesetdialog.h:        tilesetType->clear();
ui_newtilesetdialog.h:        tilesetType->insertItems(0, QStringList()
ui_newtilesetdialog.h:        typeLabel->setText(QApplication::translate("NewTilesetDialog", "Type:", 0));
ui_newtilesetdialog.h:        nameLabel->setText(QApplication::translate("NewTilesetDialog", "&Name:", 0));
ui_newtilesetdialog.h:        imageGroupBox->setTitle(QApplication::translate("NewTilesetDialog", "Image", 0));
ui_newtilesetdialog.h:        sourceLabel->setText(QApplication::translate("NewTilesetDialog", "Source:", 0));
ui_newtilesetdialog.h:        browseButton->setText(QApplication::translate("NewTilesetDialog", "&Browse...", 0));
ui_newtilesetdialog.h:        useTransparentColor->setText(QApplication::translate("NewTilesetDialog", "Use transparent color:", 0));
ui_newtilesetdialog.h:        tileHeight->setSuffix(QApplication::translate("NewTilesetDialog", " px", 0));
ui_newtilesetdialog.h:        tileHeightLabel->setText(QApplication::translate("NewTilesetDialog", "Tile height:", 0));
ui_newtilesetdialog.h:        tileWidth->setSuffix(QApplication::translate("NewTilesetDialog", " px", 0));
ui_newtilesetdialog.h:        marginLabel->setToolTip(QApplication::translate("NewTilesetDialog", "The space at the edges of the tileset.", 0));
ui_newtilesetdialog.h:        marginLabel->setText(QApplication::translate("NewTilesetDialog", "Margin:", 0));
ui_newtilesetdialog.h:        margin->setSuffix(QApplication::translate("NewTilesetDialog", " px", 0));
ui_newtilesetdialog.h:        spacing->setSuffix(QApplication::translate("NewTilesetDialog", " px", 0));
ui_newtilesetdialog.h:        tileWidthLabel->setText(QApplication::translate("NewTilesetDialog", "Tile width:", 0));
ui_newtilesetdialog.h:        spacingLabel->setToolTip(QApplication::translate("NewTilesetDialog", "The space between the tiles.", 0));
ui_newtilesetdialog.h:        spacingLabel->setText(QApplication::translate("NewTilesetDialog", "Spacing:", 0));
filesystemwatcher.h: * It's meant to be used as drop-in replacement for QFileSystemWatcher.
aboutdialog.ui:<?xml version="1.0" encoding="UTF-8"?>
aboutdialog.ui:        <pixmap resource="tiled.qrc">:/images/about-tiled-logo.png</pixmap>
Binary file terrainbrush.o matches
Binary file stampbrush.o matches
Binary file tilesetmanager.o matches
tileselectiontool.h: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tilestampmodel.h:    return i == -1 ? QModelIndex() : TileStampModel::index(i, 0);
moc_tileselectiontool.cpp:        - idx * sizeof(QByteArrayData) \
moc_tileselectiontool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_abstractobjecttool.cpp:        - idx * sizeof(QByteArrayData) \
moc_abstractobjecttool.cpp:        case 0: _t->duplicateObjects(); break;
moc_abstractobjecttool.cpp:        case 1: _t->removeObjects(); break;
moc_abstractobjecttool.cpp:        case 2: _t->flipHorizontally(); break;
moc_abstractobjecttool.cpp:        case 3: _t->flipVertically(); break;
moc_abstractobjecttool.cpp:        case 4: _t->raise(); break;
moc_abstractobjecttool.cpp:        case 5: _t->lower(); break;
moc_abstractobjecttool.cpp:        case 6: _t->raiseToTop(); break;
moc_abstractobjecttool.cpp:        case 7: _t->lowerToBottom(); break;
moc_abstractobjecttool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_abstractobjecttool.cpp:        _id -= 8;
moc_abstractobjecttool.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_abstractobjecttool.cpp:        _id -= 8;
moc_tileanimationdriver.cpp:        - idx * sizeof(QByteArrayData) \
moc_tileanimationdriver.cpp:        case 0: _t->update((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_tileanimationdriver.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tileanimationdriver.cpp:        _id -= 1;
moc_tileanimationdriver.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tileanimationdriver.cpp:        _id -= 1;
moc_preferencesdialog.cpp:        - idx * sizeof(QByteArrayData) \
moc_preferencesdialog.cpp:        case 0: _t->languageSelected((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_preferencesdialog.cpp:        case 1: _t->objectLineWidthChanged((*reinterpret_cast< double(*)>(_a[1]))); break;
moc_preferencesdialog.cpp:        case 2: _t->useOpenGLToggled((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferencesdialog.cpp:        case 3: _t->useAutomappingDrawingToggled((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferencesdialog.cpp:        case 4: _t->openLastFilesToggled((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferencesdialog.cpp:        case 5: _t->addObjectType(); break;
moc_preferencesdialog.cpp:        case 6: _t->selectedObjectTypesChanged(); break;
moc_preferencesdialog.cpp:        case 7: _t->removeSelectedObjectTypes(); break;
moc_preferencesdialog.cpp:        case 8: _t->objectTypeIndexClicked((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_preferencesdialog.cpp:        case 9: _t->applyObjectTypes(); break;
moc_preferencesdialog.cpp:        case 10: _t->importObjectTypes(); break;
moc_preferencesdialog.cpp:        case 11: _t->exportObjectTypes(); break;
moc_preferencesdialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_preferencesdialog.cpp:        _id -= 12;
moc_preferencesdialog.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_preferencesdialog.cpp:        _id -= 12;
Binary file moc_selectsametiletool.o matches
Binary file changelayer.o matches
Binary file moc_abstractimagetool.o matches
moc_tilecollisioneditor.cpp:        - idx * sizeof(QByteArrayData) \
moc_tilecollisioneditor.cpp:        case 0: _t->closed(); break;
moc_tilecollisioneditor.cpp:        case 1: _t->setTile((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_tilecollisioneditor.cpp:        case 2: _t->setSelectedTool((*reinterpret_cast< AbstractTool*(*)>(_a[1]))); break;
moc_tilecollisioneditor.cpp:        case 3: _t->applyChanges(); break;
moc_tilecollisioneditor.cpp:        case 4: _t->tileObjectGroupChanged((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_tilecollisioneditor.cpp:        case 5: _t->tilesetFileNameChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_tilecollisioneditor.cpp:        case 6: _t->currentObjectChanged((*reinterpret_cast< Object*(*)>(_a[1]))); break;
moc_tilecollisioneditor.cpp:        case 7: _t->undo(); break;
moc_tilecollisioneditor.cpp:        case 8: _t->redo(); break;
moc_tilecollisioneditor.cpp:        case 9: _t->cut(); break;
moc_tilecollisioneditor.cpp:        case 10: _t->copy(); break;
moc_tilecollisioneditor.cpp:        case 11: _t->paste(); break;
moc_tilecollisioneditor.cpp:        case 12: _t->delete_((*reinterpret_cast< Operation(*)>(_a[1]))); break;
moc_tilecollisioneditor.cpp:        case 13: _t->delete_(); break;
moc_tilecollisioneditor.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tilecollisioneditor.cpp:        _id -= 14;
moc_tilecollisioneditor.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tilecollisioneditor.cpp:        _id -= 14;
moc_objectsdock.cpp:        - idx * sizeof(QByteArrayData) \
moc_objectsdock.cpp:        case 0: _t->updateActions(); break;
moc_objectsdock.cpp:        case 1: _t->aboutToShowMoveToMenu(); break;
moc_objectsdock.cpp:        case 2: _t->triggeredMoveToMenu((*reinterpret_cast< QAction*(*)>(_a[1]))); break;
moc_objectsdock.cpp:        case 3: _t->objectProperties(); break;
moc_objectsdock.cpp:        case 4: _t->documentAboutToClose((*reinterpret_cast< MapDocument*(*)>(_a[1]))); break;
moc_objectsdock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_objectsdock.cpp:        _id -= 5;
moc_objectsdock.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_objectsdock.cpp:        _id -= 5;
moc_objectsdock.cpp:        - idx * sizeof(QByteArrayData) \
moc_objectsdock.cpp:        case 0: _t->onPressed((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_objectsdock.cpp:        case 1: _t->onActivated((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_objectsdock.cpp:        case 2: _t->onSectionResized((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_objectsdock.cpp:        case 3: _t->selectedObjectsChanged(); break;
moc_objectsdock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_objectsdock.cpp:        _id -= 4;
moc_objectsdock.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_objectsdock.cpp:        _id -= 4;
tiled.qrc:        <file>images/about-tiled-logo.png</file>
tiled.qrc:        <file>images/16x16/application-exit.png</file>
tiled.qrc:        <file>images/16x16/document-export.png</file>
tiled.qrc:        <file>images/16x16/document-import.png</file>
tiled.qrc:        <file>images/16x16/document-new.png</file>
tiled.qrc:        <file>images/16x16/document-open.png</file>
tiled.qrc:        <file>images/16x16/document-open-recent.png</file>
tiled.qrc:        <file>images/16x16/document-page-setup.png</file>
tiled.qrc:        <file>images/16x16/document-properties.png</file>
tiled.qrc:        <file>images/16x16/document-save.png</file>
tiled.qrc:        <file>images/16x16/document-save-as.png</file>
tiled.qrc:        <file>images/16x16/drive-harddisk.png</file>
tiled.qrc:        <file>images/16x16/edit-clear.png</file>
tiled.qrc:        <file>images/16x16/edit-copy.png</file>
tiled.qrc:        <file>images/16x16/edit-cut.png</file>
tiled.qrc:        <file>images/16x16/edit-delete.png</file>
tiled.qrc:        <file>images/16x16/edit-paste.png</file>
tiled.qrc:        <file>images/16x16/edit-redo.png</file>
tiled.qrc:        <file>images/16x16/edit-undo.png</file>
tiled.qrc:        <file>images/16x16/go-down.png</file>
tiled.qrc:        <file>images/16x16/go-up.png</file>
tiled.qrc:        <file>images/16x16/help-about.png</file>
tiled.qrc:        <file>images/16x16/window-close.png</file>
tiled.qrc:        <file>images/16x16/stock-duplicate-16.png</file>
tiled.qrc:        <file>images/16x16/terminal-green.png</file>
tiled.qrc:        <file>images/16x16/terminal-red.png</file>
tiled.qrc:        <file>images/16x16/zoom-in.png</file>
tiled.qrc:        <file>images/16x16/zoom-original.png</file>
tiled.qrc:        <file>images/16x16/zoom-out.png</file>
tiled.qrc:        <file>images/22x22/stock-tool-clone.png</file>
tiled.qrc:        <file>images/22x22/stock-tool-eraser.png</file>
tiled.qrc:        <file>images/22x22/stock-tool-rect-select.png</file>
tiled.qrc:        <file>images/22x22/tool-select-objects.png</file>
tiled.qrc:        <file>images/22x22/stock-tool-by-color-select.png</file>
tiled.qrc:        <file>images/24x24/document-new.png</file>
tiled.qrc:        <file>images/24x24/document-open.png</file>
tiled.qrc:        <file>images/24x24/document-open-recent.png</file>
tiled.qrc:        <file>images/24x24/document-page-setup.png</file>
tiled.qrc:        <file>images/24x24/document-properties.png</file>
tiled.qrc:        <file>images/24x24/document-save.png</file>
tiled.qrc:        <file>images/24x24/document-save-as.png</file>
tiled.qrc:        <file>images/24x24/drive-harddisk.png</file>
tiled.qrc:        <file>images/24x24/edit-clear.png</file>
tiled.qrc:        <file>images/24x24/edit-cut.png</file>
tiled.qrc:        <file>images/24x24/edit-copy.png</file>
tiled.qrc:        <file>images/24x24/edit-paste.png</file>
tiled.qrc:        <file>images/24x24/edit-redo.png</file>
tiled.qrc:        <file>images/24x24/edit-undo.png</file>
tiled.qrc:        <file>images/24x24/go-down.png</file>
tiled.qrc:        <file>images/24x24/go-up.png</file>
tiled.qrc:        <file>images/24x24/help-about.png</file>
tiled.qrc:        <file>images/24x24/insert-ellipse.png</file>
tiled.qrc:        <file>images/24x24/insert-image.png</file>
tiled.qrc:        <file>images/24x24/insert-object.png</file>
tiled.qrc:        <file>images/24x24/insert-polygon.png</file>
tiled.qrc:        <file>images/24x24/insert-polyline.png</file>
tiled.qrc:        <file>images/24x24/insert-rectangle.png</file>
tiled.qrc:        <file>images/24x24/zoom-in.png</file>
tiled.qrc:        <file>images/24x24/zoom-original.png</file>
tiled.qrc:        <file>images/24x24/zoom-out.png</file>
tiled.qrc:        <file>images/24x24/tool-edit-polygons.png</file>
tiled.qrc:        <file>images/22x22/stock-tool-bucket-fill.png</file>
tiled.qrc:        <file>images/16x16/layer-image.png</file>
tiled.qrc:        <file>images/16x16/layer-object.png</file>
tiled.qrc:        <file>images/16x16/layer-tile.png</file>
tiled.qrc:        <file>images/24x24/system-run.png</file>
tiled.qrc:        <file>images/24x24/terrain-edit.png</file>
tiled.qrc:        <file>images/24x24/move-image-layer.png</file>
tiled.qrc:        <file>images/22x22/stock-tool-fuzzy-select-22.png</file>
Binary file moc_mainwindow.o matches
Binary file newmapdialog.o matches
moc_colorbutton.cpp:        - idx * sizeof(QByteArrayData) \
moc_colorbutton.cpp:        case 0: _t->colorChanged((*reinterpret_cast< const QColor(*)>(_a[1]))); break;
moc_colorbutton.cpp:        case 1: _t->pickColor(); break;
moc_colorbutton.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_colorbutton.cpp:        _id -= 2;
moc_colorbutton.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_colorbutton.cpp:        _id -= 2;
documentmanager.moc:        - idx * sizeof(QByteArrayData) \
documentmanager.moc:        case 0: _t->reload(); break;
documentmanager.moc:        case 1: _t->ignore(); break;
documentmanager.moc:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
documentmanager.moc:        _id -= 2;
documentmanager.moc:            *reinterpret_cast<int*>(_a[0]) = -1;
documentmanager.moc:        _id -= 2;
documentmanager.moc:        - idx * sizeof(QByteArrayData) \
documentmanager.moc:        case 0: _t->reload(); break;
documentmanager.moc:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
documentmanager.moc:        _id -= 1;
documentmanager.moc:            *reinterpret_cast<int*>(_a[0]) = -1;
documentmanager.moc:        _id -= 1;
mainwindow.ui:<?xml version="1.0" encoding="UTF-8"?>
mainwindow.ui:       <normaloff>:/images/16x16/document-open-recent.png</normaloff>:/images/16x16/document-open-recent.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/document-open.png</normaloff>:/images/16x16/document-open.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/document-save.png</normaloff>:/images/16x16/document-save.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/application-exit.png</normaloff>:/images/16x16/application-exit.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/edit-copy.png</normaloff>:/images/16x16/edit-copy.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/edit-paste.png</normaloff>:/images/16x16/edit-paste.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/help-about.png</normaloff>:/images/16x16/help-about.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/document-page-setup.png</normaloff>:/images/16x16/document-page-setup.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/document-properties.png</normaloff>:/images/16x16/document-properties.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/document-save-as.png</normaloff>:/images/16x16/document-save-as.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/document-new.png</normaloff>:/images/16x16/document-new.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/document-new.png</normaloff>:/images/16x16/document-new.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/document-new.png</normaloff>:/images/16x16/document-new.png</iconset> 
mainwindow.ui:     <normaloff>:/images/16x16/window-close.png</normaloff>:/images/16x16/window-close.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/zoom-in.png</normaloff>:/images/16x16/zoom-in.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/zoom-out.png</normaloff>:/images/16x16/zoom-out.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/zoom-original.png</normaloff>:/images/16x16/zoom-original.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/edit-cut.png</normaloff>:/images/16x16/edit-cut.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/edit-clear.png</normaloff>:/images/16x16/edit-clear.png</iconset>
mainwindow.ui:     <normaloff>:/images/16x16/edit-delete.png</normaloff>:/images/16x16/edit-delete.png</iconset>
Binary file moc_minimapdock.o matches
layermodel.h: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file terrainmodel.o matches
Binary file changeproperties.o matches
moc_minimap.cpp:        - idx * sizeof(QByteArrayData) \
moc_minimap.cpp:        case 0: _t->scheduleMapImageUpdate(); break;
moc_minimap.cpp:        case 1: _t->redrawTimeout(); break;
moc_minimap.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_minimap.cpp:        _id -= 2;
moc_minimap.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_minimap.cpp:        _id -= 2;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotRangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotSingleStepChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 3: _t->d_func()->slotReadOnlyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 4: _t->d_func()->slotSetValue((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 5: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 6;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 6;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotRangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotSingleStepChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 3: _t->d_func()->slotSetValue((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 4: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 5;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 5;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotRangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotSingleStepChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 3: _t->d_func()->slotSetValue((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 4: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 5;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 5;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotTextVisibleChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotSetValue((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 3: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 4;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 4;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotRangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2])),(*reinterpret_cast< double(*)>(_a[3]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotSingleStepChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 3: _t->d_func()->slotDecimalsChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 4: _t->d_func()->slotReadOnlyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 5: _t->d_func()->slotSetValue((*reinterpret_cast< double(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 6: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 7;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 7;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotRegExpChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRegExp(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotEchoModeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 3: _t->d_func()->slotReadOnlyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 4: _t->d_func()->slotSetValue((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 5: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 6;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 6;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDate(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotRangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDate(*)>(_a[2])),(*reinterpret_cast< const QDate(*)>(_a[3]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotSetValue((*reinterpret_cast< const QDate(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 3: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 4;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 4;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QTime(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotSetValue((*reinterpret_cast< const QTime(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDateTime(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotSetValue((*reinterpret_cast< const QDateTime(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QKeySequence(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotSetValue((*reinterpret_cast< const QKeySequence(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QChar(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotSetValue((*reinterpret_cast< const QChar(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotEnumNamesChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QStringList(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotEnumIconsChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QMap<int,QIcon>(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 3: _t->d_func()->slotSetValue((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 4: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 5;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 5;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QCursor(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotEnumChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QColor(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotSetValue((*reinterpret_cast< const QColor(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_qteditorfactory.cpp:        case 0: _t->d_func()->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QFont(*)>(_a[2]))); break;
moc_qteditorfactory.cpp:        case 1: _t->d_func()->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:        case 2: _t->d_func()->slotSetValue((*reinterpret_cast< const QFont(*)>(_a[1]))); break;
moc_qteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qteditorfactory.cpp:        _id -= 3;
moc_qteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qteditorfactory.cpp:        _id -= 3;
tilestampmanager.h: * Copyright 2010-2011, Stefan Beller <stefanbeller@googlemail.com>
tilestampmanager.h: * Copyright 2014-2015, Thorbj√∏rn Lindeijer <bjorn@lindeijer.nl>
Binary file abstracttiletool.o matches
Binary file moc_preferences.o matches
Binary file toolmanager.o matches
moc_commandbutton.cpp:        - idx * sizeof(QByteArrayData) \
moc_commandbutton.cpp:        case 0: _t->runCommand(); break;
moc_commandbutton.cpp:        case 1: _t->showDialog(); break;
moc_commandbutton.cpp:        case 2: _t->populateMenu(); break;
moc_commandbutton.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_commandbutton.cpp:        _id -= 3;
moc_commandbutton.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_commandbutton.cpp:        _id -= 3;
moc_mapdocumentactionhandler.cpp:        - idx * sizeof(QByteArrayData) \
moc_mapdocumentactionhandler.cpp:        case 0: _t->mapDocumentChanged((*reinterpret_cast< MapDocument*(*)>(_a[1]))); break;
moc_mapdocumentactionhandler.cpp:        case 1: _t->selectAll(); break;
moc_mapdocumentactionhandler.cpp:        case 2: _t->selectNone(); break;
moc_mapdocumentactionhandler.cpp:        case 3: _t->copyPosition(); break;
moc_mapdocumentactionhandler.cpp:        case 4: _t->cropToSelection(); break;
moc_mapdocumentactionhandler.cpp:        case 5: _t->addTileLayer(); break;
moc_mapdocumentactionhandler.cpp:        case 6: _t->addObjectGroup(); break;
moc_mapdocumentactionhandler.cpp:        case 7: _t->addImageLayer(); break;
moc_mapdocumentactionhandler.cpp:        case 8: _t->duplicateLayer(); break;
moc_mapdocumentactionhandler.cpp:        case 9: _t->mergeLayerDown(); break;
moc_mapdocumentactionhandler.cpp:        case 10: _t->selectPreviousLayer(); break;
moc_mapdocumentactionhandler.cpp:        case 11: _t->selectNextLayer(); break;
moc_mapdocumentactionhandler.cpp:        case 12: _t->moveLayerUp(); break;
moc_mapdocumentactionhandler.cpp:        case 13: _t->moveLayerDown(); break;
moc_mapdocumentactionhandler.cpp:        case 14: _t->removeLayer(); break;
moc_mapdocumentactionhandler.cpp:        case 15: _t->toggleOtherLayers(); break;
moc_mapdocumentactionhandler.cpp:        case 16: _t->layerProperties(); break;
moc_mapdocumentactionhandler.cpp:        case 17: _t->duplicateObjects(); break;
moc_mapdocumentactionhandler.cpp:        case 18: _t->removeObjects(); break;
moc_mapdocumentactionhandler.cpp:        case 19: _t->moveObjectsToGroup((*reinterpret_cast< ObjectGroup*(*)>(_a[1]))); break;
moc_mapdocumentactionhandler.cpp:        case 20: _t->updateActions(); break;
moc_mapdocumentactionhandler.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_mapdocumentactionhandler.cpp:        _id -= 21;
moc_mapdocumentactionhandler.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_mapdocumentactionhandler.cpp:        _id -= 21;
Binary file undodock.o matches
moc_variantpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_variantpropertymanager.cpp:        case 0: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QVariant(*)>(_a[2]))); break;
moc_variantpropertymanager.cpp:        case 1: _t->setAttribute((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2])),(*reinterpret_cast< const QVariant(*)>(_a[3]))); break;
moc_variantpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_variantpropertymanager.cpp:        _id -= 2;
moc_variantpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_variantpropertymanager.cpp:        _id -= 2;
Binary file mapobjectitem.o matches
commandlineparser.cpp:        if (noMoreArguments || arg.at(0) != QLatin1Char('-')) {
commandlineparser.cpp:        if (arg.at(1) == QLatin1Char('-')) {
commandlineparser.cpp:            // Double hypen "--" means no more options will follow
commandlineparser.cpp:    qWarning("  -h %-*s : %s", mLongestArgument, "--help", qPrintable(tr("Display this help")));
commandlineparser.cpp:            qWarning("  -%c %-*s : %s",
commandlineparser.cpp:            qWarning("     %-*s : %s",
commandlineparser.cpp:    if (longName == QLatin1String("--help")) {
renamelayer.cpp:    const Layer *layer = mMapDocument->map()->layerAt(mLayerIndex);
renamelayer.cpp:    const QString previousName = layer->name();
renamelayer.cpp:    mMapDocument->layerModel()->renameLayer(mLayerIndex, mName);
tilepainter.cpp: * Copyright 2009-2011, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tilepainter.cpp:        , mDrawMargins(layer->drawMargins())
tilepainter.cpp:        if (mTileLayer->map() == mMapDocument->map())
tilepainter.cpp:            if (mTileLayer->drawMargins() != mDrawMargins)
tilepainter.cpp:                mMapDocument->emitTileLayerDrawMarginsChanged(mTileLayer);
tilepainter.cpp:    const int layerX = x - mTileLayer->x();
tilepainter.cpp:    const int layerY = y - mTileLayer->y();
tilepainter.cpp:    if (!mTileLayer->contains(layerX, layerY))
tilepainter.cpp:    return mTileLayer->cellAt(layerX, layerY);
tilepainter.cpp:    const QRegion &selection = mMapDocument->selectedArea();
tilepainter.cpp:    const int layerX = x - mTileLayer->x();
tilepainter.cpp:    const int layerY = y - mTileLayer->y();
tilepainter.cpp:    if (!mTileLayer->contains(layerX, layerY))
tilepainter.cpp:    mTileLayer->setCell(layerX, layerY, cell);
tilepainter.cpp:    mMapDocument->emitRegionChanged(QRegion(x, y, 1, 1), mTileLayer);
tilepainter.cpp:                                     tileLayer->width(),
tilepainter.cpp:                                     tileLayer->height());
tilepainter.cpp:    mTileLayer->setCells(x - mTileLayer->x(),
tilepainter.cpp:                         y - mTileLayer->y(),
tilepainter.cpp:                         region.translated(-mTileLayer->position()));
tilepainter.cpp:    mMapDocument->emitRegionChanged(region, mTileLayer);
tilepainter.cpp:                                           tileLayer->width(),
tilepainter.cpp:                                           tileLayer->height());
tilepainter.cpp:                const Cell &cell = tileLayer->cellAt(_x - x, _y - y);
tilepainter.cpp:                mTileLayer->setCell(_x - mTileLayer->x(),
tilepainter.cpp:                                    _y - mTileLayer->y(),
tilepainter.cpp:    mMapDocument->emitRegionChanged(region, mTileLayer);
tilepainter.cpp:    if (stamp->bounds().isEmpty())
tilepainter.cpp:    const int w = stamp->width();
tilepainter.cpp:    const int h = stamp->height();
tilepainter.cpp:                const int stampX = (_x - regionBounds.left()) % w;
tilepainter.cpp:                const int stampY = (_y - regionBounds.top()) % h;
tilepainter.cpp:                const Cell &cell = stamp->cellAt(stampX, stampY);
tilepainter.cpp:                mTileLayer->setCell(_x - mTileLayer->x(),
tilepainter.cpp:                                    _y - mTileLayer->y(),
tilepainter.cpp:    mMapDocument->emitRegionChanged(region, mTileLayer);
tilepainter.cpp:    mTileLayer->erase(paintable.translated(-mTileLayer->position()));
tilepainter.cpp:    mMapDocument->emitRegionChanged(paintable, mTileLayer);
tilepainter.cpp:    if (!layer->contains(fillOrigin))
tilepainter.cpp:    const Cell matchCell = layer->cellAt(fillOrigin);
tilepainter.cpp:    const int layerWidth = layer->width();
tilepainter.cpp:    const int layerHeight = layer->height();
tilepainter.cpp:        while (left > 0 && layer->cellAt(left - 1, currentPoint.y()) == matchCell)
tilepainter.cpp:            --left;
tilepainter.cpp:        while (right + 1 < layerWidth && layer->cellAt(right + 1, currentPoint.y()) == matchCell)
tilepainter.cpp:        fillRegion += QRegion(left, currentPoint.y(), right - left + 1, 1);
tilepainter.cpp:               right - left);
tilepainter.cpp:                QPoint aboveCell(fillPoint.x(), fillPoint.y() - 1);
tilepainter.cpp:                    layer->cellAt(aboveCell) == matchCell)
tilepainter.cpp:                    // x-adjacent cell was added.
tilepainter.cpp:                    layer->cellAt(belowCell) == matchCell)
tilepainter.cpp:                    // x-adjacent cell was added.
tilepainter.cpp:    QRegion region = fillRegion(mTileLayer, fillOrigin - mTileLayer->position());
tilepainter.cpp:    region.translate(mTileLayer->position());
tilepainter.cpp:    const QRegion &selection = mMapDocument->selectedArea();
tilepainter.cpp:    QRegion region = fillRegion(mTileLayer, fillOrigin - mTileLayer->position());
tilepainter.cpp:    return region.translated(mTileLayer->position());
tilepainter.cpp:    const QRegion &selection = mMapDocument->selectedArea();
tilepainter.cpp:    const int layerX = x - mTileLayer->x();
tilepainter.cpp:    const int layerY = y - mTileLayer->y();
tilepainter.cpp:    if (!mTileLayer->contains(layerX, layerY))
tilepainter.cpp:    const QRegion bounds = QRegion(mTileLayer->bounds());
tilepainter.cpp:    const QRegion &selection = mMapDocument->selectedArea();
Binary file tilepainter.o matches
offsetlayer.cpp: * Copyright 2009-2014, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
offsetlayer.cpp:    Layer *layer = mMapDocument->map()->layerAt(mIndex);
offsetlayer.cpp:    mOffsetLayer = layer->clone();
offsetlayer.cpp:    switch (mOffsetLayer->layerType()) {
offsetlayer.cpp:        static_cast<TileLayer*>(mOffsetLayer)->offsetTiles(offset, bounds, wrapX, wrapY);
offsetlayer.cpp:        MapRenderer *renderer = mapDocument->renderer();
offsetlayer.cpp:        const QPointF origin = renderer->tileToPixelCoords(QPointF());
offsetlayer.cpp:        const QPointF pixelOffset = renderer->tileToPixelCoords(offset) - origin;
offsetlayer.cpp:        const QRectF pixelBounds = renderer->tileToPixelCoords(bounds);
offsetlayer.cpp:        static_cast<ObjectGroup*>(mOffsetLayer)->offsetObjects(pixelOffset, pixelBounds, wrapX, wrapY);
offsetlayer.cpp:    const int currentIndex = mMapDocument->currentLayerIndex();
offsetlayer.cpp:    LayerModel *layerModel = mMapDocument->layerModel();
offsetlayer.cpp:    Layer *replaced = layerModel->takeLayerAt(mIndex);
offsetlayer.cpp:    layerModel->insertLayer(mIndex, layer);
offsetlayer.cpp:        mMapDocument->setCurrentLayerIndex(mIndex);
tilesetdock.cpp: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tilesetdock.cpp:        QString previousFileName = mTileset->fileName();
tilesetdock.cpp:        mMapDocument->setTilesetFileName(mTileset, mFileName);
tilesetdock.cpp:    foreach (Layer *layer, mapDocument->map()->layers()) {
tilesetdock.cpp:        if (TileLayer *tileLayer = layer->asTileLayer()) {
tilesetdock.cpp:            if (tileLayer->hasCell(condition))
tilesetdock.cpp:        } else if (ObjectGroup *objectGroup = layer->asObjectGroup()) {
tilesetdock.cpp:            foreach (MapObject *object, objectGroup->objects()) {
tilesetdock.cpp:                if (condition(object->cell()))
tilesetdock.cpp:    QUndoStack *undoStack = mapDocument->undoStack();
tilesetdock.cpp:    foreach (Layer *layer, mapDocument->map()->layers()) {
tilesetdock.cpp:        if (TileLayer *tileLayer = layer->asTileLayer()) {
tilesetdock.cpp:            const QRegion refs = tileLayer->region(condition);
tilesetdock.cpp:                undoStack->push(new EraseTiles(mapDocument, tileLayer, refs));
tilesetdock.cpp:        } else if (ObjectGroup *objectGroup = layer->asObjectGroup()) {
tilesetdock.cpp:            foreach (MapObject *object, objectGroup->objects()) {
tilesetdock.cpp:                if (condition(object->cell()))
tilesetdock.cpp:                    undoStack->push(new RemoveMapObject(mapDocument, object));
tilesetdock.cpp:    mTabBar->setMovable(true);
tilesetdock.cpp:    mTabBar->setUsesScrollButtons(true);
tilesetdock.cpp:    horizontal->setSpacing(0);
tilesetdock.cpp:    horizontal->addWidget(mTabBar);
tilesetdock.cpp:    horizontal->addWidget(mTilesetMenuButton);
tilesetdock.cpp:    vertical->setSpacing(0);
tilesetdock.cpp:    vertical->setMargin(5);
tilesetdock.cpp:    vertical->addLayout(horizontal);
tilesetdock.cpp:    vertical->addWidget(mViewStack);
tilesetdock.cpp:    horizontal->setSpacing(0);
tilesetdock.cpp:    horizontal->addWidget(mToolBar, 1);
tilesetdock.cpp:    vertical->addLayout(horizontal);
tilesetdock.cpp:    mNewTileset->setIcon(QIcon(QLatin1String(":images/16x16/document-new.png")));
tilesetdock.cpp:    mSelectAllTiles->setIcon(QIcon(QLatin1String(":images/16x16/document-new.png")));
tilesetdock.cpp:    mImportTileset->setIcon(QIcon(QLatin1String(":images/16x16/document-import.png")));
tilesetdock.cpp:    mExportTileset->setIcon(QIcon(QLatin1String(":images/16x16/document-export.png")));
tilesetdock.cpp:    mPropertiesTileset->setIcon(QIcon(QLatin1String(":images/16x16/document-properties.png")));
tilesetdock.cpp:    mDeleteTileset->setIcon(QIcon(QLatin1String(":images/16x16/edit-delete.png")));
tilesetdock.cpp:    mEditTerrain->setIcon(QIcon(QLatin1String(":images/16x16/terrain.png")));
tilesetdock.cpp:    mAddTiles->setIcon(QIcon(QLatin1String(":images/16x16/add.png")));
tilesetdock.cpp:    mRemoveTiles->setIcon(QIcon(QLatin1String(":images/16x16/remove.png")));
tilesetdock.cpp:    Utils::setThemeIcon(mNewTileset, "document-new");
tilesetdock.cpp:    Utils::setThemeIcon(mSelectAllTiles, "document-new");
tilesetdock.cpp:    Utils::setThemeIcon(mImportTileset, "document-import");
tilesetdock.cpp:    Utils::setThemeIcon(mExportTileset, "document-export");
tilesetdock.cpp:    Utils::setThemeIcon(mPropertiesTileset, "document-properties");
tilesetdock.cpp:    Utils::setThemeIcon(mDeleteTileset, "edit-delete");
tilesetdock.cpp:    mToolBar->addAction(mNewTileset);
tilesetdock.cpp:    mToolBar->addAction(mSelectAllTiles);
tilesetdock.cpp:    mToolBar->setIconSize(QSize(16, 16));
tilesetdock.cpp:    mToolBar->addAction(mImportTileset);
tilesetdock.cpp:    mToolBar->addAction(mExportTileset);
tilesetdock.cpp:    mToolBar->addAction(mPropertiesTileset);
tilesetdock.cpp:    mToolBar->addAction(mDeleteTileset);
tilesetdock.cpp:    mToolBar->addAction(mEditTerrain);
tilesetdock.cpp:    mToolBar->addAction(mAddTiles);
tilesetdock.cpp:    mToolBar->addAction(mRemoveTiles);
tilesetdock.cpp:    mZoomable->connectToComboBox(mZoomComboBox);
tilesetdock.cpp:    horizontal->addWidget(mZoomComboBox);
tilesetdock.cpp:    mTilesetMenuButton->setMenu(mTilesetMenu);
tilesetdock.cpp:    widget()->hide();
tilesetdock.cpp:        const QString tilesetName = mTabBar->tabText(mTabBar->currentIndex());
tilesetdock.cpp:    while (mTabBar->count())
tilesetdock.cpp:        mTabBar->removeTab(0);
tilesetdock.cpp:    while (mViewStack->count())
tilesetdock.cpp:        delete mViewStack->widget(0);
tilesetdock.cpp:        mMapDocument->disconnect(this);
tilesetdock.cpp:        mTilesets = mMapDocument->map()->tilesets();
tilesetdock.cpp:            view->setMapDocument(mMapDocument);
tilesetdock.cpp:            view->setZoomable(mZoomable);
tilesetdock.cpp:            mTabBar->addTab(tileset->name());
tilesetdock.cpp:            mViewStack->addWidget(view);
tilesetdock.cpp:        for (int i = 0; i < mTabBar->count(); ++i) {
tilesetdock.cpp:            if (mTabBar->tabText(i) == cacheName) {
tilesetdock.cpp:                mTabBar->setCurrentIndex(i);
tilesetdock.cpp:        if (Object *object = mMapDocument->currentObject())
tilesetdock.cpp:            if (object->typeId() == Object::TileType)
tilesetdock.cpp:    widget()->show();
tilesetdock.cpp:                Tileset *tileset = tile->tileset();
tilesetdock.cpp:                int tilesetIndex = mTilesets.indexOf(tileset->sharedPointer());
tilesetdock.cpp:                if (tilesetIndex != -1) {
tilesetdock.cpp:                    if (!view->model()) // Lazily set up the model
tilesetdock.cpp:                    const TilesetModel *model = view->tilesetModel();
tilesetdock.cpp:                    const QModelIndex modelIndex = model->tileIndex(tile);
tilesetdock.cpp:                    QItemSelectionModel *selectionModel = view->selectionModel();
tilesetdock.cpp:            selectionModel->select(selection, QItemSelectionModel::SelectCurrent);
tilesetdock.cpp:        if (selectionModel->currentIndex() != currentIndex)
tilesetdock.cpp:            selectionModel->setCurrentIndex(currentIndex, QItemSelectionModel::NoUpdate);
tilesetdock.cpp:    switch (e->type()) {
tilesetdock.cpp:    const QList<QUrl> urls = e->mimeData()->urls();
tilesetdock.cpp:        e->accept();
tilesetdock.cpp:    foreach (const QUrl &url, e->mimeData()->urls()) {
tilesetdock.cpp:        e->accept();
tilesetdock.cpp:        if (const QItemSelectionModel *s = view->selectionModel())
tilesetdock.cpp:            setCurrentTile(view->tilesetModel()->tileAt(s->currentIndex()));
tilesetdock.cpp:    setCurrentTile(model->tileAt(index));
tilesetdock.cpp:    const int index = mTabBar->currentIndex();
tilesetdock.cpp:    if (index > -1) {
tilesetdock.cpp:            if (!view->model()) // Lazily set up the model
tilesetdock.cpp:            mViewStack->setCurrentIndex(index);
tilesetdock.cpp:            external = tileset->isExternal();
tilesetdock.cpp:            hasImageSource = !tileset->imageSource().isEmpty();
tilesetdock.cpp:            hasSelection = view->selectionModel()->hasSelection();
tilesetdock.cpp:    mNewTileset->setEnabled(mapIsDisplayed);
tilesetdock.cpp:    mImportTileset->setEnabled(tilesetIsDisplayed && external);
tilesetdock.cpp:    mExportTileset->setEnabled(tilesetIsDisplayed && !external);
tilesetdock.cpp:    mPropertiesTileset->setEnabled(tilesetIsDisplayed && !external);
tilesetdock.cpp:    mDeleteTileset->setEnabled(tilesetIsDisplayed);
tilesetdock.cpp:    mEditTerrain->setEnabled(tilesetIsDisplayed && !external);
tilesetdock.cpp:    mAddTiles->setEnabled(tilesetIsDisplayed && !hasImageSource && !external);
tilesetdock.cpp:    mRemoveTiles->setEnabled(tilesetIsDisplayed && !hasImageSource
tilesetdock.cpp:    const QItemSelectionModel *s = view->selectionModel();
tilesetdock.cpp:    const QModelIndexList indexes = s->selection().indexes();
tilesetdock.cpp:                                         maxX - minX + 1,
tilesetdock.cpp:                                         maxY - minY + 1);
tilesetdock.cpp:    const TilesetModel *model = view->tilesetModel();
tilesetdock.cpp:        tileLayer->setCell(index.column() - minX,
tilesetdock.cpp:                           index.row() - minY,
tilesetdock.cpp:                           Cell(model->tileAt(index)));
tilesetdock.cpp:    if (Tile *tile = view->tilesetModel()->tileAt(index))
tilesetdock.cpp:        mMapDocument->setCurrentObject(tile);
tilesetdock.cpp:    view->setMapDocument(mMapDocument);
tilesetdock.cpp:    view->setZoomable(mZoomable);
tilesetdock.cpp:    mTilesets.insert(index, tileset->sharedPointer());
tilesetdock.cpp:    mTabBar->insertTab(index, tileset->name());
tilesetdock.cpp:    mViewStack->insertWidget(index, view);
tilesetdock.cpp:    if (TilesetModel *model = tilesetViewAt(index)->tilesetModel())
tilesetdock.cpp:        model->tilesetChanged();
tilesetdock.cpp:    Q_ASSERT(index != -1);
tilesetdock.cpp:    mTabBar->removeTab(index);
tilesetdock.cpp:        TileLayer *cleaned = static_cast<TileLayer *>(mCurrentTiles->clone());
tilesetdock.cpp:        cleaned->removeReferencesToTileset(tileset);
tilesetdock.cpp:    if (mCurrentTile && mCurrentTile->tileset() == tileset)
tilesetdock.cpp:    QWidget *widget = mViewStack->widget(from);
tilesetdock.cpp:    mViewStack->removeWidget(widget);
tilesetdock.cpp:    mViewStack->insertWidget(to, widget);
tilesetdock.cpp:    mViewStack->setCurrentIndex(mTabBar->currentIndex());
tilesetdock.cpp:        if (mTabBar->tabText(i) != tileset->name())
tilesetdock.cpp:            mTabBar->setTabText(i, tileset->name());
tilesetdock.cpp:    const int currentIndex = mViewStack->currentIndex();
tilesetdock.cpp:    if (currentIndex != -1)
tilesetdock.cpp:        removeTileset(mViewStack->currentIndex());
tilesetdock.cpp:    const bool inUse = mMapDocument->map()->isTilesetUsed(tileset);
tilesetdock.cpp:                               "map!").arg(tileset->name()),
tilesetdock.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
tilesetdock.cpp:                return tile->tileset() == tileset;
tilesetdock.cpp:        undoStack->beginMacro(remove->text());
tilesetdock.cpp:    undoStack->push(remove);
tilesetdock.cpp:        undoStack->endMacro();
tilesetdock.cpp:    mMapDocument->undoStack()->push(command);
tilesetdock.cpp:        for (int y = 0; y < tiles->height(); ++y) {
tilesetdock.cpp:            for (int x = 0; x < tiles->width(); ++x) {
tilesetdock.cpp:                const Cell &cell = tiles->cellAt(x, y);
tilesetdock.cpp:        mMapDocument->setSelectedTiles(selectedTiles);
tilesetdock.cpp:        Map *map = mMapDocument->map();
tilesetdock.cpp:        Map *stamp = new Map(map->orientation(),
tilesetdock.cpp:                             tiles->width(),
tilesetdock.cpp:                             tiles->height(),
tilesetdock.cpp:                             map->tileWidth(),
tilesetdock.cpp:                             map->tileHeight());
tilesetdock.cpp:        stamp->addLayer(tiles->clone());
tilesetdock.cpp:        stamp->addTilesets(tiles->usedTilesets());
tilesetdock.cpp:        mMapDocument->setCurrentObject(tile);
tilesetdock.cpp:    mNewTileset->setText(tr("New Tileset"));
tilesetdock.cpp:    mImportTileset->setText(tr("&Import Tileset"));
tilesetdock.cpp:    mExportTileset->setText(tr("&Export Tileset As..."));
tilesetdock.cpp:    mPropertiesTileset->setText(tr("Tile&set Properties"));
tilesetdock.cpp:    mDeleteTileset->setText(tr("&Remove Tileset"));
tilesetdock.cpp:    mEditTerrain->setText(tr("Edit &Terrain Information"));
tilesetdock.cpp:    mAddTiles->setText(tr("Add Tiles"));
tilesetdock.cpp:    mRemoveTiles->setText(tr("Remove Tiles"));
tilesetdock.cpp:    const int index = mTabBar->currentIndex();
tilesetdock.cpp:    if (index == -1)
tilesetdock.cpp:    return static_cast<TilesetView *>(mViewStack->currentWidget());
tilesetdock.cpp:    return static_cast<TilesetView *>(mViewStack->widget(index));
tilesetdock.cpp:    view->setModel(new TilesetModel(tileset, view));
tilesetdock.cpp:    QItemSelectionModel *s = view->selectionModel();
tilesetdock.cpp:    mMapDocument->setCurrentObject(tileset);
tilesetdock.cpp:    mMapDocument->emitEditCurrentObject();
tilesetdock.cpp:    QString suggestedFileName = prefs->lastPath(Preferences::ExternalTileset);
tilesetdock.cpp:    suggestedFileName += tileset->name();
tilesetdock.cpp:    prefs->setLastPath(Preferences::ExternalTileset,
tilesetdock.cpp:    if (format->write(*tileset, fileName)) {
tilesetdock.cpp:        mMapDocument->undoStack()->push(command);
tilesetdock.cpp:        QString error = format->errorString();
tilesetdock.cpp:    mMapDocument->undoStack()->push(command);
tilesetdock.cpp:    const QString startLocation = QFileInfo(prefs->lastPath(Preferences::ImageFile)).absolutePath();
tilesetdock.cpp:    int id = tileset->tileCount();
tilesetdock.cpp:    prefs->setLastPath(Preferences::ImageFile, files.last());
tilesetdock.cpp:    mMapDocument->undoStack()->push(new AddTiles(mMapDocument,
tilesetdock.cpp:    if (!view->selectionModel()->hasSelection())
tilesetdock.cpp:    const QModelIndexList indexes = view->selectionModel()->selectedIndexes();
tilesetdock.cpp:    const TilesetModel *model = view->tilesetModel();
tilesetdock.cpp:        if (Tile *tile = model->tileAt(index)) {
tilesetdock.cpp:            tileIds.insert(tile->id());
tilesetdock.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
tilesetdock.cpp:    undoStack->beginMacro(tr("Remove Tiles"));
tilesetdock.cpp:    Tileset *tileset = view->tilesetModel()->tileset();
tilesetdock.cpp:        --it;
tilesetdock.cpp:        undoStack->push(new RemoveTiles(mMapDocument, tileset,
tilesetdock.cpp:    undoStack->endMacro();
tilesetdock.cpp:    Q_ASSERT(index != -1);
tilesetdock.cpp:    mTabBar->setTabText(index, tileset->name());
tilesetdock.cpp:        if (TilesetModel *model = view->tilesetModel())
tilesetdock.cpp:            model->tileChanged(tile);
tilesetdock.cpp:    mTilesetMenu->clear();
tilesetdock.cpp:        mTabBar->disconnect(mTilesetMenuMapper);
tilesetdock.cpp:    const int currentIndex = mTabBar->currentIndex();
tilesetdock.cpp:    for (int i = 0; i < mTabBar->count(); ++i) {
tilesetdock.cpp:        QAction *action = new QAction(mTabBar->tabText(i), this);
tilesetdock.cpp:        action->setCheckable(true);
tilesetdock.cpp:        mTilesetActionGroup->addAction(action);
tilesetdock.cpp:            action->setChecked(true);
tilesetdock.cpp:        mTilesetMenu->addAction(action);
tilesetdock.cpp:        mTilesetMenuMapper->setMapping(action, i);
Binary file abstractobjecttool.o matches
Binary file propertybrowser.o matches
Binary file qtpropertybrowser.o matches
changemapobjectsorder.cpp:        from -= mCount;
changemapobjectsorder.cpp:    mMapDocument->mapObjectModel()->moveObjects(mObjectGroup,
changemapobjectsorder.cpp:    mMapDocument->mapObjectModel()->moveObjects(mObjectGroup,
aboutdialog.h: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
moc_newmapdialog.cpp:        - idx * sizeof(QByteArrayData) \
moc_newmapdialog.cpp:        case 0: _t->refreshPixelSize(); break;
moc_newmapdialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_newmapdialog.cpp:        _id -= 1;
moc_newmapdialog.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_newmapdialog.cpp:        _id -= 1;
Binary file objecttypesmodel.o matches
Binary file moc_resizedialog.o matches
Binary file imagemovementtool.o matches
Binary file qteditorfactory.o matches
moc_createpolylineobjecttool.cpp:        - idx * sizeof(QByteArrayData) \
moc_createpolylineobjecttool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
fileedit.cpp:    layout->setMargin(0);
fileedit.cpp:    layout->setSpacing(0);
fileedit.cpp:    mLineEdit->setSizePolicy(QSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred));
fileedit.cpp:    mOkTextColor = mLineEdit->palette().color(QPalette::Active, QPalette::Text);
fileedit.cpp:    button->setSizePolicy(QSizePolicy(QSizePolicy::Fixed, QSizePolicy::Preferred));
fileedit.cpp:    button->setFixedWidth(20);
fileedit.cpp:    button->setText(QLatin1String("..."));
fileedit.cpp:    layout->addWidget(mLineEdit);
fileedit.cpp:    layout->addWidget(button);
fileedit.cpp:     if (mLineEdit->text() != filePath)
fileedit.cpp:         mLineEdit->setText(filePath);
fileedit.cpp:    return mLineEdit->text();
fileedit.cpp:    mLineEdit->event(e);
fileedit.cpp:    if (e->reason() == Qt::TabFocusReason || e->reason() == Qt::BacktabFocusReason) {
fileedit.cpp:        mLineEdit->selectAll();
fileedit.cpp:    mLineEdit->event(e);
fileedit.cpp:    mLineEdit->event(e);
fileedit.cpp:    mLineEdit->event(e);
fileedit.cpp:    QPalette palette = mLineEdit->palette();
fileedit.cpp:    mLineEdit->setPalette(palette);
fileedit.cpp:                                                    mLineEdit->text(),
fileedit.cpp:    mLineEdit->setText(filePath);
createpolygonobjecttool.cpp:    setIcon(QIcon(QLatin1String(":images/24x24/insert-polygon.png")));
createpolygonobjecttool.cpp:    newMapObject->setShape(MapObject::Polygon);
createpolygonobjecttool.cpp:    if (mNewMapObjectItem->mapObject()->polygon().size() >= 3)
changemapobject.cpp:    const QString name = mMapObject->name();
changemapobject.cpp:    const QString type = mMapObject->type();
changemapobject.cpp:    mMapDocument->mapObjectModel()->setObjectName(mMapObject, mName);
changemapobject.cpp:    mMapDocument->mapObjectModel()->setObjectType(mMapObject, mType);
changemapobject.cpp:    : mMapObjectModel(mapDocument->mapObjectModel())
changemapobject.cpp:    , mOldVisible(mapObject->isVisible())
changemapobject.cpp:    mMapObjectModel->setObjectVisible(mMapObject, mOldVisible);
changemapobject.cpp:    mMapObjectModel->setObjectVisible(mMapObject, mNewVisible);
Binary file moc_objectselectiontool.o matches
moc_tilestampmanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_tilestampmanager.cpp:        case 0: _t->setStamp((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_tilestampmanager.cpp:        case 1: { TileStamp _r = _t->createStamp();
moc_tilestampmanager.cpp:        case 2: _t->addVariation((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_tilestampmanager.cpp:        case 3: _t->selectQuickStamp((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_tilestampmanager.cpp:        case 4: _t->createQuickStamp((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_tilestampmanager.cpp:        case 5: _t->extendQuickStamp((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_tilestampmanager.cpp:        case 6: _t->stampsDirectoryChanged(); break;
moc_tilestampmanager.cpp:        case 7: _t->stampAdded((*reinterpret_cast< TileStamp(*)>(_a[1]))); break;
moc_tilestampmanager.cpp:        case 8: _t->stampRenamed((*reinterpret_cast< TileStamp(*)>(_a[1]))); break;
moc_tilestampmanager.cpp:        case 9: _t->saveStamp((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_tilestampmanager.cpp:        case 10: _t->deleteStamp((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_tilestampmanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tilestampmanager.cpp:        _id -= 11;
moc_tilestampmanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tilestampmanager.cpp:        _id -= 11;
ui_resizedialog.h:        if (ResizeDialog->objectName().isEmpty())
ui_resizedialog.h:            ResizeDialog->setObjectName(QStringLiteral("ResizeDialog"));
ui_resizedialog.h:        ResizeDialog->resize(242, 402);
ui_resizedialog.h:        verticalLayout->setObjectName(QStringLiteral("verticalLayout"));
ui_resizedialog.h:        groupBox->setObjectName(QStringLiteral("groupBox"));
ui_resizedialog.h:        _6->setObjectName(QStringLiteral("_6"));
ui_resizedialog.h:        label_3->setObjectName(QStringLiteral("label_3"));
ui_resizedialog.h:        _6->addWidget(label_3, 0, 0, 1, 1);
ui_resizedialog.h:        widthSpinBox->setObjectName(QStringLiteral("widthSpinBox"));
ui_resizedialog.h:        widthSpinBox->setMinimum(1);
ui_resizedialog.h:        widthSpinBox->setMaximum(99999);
ui_resizedialog.h:        _6->addWidget(widthSpinBox, 0, 1, 1, 1);
ui_resizedialog.h:        label_4->setObjectName(QStringLiteral("label_4"));
ui_resizedialog.h:        _6->addWidget(label_4, 1, 0, 1, 1);
ui_resizedialog.h:        heightSpinBox->setObjectName(QStringLiteral("heightSpinBox"));
ui_resizedialog.h:        heightSpinBox->setMinimum(1);
ui_resizedialog.h:        heightSpinBox->setMaximum(99999);
ui_resizedialog.h:        _6->addWidget(heightSpinBox, 1, 1, 1, 1);
ui_resizedialog.h:        verticalLayout->addWidget(groupBox);
ui_resizedialog.h:        groupBox_2->setObjectName(QStringLiteral("groupBox_2"));
ui_resizedialog.h:        _4->setObjectName(QStringLiteral("_4"));
ui_resizedialog.h:        label_2->setObjectName(QStringLiteral("label_2"));
ui_resizedialog.h:        _4->addWidget(label_2, 0, 0, 1, 1);
ui_resizedialog.h:        offsetXSpinBox->setObjectName(QStringLiteral("offsetXSpinBox"));
ui_resizedialog.h:        offsetXSpinBox->setMinimum(-99999);
ui_resizedialog.h:        offsetXSpinBox->setMaximum(99999);
ui_resizedialog.h:        _4->addWidget(offsetXSpinBox, 0, 1, 1, 1);
ui_resizedialog.h:        label->setObjectName(QStringLiteral("label"));
ui_resizedialog.h:        _4->addWidget(label, 1, 0, 1, 1);
ui_resizedialog.h:        offsetYSpinBox->setObjectName(QStringLiteral("offsetYSpinBox"));
ui_resizedialog.h:        offsetYSpinBox->setMinimum(-99999);
ui_resizedialog.h:        offsetYSpinBox->setMaximum(99999);
ui_resizedialog.h:        _4->addWidget(offsetYSpinBox, 1, 1, 1, 1);
ui_resizedialog.h:        verticalLayout->addWidget(groupBox_2);
ui_resizedialog.h:        frame->setObjectName(QStringLiteral("frame"));
ui_resizedialog.h:        sizePolicy.setHeightForWidth(frame->sizePolicy().hasHeightForWidth());
ui_resizedialog.h:        frame->setSizePolicy(sizePolicy);
ui_resizedialog.h:        frame->setFrameShape(QFrame::StyledPanel);
ui_resizedialog.h:        frame->setFrameShadow(QFrame::Raised);
ui_resizedialog.h:        _5->setObjectName(QStringLiteral("_5"));
ui_resizedialog.h:        resizeHelper->setObjectName(QStringLiteral("resizeHelper"));
ui_resizedialog.h:        _5->addWidget(resizeHelper);
ui_resizedialog.h:        verticalLayout->addWidget(frame);
ui_resizedialog.h:        buttonBox->setObjectName(QStringLiteral("buttonBox"));
ui_resizedialog.h:        buttonBox->setOrientation(Qt::Horizontal);
ui_resizedialog.h:        buttonBox->setStandardButtons(QDialogButtonBox::Cancel|QDialogButtonBox::Ok);
ui_resizedialog.h:        verticalLayout->addWidget(buttonBox);
ui_resizedialog.h:        label_3->setBuddy(widthSpinBox);
ui_resizedialog.h:        label_4->setBuddy(heightSpinBox);
ui_resizedialog.h:        label_2->setBuddy(offsetXSpinBox);
ui_resizedialog.h:        label->setBuddy(offsetYSpinBox);
ui_resizedialog.h:        ResizeDialog->setWindowTitle(QApplication::translate("ResizeDialog", "Resize", 0));
ui_resizedialog.h:        groupBox->setTitle(QApplication::translate("ResizeDialog", "Size", 0));
ui_resizedialog.h:        label_3->setText(QApplication::translate("ResizeDialog", "Width:", 0));
ui_resizedialog.h:        label_4->setText(QApplication::translate("ResizeDialog", "Height:", 0));
ui_resizedialog.h:        groupBox_2->setTitle(QApplication::translate("ResizeDialog", "Offset", 0));
ui_resizedialog.h:        label_2->setText(QApplication::translate("ResizeDialog", "X:", 0));
ui_resizedialog.h:        label->setText(QApplication::translate("ResizeDialog", "Y:", 0));
Binary file addremovetiles.o matches
Binary file mapdocumentactionhandler.o matches
Binary file moc_mapdocument.o matches
Binary file painttilelayer.o matches
flipmapobjects.cpp:        object->flip(mFlipDirection);
flipmapobjects.cpp:    mMapDocument->mapObjectModel()->emitObjectsChanged(mMapObjects);
changepolygon.cpp:    , mNewPolygon(mapObject->polygon())
changepolygon.cpp:    mMapDocument->mapObjectModel()->setObjectPolygon(mMapObject, mOldPolygon);
changepolygon.cpp:    mMapDocument->mapObjectModel()->setObjectPolygon(mMapObject, mNewPolygon);
preferencesdialog.h: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
moc_qtpropertybrowser.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertybrowser.cpp:        case 0: _t->propertyInserted((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< QtProperty*(*)>(_a[2])),(*reinterpret_cast< QtProperty*(*)>(_a[3]))); break;
moc_qtpropertybrowser.cpp:        case 1: _t->propertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertybrowser.cpp:        case 2: _t->propertyRemoved((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< QtProperty*(*)>(_a[2]))); break;
moc_qtpropertybrowser.cpp:        case 3: _t->propertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertybrowser.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertybrowser.cpp:        _id -= 4;
moc_qtpropertybrowser.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertybrowser.cpp:        _id -= 4;
moc_qtpropertybrowser.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertybrowser.cpp:        case 0: _t->managerDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_qtpropertybrowser.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertybrowser.cpp:        _id -= 1;
moc_qtpropertybrowser.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertybrowser.cpp:        _id -= 1;
moc_qtpropertybrowser.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertybrowser.cpp:        case 0: _t->currentItemChanged((*reinterpret_cast< QtBrowserItem*(*)>(_a[1]))); break;
moc_qtpropertybrowser.cpp:        case 1: { QtBrowserItem* _r = _t->addProperty((*reinterpret_cast< QtProperty*(*)>(_a[1])));
moc_qtpropertybrowser.cpp:        case 2: { QtBrowserItem* _r = _t->insertProperty((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< QtProperty*(*)>(_a[2])));
moc_qtpropertybrowser.cpp:        case 3: _t->removeProperty((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertybrowser.cpp:        case 4: _t->d_func()->slotPropertyInserted((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< QtProperty*(*)>(_a[2])),(*reinterpret_cast< QtProperty*(*)>(_a[3]))); break;
moc_qtpropertybrowser.cpp:        case 5: _t->d_func()->slotPropertyRemoved((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< QtProperty*(*)>(_a[2]))); break;
moc_qtpropertybrowser.cpp:        case 6: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertybrowser.cpp:        case 7: _t->d_func()->slotPropertyDataChanged((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertybrowser.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertybrowser.cpp:        _id -= 8;
moc_qtpropertybrowser.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertybrowser.cpp:        _id -= 8;
moc_patreondialog.cpp:        - idx * sizeof(QByteArrayData) \
moc_patreondialog.cpp:        case 0: _t->openPatreonPage(); break;
moc_patreondialog.cpp:        case 1: _t->togglePatreonStatus(); break;
moc_patreondialog.cpp:        case 2: _t->updatePatreonStatus(); break;
moc_patreondialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_patreondialog.cpp:        _id -= 3;
moc_patreondialog.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_patreondialog.cpp:        _id -= 3;
Binary file tileanimationdriver.o matches
commandlineparser.h: * C-style callback function taking an arbitrary data pointer.
commandlineparser.h: * A template function that will static-cast the given \a object to a type T
commandlineparser.h:    (t->*memberFunction)();
commandlineparser.h: * The help option (-h/--help) is provided by the parser based on the
Binary file createtileobjecttool.o matches
Binary file offsetlayer.o matches
Binary file moc_exportasimagedialog.o matches
layerdock.h: * Copyright 2008-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file objectselectionitem.o matches
snaphelper.cpp:    mSnapToGrid = preferences->snapToGrid();
snaphelper.cpp:    mSnapToFineGrid = preferences->snapToFineGrid();
snaphelper.cpp:        QPointF tileCoords = mRenderer->pixelToTileCoords(pixelPos);
snaphelper.cpp:            int gridFine = Preferences::instance()->gridFine();
snaphelper.cpp:        pixelPos = mRenderer->tileToPixelCoords(tileCoords);
newtilesetdialog.h: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file selectsametiletool.o matches
Binary file moc_commanddialog.o matches
automapperwrapper.cpp: * Copyright 2010-2011, Stefan Beller, stefanbeller@googlemail.com
automapperwrapper.cpp:    Map *map = mMapDocument->map();
automapperwrapper.cpp:        if (a->prepareAutoMap()) {
automapperwrapper.cpp:            touchedLayers|= a->getTouchedTileLayers();
automapperwrapper.cpp:        const int layerindex = map->indexOfLayer(layerName);
automapperwrapper.cpp:        Q_ASSERT(layerindex != -1);
automapperwrapper.cpp:        mLayersBefore << static_cast<TileLayer*>(map->layerAt(layerindex)->clone());
automapperwrapper.cpp:        a->autoMap(where);
automapperwrapper.cpp:        const int layerindex = map->indexOfLayer(layerName);
automapperwrapper.cpp:        Q_ASSERT(layerindex != -1);
automapperwrapper.cpp:        mLayersAfter << static_cast<TileLayer*>(map->layerAt(layerindex)->clone());
automapperwrapper.cpp:        QRect diffRegion = before->computeDiffRegion(after).boundingRect();
automapperwrapper.cpp:        TileLayer *before1 = before->copy(diffRegion);
automapperwrapper.cpp:        TileLayer *after1 = after->copy(diffRegion);
automapperwrapper.cpp:        before1->setPosition(diffRegion.topLeft());
automapperwrapper.cpp:        after1->setPosition(diffRegion.topLeft());
automapperwrapper.cpp:        before1->setName(before->name());
automapperwrapper.cpp:        after1->setName(after->name());
automapperwrapper.cpp:        a->cleanAll();
automapperwrapper.cpp:    Map *map = mMapDocument->map();
automapperwrapper.cpp:        const int layerindex = map->indexOfLayer(layer->name());
automapperwrapper.cpp:        if (layerindex != -1)
automapperwrapper.cpp:    Map *map = mMapDocument->map();
automapperwrapper.cpp:        const int layerindex = map->indexOfLayer(layer->name());
automapperwrapper.cpp:        if (layerindex != -1)
automapperwrapper.cpp:    Map *map = mMapDocument->map();
automapperwrapper.cpp:    QRect b = layer->bounds();
automapperwrapper.cpp:    Q_ASSERT(map->layerAt(layerIndex)->asTileLayer());
automapperwrapper.cpp:    TileLayer *t = static_cast<TileLayer*>(map->layerAt(layerIndex));
automapperwrapper.cpp:    t->setCells(b.left() - t->x(), b.top() - t->y(), layer,
automapperwrapper.cpp:                b.translated(-t->position()));
automapperwrapper.cpp:    mMapDocument->emitRegionChanged(b, t);
tilesetmodel.cpp: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tilesetmodel.cpp:    const int tiles = mTileset->tileCount();
tilesetmodel.cpp:    if (mTileset->columnCount())
tilesetmodel.cpp:        return mTileset->columnCount();
tilesetmodel.cpp:    // TODO: Non-table tilesets should use a different model.
tilesetmodel.cpp:            return tile->image();
tilesetmodel.cpp:            return tile->terrain();
tilesetmodel.cpp:    mimeData->setData(QLatin1String(TILES_MIMETYPE), encodedData);
tilesetmodel.cpp:    return mTileset->tileAt(i);
tilesetmodel.cpp:    Q_ASSERT(tile->tileset() == mTileset);
tilesetmodel.cpp:    const int id = tile->id();
tilesetmodel.cpp:    if (tiles.first()->tileset() != mTileset)
tilesetmodel.cpp:    if (tile->tileset() != mTileset)
Binary file moc_abstracttool.o matches
Binary file changeselectedarea.o matches
tileanimationeditor.moc:        - idx * sizeof(QByteArrayData) \
tileanimationeditor.moc:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
Binary file tilesetview.o matches
Binary file resizetilelayer.o matches
moc_bucketfilltool.cpp:        - idx * sizeof(QByteArrayData) \
moc_bucketfilltool.cpp:        case 0: _t->setRandom((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_bucketfilltool.cpp:        case 1: _t->clearOverlay(); break;
moc_bucketfilltool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_bucketfilltool.cpp:        _id -= 2;
moc_bucketfilltool.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_bucketfilltool.cpp:        _id -= 2;
moc_tilesetmodel.cpp:        - idx * sizeof(QByteArrayData) \
moc_tilesetmodel.cpp:        case 0: _t->tilesChanged((*reinterpret_cast< const QList<Tile*>(*)>(_a[1]))); break;
moc_tilesetmodel.cpp:        case 1: _t->tileChanged((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_tilesetmodel.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tilesetmodel.cpp:        _id -= 2;
moc_tilesetmodel.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tilesetmodel.cpp:        _id -= 2;
bucketfilltool.h: * Copyright 2009-2010, Jeff Bland <jksb@member.fsf.org>
bucketfilltool.h:     * This is done by taking all non-null tiles from the original stamp mStamp.
moc_automapper.cpp:        - idx * sizeof(QByteArrayData) \
moc_automapper.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
Binary file moc_propertiesdock.o matches
stampbrush.h: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
stampbrush.h: * right-click dragging, or selected from the tileset view.
resizehelper.h: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file objecttypes.o matches
Binary file moc_commanddatamodel.o matches
renameterrain.cpp: * Copyright 2012-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
renameterrain.cpp:    , mTerrainModel(mapDocument->terrainModel())
renameterrain.cpp:    , mOldName(tileset->terrain(terrainId)->name())
renameterrain.cpp:    mTerrainModel->setTerrainName(mTileset, mTerrainId, mOldName);
renameterrain.cpp:    mTerrainModel->setTerrainName(mTileset, mTerrainId, mNewName);
createpolylineobjecttool.cpp:    setIcon(QIcon(QLatin1String(":images/24x24/insert-polyline.png")));
createpolylineobjecttool.cpp:    newMapObject->setShape(MapObject::Polyline);
createpolylineobjecttool.cpp:    if (mNewMapObjectItem->mapObject()->polygon().size() >= 2)
Binary file mapdocument.o matches
commanddialog.ui:<?xml version="1.0" encoding="UTF-8"?>
toolmanager.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
toolmanager.cpp:    mActionGroup->setExclusive(true);
toolmanager.cpp:    foreach (QAction *action, mActionGroup->actions()) {
toolmanager.cpp:        AbstractTool *tool = action->data().value<AbstractTool*>();
toolmanager.cpp:        tool->setMapDocument(mapDocument);
toolmanager.cpp:    tool->setMapDocument(mMapDocument);
toolmanager.cpp:    QAction *toolAction = new QAction(tool->icon(), tool->name(), this);
toolmanager.cpp:    toolAction->setShortcut(tool->shortcut());
toolmanager.cpp:    toolAction->setData(QVariant::fromValue<AbstractTool*>(tool));
toolmanager.cpp:    toolAction->setCheckable(true);
toolmanager.cpp:    toolAction->setToolTip(
toolmanager.cpp:            QString(QLatin1String("%1 (%2)")).arg(tool->name(),
toolmanager.cpp:                                                  tool->shortcut().toString()));
toolmanager.cpp:    toolAction->setEnabled(tool->isEnabled());
toolmanager.cpp:    mActionGroup->addAction(toolAction);
toolmanager.cpp:    if (!mSelectedTool && tool->isEnabled()) {
toolmanager.cpp:        toolAction->setChecked(true);
toolmanager.cpp:    if (tool && !tool->isEnabled()) // Refuse to select disabled tools
toolmanager.cpp:    foreach (QAction *action, mActionGroup->actions()) {
toolmanager.cpp:        if (action->data().value<AbstractTool*>() == tool) {
toolmanager.cpp:            action->trigger();
toolmanager.cpp:    foreach (QAction *action, mActionGroup->actions())
toolmanager.cpp:        action->setChecked(false);
toolmanager.cpp:    setSelectedTool(action->data().value<AbstractTool*>());
toolmanager.cpp:    foreach (QAction *action, mActionGroup->actions()) {
toolmanager.cpp:        AbstractTool *tool = action->data().value<AbstractTool*>();
toolmanager.cpp:        tool->languageChanged();
toolmanager.cpp:        action->setText(tool->name());
toolmanager.cpp:        action->setShortcut(tool->shortcut());
toolmanager.cpp:        action->setToolTip(QString(QLatin1String("%1 (%2)")).arg(
toolmanager.cpp:                tool->name(), tool->shortcut().toString()));
toolmanager.cpp:    foreach (QAction *action, mActionGroup->actions()) {
toolmanager.cpp:        if (action->data().value<AbstractTool*>() == tool) {
toolmanager.cpp:            action->setEnabled(enabled);
toolmanager.cpp:    if (mSelectedTool && mSelectedTool->isEnabled())
toolmanager.cpp:    if (mPreviouslyDisabledTool && mPreviouslyDisabledTool->isEnabled())
toolmanager.cpp:    foreach (QAction *action, mActionGroup->actions())
toolmanager.cpp:        if (AbstractTool *tool = action->data().value<AbstractTool*>())
toolmanager.cpp:            if (tool->isEnabled())
toolmanager.cpp:        emit statusInfoChanged(mSelectedTool->statusInfo());
offsetmapdialog.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
offsetmapdialog.cpp:    mUi->setupUi(this);
offsetmapdialog.cpp:    if (mMapDocument->selectedArea().isEmpty())
offsetmapdialog.cpp:        mUi->boundsSelection->setCurrentIndex(1);
offsetmapdialog.cpp:    const Map *map = mMapDocument->map();
offsetmapdialog.cpp:        for (int i = 0; i < map->layerCount(); i++)
offsetmapdialog.cpp:            if (map->layerAt(i)->isVisible())
offsetmapdialog.cpp:        for (int i = 0; i < map->layerCount(); i++)
offsetmapdialog.cpp:        layerIndexes.append(mMapDocument->currentLayerIndex());
offsetmapdialog.cpp:        boundingRect = QRect(QPoint(0, 0), mMapDocument->map()->size());
offsetmapdialog.cpp:        const QRegion &selection = mMapDocument->selectedArea();
offsetmapdialog.cpp:    switch (mUi->layerSelection->currentIndex()) {
offsetmapdialog.cpp:    if (mUi->boundsSelection->currentIndex() == 0)
offsetmapdialog.cpp:    return QPoint(mUi->xOffset->value(), mUi->yOffset->value());
offsetmapdialog.cpp:    return mUi->wrapX->isChecked();
offsetmapdialog.cpp:    return mUi->wrapY->isChecked();
offsetmapdialog.cpp:    mUi->boundsSelection->setEnabled(false);
offsetmapdialog.cpp:    mUi->boundsSelection->setCurrentIndex(0);
painttilelayer.cpp:    mSource(static_cast<TileLayer*>(source->clone())),
painttilelayer.cpp:    mPaintedRegion(x, y, source->width(), source->height()),
painttilelayer.cpp:    mErased = mTarget->copy(mX - mTarget->x(),
painttilelayer.cpp:                            mY - mTarget->y(),
painttilelayer.cpp:                            mSource->width(), mSource->height());
painttilelayer.cpp:    if (!(mMapDocument == o->mMapDocument &&
painttilelayer.cpp:          mTarget == o->mTarget &&
painttilelayer.cpp:          o->mMergeable))
painttilelayer.cpp:    const QRegion newRegion = o->mPaintedRegion.subtracted(mPaintedRegion);
painttilelayer.cpp:    const QRegion combinedRegion = mPaintedRegion.united(o->mPaintedRegion);
painttilelayer.cpp:    const QRect bounds = QRect(mX, mY, mSource->width(), mSource->height());
painttilelayer.cpp:        const QPoint shift = bounds.topLeft() - combinedBounds.topLeft();
painttilelayer.cpp:        mErased->resize(combinedBounds.size(), shift);
painttilelayer.cpp:        mSource->resize(combinedBounds.size(), shift);
painttilelayer.cpp:    const QPoint pos = QPoint(o->mX, o->mY) - combinedBounds.topLeft();
painttilelayer.cpp:    mSource->merge(pos, o->mSource);
painttilelayer.cpp:                mErased->setCell(x - mX,
painttilelayer.cpp:                                 y - mY,
painttilelayer.cpp:                                 o->mErased->cellAt(x - o->mX, y - o->mY));
toolmanager.h: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
changetileprobability.cpp:    float probability = mTile->probability();
changetileprobability.cpp:    mTile->setProbability(mProbability);
changetileprobability.cpp:    mMapDocument->emitTileProbabilityChanged(mTile);
moc_aboutdialog.cpp:        - idx * sizeof(QByteArrayData) \
moc_aboutdialog.cpp:        case 0: _t->donate(); break;
moc_aboutdialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_aboutdialog.cpp:        _id -= 1;
moc_aboutdialog.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_aboutdialog.cpp:        _id -= 1;
Binary file changetileanimation.o matches
Binary file commandlineparser.o matches
Binary file imagelayeritem.o matches
tmxmapformat.cpp: * Copyright 2008-2015, Thorbj√∏rn Lindeijer <bjorn@lindeijer.nl>
tmxmapformat.cpp:        SharedTileset tileset = manager->findTileset(source);
tmxmapformat.cpp:    writer.setDtdEnabled(prefs->dtdEnabled());
tmxmapformat.cpp:    writer.setDtdEnabled(prefs->dtdEnabled());
Binary file moc_propertybrowser.o matches
zoomable.h: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tmxmapformat.h: * Copyright 2008-2015, Thorbj√∏rn Lindeijer <bjorn@lindeijer.nl>
Binary file propertiesdock.o matches
objectsdock.cpp:    mActionObjectProperties->setIcon(QIcon(QLatin1String(":/images/16x16/document-properties.png")));
objectsdock.cpp:    Utils::setThemeIcon(mActionObjectProperties, "document-properties");
objectsdock.cpp:    layout->setMargin(5);
objectsdock.cpp:    layout->setSpacing(0);
objectsdock.cpp:    layout->addWidget(mObjectsView);
objectsdock.cpp:    mActionNewLayer->setIcon(QIcon(QLatin1String(":/images/16x16/document-new.png")));
objectsdock.cpp:            handler->actionAddObjectGroup(), SIGNAL(triggered()));
objectsdock.cpp:    mActionMoveToGroup->setIcon(QIcon(QLatin1String(":/images/16x16/layer-object.png")));
objectsdock.cpp:    toolBar->setFloatable(false);
objectsdock.cpp:    toolBar->setMovable(false);
objectsdock.cpp:    toolBar->setIconSize(QSize(16, 16));
objectsdock.cpp:    toolBar->addAction(mActionNewLayer);
objectsdock.cpp:    toolBar->addAction(handler->actionDuplicateObjects());
objectsdock.cpp:    toolBar->addAction(handler->actionRemoveObjects());
objectsdock.cpp:    toolBar->addAction(mActionMoveToGroup);
objectsdock.cpp:    button = dynamic_cast<QToolButton*>(toolBar->widgetForAction(mActionMoveToGroup));
objectsdock.cpp:    button->setPopupMode(QToolButton::InstantPopup);
objectsdock.cpp:    button->setMenu(mMoveToMenu);
objectsdock.cpp:    toolBar->addAction(mActionObjectProperties);
objectsdock.cpp:    layout->addWidget(toolBar);
objectsdock.cpp:        mMapDocument->disconnect(this);
objectsdock.cpp:    mObjectsView->setMapDocument(mapDoc);
objectsdock.cpp:    switch (e->type()) {
objectsdock.cpp:    mActionNewLayer->setToolTip(tr("Add Object Layer"));
objectsdock.cpp:    mActionObjectProperties->setToolTip(tr("Object Properties"));
objectsdock.cpp:    int count = mMapDocument ? mMapDocument->selectedObjects().count() : 0;
objectsdock.cpp:    mActionObjectProperties->setEnabled(count == 1);
objectsdock.cpp:    if (mMapDocument && (mMapDocument->map()->objectGroupCount() < 2))
objectsdock.cpp:    mActionMoveToGroup->setEnabled(enabled);
objectsdock.cpp:    mActionMoveToGroup->setToolTip(tr("Move %n Object(s) to Layer", "", count));
objectsdock.cpp:    mMoveToMenu->clear();
objectsdock.cpp:    foreach (ObjectGroup *objectGroup, mMapDocument->map()->objectGroups()) {
objectsdock.cpp:        QAction *action = mMoveToMenu->addAction(objectGroup->name());
objectsdock.cpp:        action->setData(QVariant::fromValue(objectGroup));
objectsdock.cpp:    ObjectGroup *objectGroup = action->data().value<ObjectGroup*>();
objectsdock.cpp:    handler->moveObjectsToGroup(objectGroup);
objectsdock.cpp:    const QList<MapObject *> &selectedObjects = mMapDocument->selectedObjects();
objectsdock.cpp:    mMapDocument->setCurrentObject(mapObject);
objectsdock.cpp:    mMapDocument->emitEditCurrentObject();
objectsdock.cpp:    foreach (ObjectGroup *og, mapDoc->map()->objectGroups()) {
objectsdock.cpp:        if (mObjectsView->isExpanded(mObjectsView->model()->index(og)))
objectsdock.cpp:        mObjectsView->setExpanded(mObjectsView->model()->index(og), true);
objectsdock.cpp:    foreach (MapObject *o, mapDoc->selectedObjects()) {
objectsdock.cpp:        QModelIndex index = mObjectsView->model()->index(o);
objectsdock.cpp:        mObjectsView->selectionModel()->select(index,
objectsdock.cpp:        mMapDocument->disconnect(this);
objectsdock.cpp:        setModel(mMapDocument->mapObjectModel());
objectsdock.cpp:        const QSettings *settings = Preferences::instance()->settings();
objectsdock.cpp:                settings->value(QLatin1String(FIRST_SECTION_SIZE_KEY), 200).toInt();
objectsdock.cpp:        header()->resizeSection(0, firstSectionSize);
objectsdock.cpp:    if (MapObject *mapObject = model()->toMapObject(index))
objectsdock.cpp:        mMapDocument->setCurrentObject(mapObject);
objectsdock.cpp:    else if (ObjectGroup *objectGroup = model()->toObjectGroup(index))
objectsdock.cpp:        mMapDocument->setCurrentObject(objectGroup);
objectsdock.cpp:    if (MapObject *mapObject = model()->toMapObject(index)) {
objectsdock.cpp:        mMapDocument->setCurrentObject(mapObject);
objectsdock.cpp:        mMapDocument->emitEditCurrentObject();
objectsdock.cpp:    QSettings *settings = Preferences::instance()->settings();
objectsdock.cpp:    settings->setValue(QLatin1String(FIRST_SECTION_SIZE_KEY),
objectsdock.cpp:                       header()->sectionSize(0));
objectsdock.cpp:    QModelIndexList selectedRows = selectionModel()->selectedRows();
objectsdock.cpp:    int currentLayerIndex = -1;
objectsdock.cpp:        if (ObjectGroup *og = model()->toLayer(index)) {
objectsdock.cpp:            int index = mMapDocument->map()->layers().indexOf(og);
objectsdock.cpp:            if (currentLayerIndex == -1)
objectsdock.cpp:                currentLayerIndex = -2;
objectsdock.cpp:        if (MapObject *o = model()->toMapObject(index))
objectsdock.cpp:    if (currentLayerIndex >= 0 && currentLayerIndex != mMapDocument->currentLayerIndex())
objectsdock.cpp:        mMapDocument->setCurrentLayerIndex(currentLayerIndex);
objectsdock.cpp:    if (selectedObjects != mMapDocument->selectedObjects()) {
objectsdock.cpp:            const QPointF center = o->bounds().center();
objectsdock.cpp:            DocumentManager::instance()->centerViewOn(center);
objectsdock.cpp:        mMapDocument->setSelectedObjects(selectedObjects);
objectsdock.cpp:    const QList<MapObject *> &selectedObjects = mMapDocument->selectedObjects();
objectsdock.cpp:        QModelIndex index = model()->index(o);
objectsdock.cpp:        selectionModel()->select(index, QItemSelectionModel::Select |  QItemSelectionModel::Rows);
objectsdock.cpp:        scrollTo(model()->index(o));
changeobjectgroupproperties.cpp:    , mUndoColor(objectGroup->color())
changeobjectgroupproperties.cpp:    , mUndoDrawOrder(objectGroup->drawOrder())
changeobjectgroupproperties.cpp:    mObjectGroup->setColor(mRedoColor);
changeobjectgroupproperties.cpp:    mObjectGroup->setDrawOrder(mRedoDrawOrder);
changeobjectgroupproperties.cpp:    mMapDocument->emitObjectGroupChanged(mObjectGroup);
changeobjectgroupproperties.cpp:    mObjectGroup->setColor(mUndoColor);
changeobjectgroupproperties.cpp:    mObjectGroup->setDrawOrder(mUndoDrawOrder);
changeobjectgroupproperties.cpp:    mMapDocument->emitObjectGroupChanged(mObjectGroup);
Binary file moc_aboutdialog.o matches
thumbnailrenderer.cpp: * Copyright 2011-2015, Thorbj√∏rn Lindeijer <bjorn@lindeijer.nl>
thumbnailrenderer.cpp:    switch (map->orientation()) {
thumbnailrenderer.cpp:    return a->y() < b->y();
thumbnailrenderer.cpp:        if (mMap->backgroundColor().isValid())
thumbnailrenderer.cpp:            image.fill(mMap->backgroundColor());
thumbnailrenderer.cpp:    QSize mapSize = mRenderer->mapSize();
thumbnailrenderer.cpp:    QMargins margins = mRenderer->map()->drawMargins();
thumbnailrenderer.cpp:    painter.translate((size.width() - scaledSize.width()) / 2,
thumbnailrenderer.cpp:                      (size.height() - scaledSize.height()) / 2);
thumbnailrenderer.cpp:    painter.translate(margins.left() + (size.width() - scaledSize.width()) / 2,
thumbnailrenderer.cpp:                      margins.top() + (size.height() - scaledSize.height()) / 2);
thumbnailrenderer.cpp:    mRenderer->setPainterScale(scale);
thumbnailrenderer.cpp:    foreach (const Layer *layer, mMap->layers()) {
thumbnailrenderer.cpp:        if (mVisibleLayersOnly && !layer->isVisible())
thumbnailrenderer.cpp:        painter.setOpacity(layer->opacity());
thumbnailrenderer.cpp:            mRenderer->drawTileLayer(&painter, tileLayer);
thumbnailrenderer.cpp:            QList<MapObject*> objects = objGroup->objects();
thumbnailrenderer.cpp:            if (objGroup->drawOrder() == ObjectGroup::TopDownOrder)
thumbnailrenderer.cpp:                if (object->isVisible()) {
thumbnailrenderer.cpp:                    if (object->rotation() != qreal(0)) {
thumbnailrenderer.cpp:                        QPointF origin = mRenderer->pixelToScreenCoords(object->position());
thumbnailrenderer.cpp:                        painter.rotate(object->rotation());
thumbnailrenderer.cpp:                        painter.translate(-origin);
thumbnailrenderer.cpp:                    mRenderer->drawMapObject(&painter, object, color);
thumbnailrenderer.cpp:                    if (object->rotation() != qreal(0))
thumbnailrenderer.cpp:            mRenderer->drawImageLayer(&painter, imageLayer);
Binary file changemapobjectsorder.o matches
moc_consoledock.cpp:        - idx * sizeof(QByteArrayData) \
moc_consoledock.cpp:        case 0: _t->appendInfo((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_consoledock.cpp:        case 1: _t->appendError((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_consoledock.cpp:        case 2: _t->onObjectAdded((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_consoledock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_consoledock.cpp:        _id -= 3;
moc_consoledock.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_consoledock.cpp:        _id -= 3;
Binary file movemapobject.o matches
Binary file filltiles.o matches
Binary file moc_createpolygonobjecttool.o matches
moc_tilesetmanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_tilesetmanager.cpp:        case 0: _t->tilesetChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_tilesetmanager.cpp:        case 1: _t->repaintTileset((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_tilesetmanager.cpp:        case 2: _t->fileChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_tilesetmanager.cpp:        case 3: _t->fileChangedTimeout(); break;
moc_tilesetmanager.cpp:        case 4: _t->advanceTileAnimations((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_tilesetmanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tilesetmanager.cpp:        _id -= 5;
moc_tilesetmanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tilesetmanager.cpp:        _id -= 5;
moc_magicwandtool.cpp:        - idx * sizeof(QByteArrayData) \
moc_magicwandtool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
objectselectiontool.cpp: * Copyright 2010-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
objectselectiontool.cpp:    const qreal outerArcSize = arrowHeadPos + bodyWidth - arrowHeadLength;
objectselectiontool.cpp:    const qreal innerArcSize = arrowHeadPos - bodyWidth - arrowHeadLength;
objectselectiontool.cpp:    path.arcTo(QRectF(arrowHeadLength - outerArcSize,
objectselectiontool.cpp:                      arrowHeadLength - outerArcSize,
objectselectiontool.cpp:               0, -90);
objectselectiontool.cpp:    path.lineTo(arrowHeadLength, arrowHeadPos - arrowHeadWidth);
objectselectiontool.cpp:    path.lineTo(arrowHeadLength, arrowHeadPos - bodyWidth);
objectselectiontool.cpp:    path.arcTo(QRectF(arrowHeadLength - innerArcSize,
objectselectiontool.cpp:                      arrowHeadLength - innerArcSize,
objectselectiontool.cpp:               -90, 90);
objectselectiontool.cpp:    path.lineTo(arrowHeadPos - arrowHeadWidth, arrowHeadLength);
objectselectiontool.cpp:    path.lineTo(0 + bodyWidth, arrowLength - arrowHeadLength);
objectselectiontool.cpp:    path.lineTo(arrowHeadWidth, arrowLength - arrowHeadLength);
objectselectiontool.cpp:    path.lineTo(-arrowHeadWidth, arrowLength - arrowHeadLength);
objectselectiontool.cpp:    path.lineTo(0 - bodyWidth, arrowLength - arrowHeadLength);
objectselectiontool.cpp:    path.lineTo(0 - bodyWidth, arrowHeadLength);
objectselectiontool.cpp:    path.lineTo(-arrowHeadWidth, arrowHeadLength);
objectselectiontool.cpp:    QRectF boundingRect() const { return QRectF(-9, -9, 18, 18); }
objectselectiontool.cpp:        QLine(-8,0, 8,0),
objectselectiontool.cpp:        QLine(0,-8, 0,8),
objectselectiontool.cpp:    painter->setPen(QPen(mUnderMouse ? Qt::white : Qt::lightGray, 1, Qt::DashLine));
objectselectiontool.cpp:    painter->drawLines(lines, sizeof(lines) / sizeof(lines[0]));
objectselectiontool.cpp:    painter->translate(1, 1);
objectselectiontool.cpp:    painter->setPen(QPen(Qt::black, 1, Qt::DashLine));
objectselectiontool.cpp:    painter->drawLines(lines, sizeof(lines) / sizeof(lines[0]));
objectselectiontool.cpp:        case TopRightAnchor:    transform.rotate(-90);  break;
objectselectiontool.cpp:    QRectF boundingRect() const { return mArrow.boundingRect().adjusted(-1, -1, 1, 1); }
objectselectiontool.cpp:    painter->setRenderHint(QPainter::Antialiasing);
objectselectiontool.cpp:    painter->setPen(pen);
objectselectiontool.cpp:    painter->setBrush(brush);
objectselectiontool.cpp:    painter->drawPath(mArrow);
objectselectiontool.cpp:        case TopRightAnchor:    transform.rotate(-135); break;
objectselectiontool.cpp:        case BottomRightAnchor: transform.rotate(-45);  break;
objectselectiontool.cpp:        case RightAnchor:       transform.rotate(-90);  mResizingLimitVertical = true; break;
objectselectiontool.cpp:    QRectF boundingRect() const { return mArrow.boundingRect().adjusted(-1, -1, 1, 1); }
objectselectiontool.cpp:    painter->setRenderHint(QPainter::Antialiasing);
objectselectiontool.cpp:    painter->setPen(pen);
objectselectiontool.cpp:    painter->setBrush(brush);
objectselectiontool.cpp:    painter->drawPath(mArrow);
objectselectiontool.cpp:          QIcon(QLatin1String(":images/22x22/tool-select-objects.png")),
objectselectiontool.cpp:    scene->addItem(mOriginIndicator);
objectselectiontool.cpp:        scene->addItem(mRotateHandles[i]);
objectselectiontool.cpp:        scene->addItem(mResizeHandles[i]);
objectselectiontool.cpp:    scene->removeItem(mOriginIndicator);
objectselectiontool.cpp:        scene->removeItem(mRotateHandles[i]);
objectselectiontool.cpp:        scene->removeItem(mResizeHandles[i]);
objectselectiontool.cpp:        event->ignore();
objectselectiontool.cpp:    switch (event->key()) {
objectselectiontool.cpp:    case Qt::Key_Up:    moveBy = QPointF(0, -1); break;
objectselectiontool.cpp:    case Qt::Key_Left:  moveBy = QPointF(-1, 0); break;
objectselectiontool.cpp:    const QSet<MapObjectItem*> &items = mapScene()->selectedObjectItems();
objectselectiontool.cpp:    const Qt::KeyboardModifiers modifiers = event->modifiers();
objectselectiontool.cpp:        event->ignore();
objectselectiontool.cpp:    const bool snapToFineGrid = Preferences::instance()->snapToFineGrid();
objectselectiontool.cpp:        moveBy.rx() *= mapDocument()->map()->tileWidth();
objectselectiontool.cpp:        moveBy.ry() *= mapDocument()->map()->tileHeight();
objectselectiontool.cpp:            moveBy /= Preferences::instance()->gridFine();
objectselectiontool.cpp:    QUndoStack *undoStack = mapDocument()->undoStack();
objectselectiontool.cpp:    undoStack->beginMacro(tr("Move %n Object(s)", "", items.size()));
objectselectiontool.cpp:        MapObject *object = objectItem->mapObject();
objectselectiontool.cpp:        const QPointF oldPos = object->position();
objectselectiontool.cpp:        undoStack->push(new MoveMapObject(mapDocument(), object, newPos, oldPos));
objectselectiontool.cpp:    undoStack->endMacro();
objectselectiontool.cpp:        if (QGraphicsView *view = mapScene()->views().first()) {
objectselectiontool.cpp:            QGraphicsItem *hoveredItem = mapScene()->itemAt(pos,
objectselectiontool.cpp:                                                            view->transform());
objectselectiontool.cpp:        const int dragDistance = (mScreenStart - screenPos).manhattanLength();
objectselectiontool.cpp:            const bool hasSelection = !mapScene()->selectedObjectItems().isEmpty();
objectselectiontool.cpp:        mSelectionRectangle->setRectangle(QRectF(mStart, pos).normalized());
objectselectiontool.cpp:    if (QWidget *viewport = event->widget())
objectselectiontool.cpp:        return qobject_cast<QGraphicsView*>(viewport->parent());
objectselectiontool.cpp:    switch (event->button()) {
objectselectiontool.cpp:        mStart = event->scenePos();
objectselectiontool.cpp:        mScreenStart = event->screenPos();
objectselectiontool.cpp:            QGraphicsItem *clickedItem = mapScene()->itemAt(event->scenePos(),
objectselectiontool.cpp:                                                            view->transform());
objectselectiontool.cpp:    if (event->button() != Qt::LeftButton)
objectselectiontool.cpp:        const Qt::KeyboardModifiers modifiers = event->modifiers();
objectselectiontool.cpp:            QSet<MapObjectItem*> selection = mapScene()->selectedObjectItems();
objectselectiontool.cpp:            mapScene()->setSelectedObjectItems(selection);
objectselectiontool.cpp:            mapScene()->setSelectedObjectItems(QSet<MapObjectItem*>());
objectselectiontool.cpp:        updateSelection(event->scenePos(), event->modifiers());
objectselectiontool.cpp:        mapScene()->removeItem(mSelectionRectangle);
objectselectiontool.cpp:        finishMoving(event->scenePos());
objectselectiontool.cpp:        finishRotating(event->scenePos());
objectselectiontool.cpp:        finishResizing(event->scenePos());
objectselectiontool.cpp:    r.translate(-alignmentOffset(r, alignment));
objectselectiontool.cpp:    Q_ASSERT(object->cell().isEmpty()); // tile objects only have screen bounds
objectselectiontool.cpp:    switch (object->shape()) {
objectselectiontool.cpp:        QRectF bounds(object->bounds());
objectselectiontool.cpp:        align(bounds, object->alignment());
objectselectiontool.cpp:        const QPointF &pos = object->position();
objectselectiontool.cpp:        const QPolygonF polygon = object->polygon().translated(pos);
objectselectiontool.cpp:    return object->cell().isEmpty();
objectselectiontool.cpp:    if (!object->cell().isEmpty()) {
objectselectiontool.cpp:        const Tile *tile = object->cell().tile;
objectselectiontool.cpp:        const QSize imgSize = tile->image().size();
objectselectiontool.cpp:        const QPointF position = renderer->pixelToScreenCoords(object->position());
objectselectiontool.cpp:        const QPoint tileOffset = tile->tileset()->tileOffset();
objectselectiontool.cpp:        const QSizeF objectSize = object->size();
objectselectiontool.cpp:        align(bounds, object->alignment());
objectselectiontool.cpp:        switch (object->shape()) {
objectselectiontool.cpp:            QRectF bounds(object->bounds());
objectselectiontool.cpp:            align(bounds, object->alignment());
objectselectiontool.cpp:            QPolygonF screenPolygon = renderer->pixelToScreenCoords(bounds);
objectselectiontool.cpp:            const QPointF &pos = object->position();
objectselectiontool.cpp:            const QPolygonF polygon = object->polygon().translated(pos);
objectselectiontool.cpp:            QPolygonF screenPolygon = renderer->pixelToScreenCoords(polygon);
objectselectiontool.cpp:    transform.translate(-position.x(), -position.y());
objectselectiontool.cpp:    if (object->rotation() != 0) {
objectselectiontool.cpp:        const QPointF pos = renderer->pixelToScreenCoords(object->position());
objectselectiontool.cpp:        transform = rotateAt(pos, object->rotation());
objectselectiontool.cpp:    QPointF offset = object->objectGroup()->offset();
objectselectiontool.cpp:    const QList<MapObject*> &objects = mapDocument()->selectedObjects();
objectselectiontool.cpp:        MapRenderer *renderer = mapDocument()->renderer();
objectselectiontool.cpp:            handleRotation = object->rotation();
objectselectiontool.cpp:                topLeft = transform.map(renderer->pixelToScreenCoords(bounds.topLeft()));
objectselectiontool.cpp:                topRight = transform.map(renderer->pixelToScreenCoords(bounds.topRight()));
objectselectiontool.cpp:                bottomLeft = transform.map(renderer->pixelToScreenCoords(bounds.bottomLeft()));
objectselectiontool.cpp:                bottomRight = transform.map(renderer->pixelToScreenCoords(bounds.bottomRight()));
objectselectiontool.cpp:                center = transform.map(renderer->pixelToScreenCoords(bounds.center()));
objectselectiontool.cpp:                if (mapDocument()->map()->orientation() == Map::Isometric)
objectselectiontool.cpp:        mOriginIndicator->setPos(center);
objectselectiontool.cpp:        mRotateHandles[TopLeftAnchor]->setPos(topLeft);
objectselectiontool.cpp:        mRotateHandles[TopRightAnchor]->setPos(topRight);
objectselectiontool.cpp:        mRotateHandles[BottomLeftAnchor]->setPos(bottomLeft);
objectselectiontool.cpp:        mRotateHandles[BottomRightAnchor]->setPos(bottomRight);
objectselectiontool.cpp:        mResizeHandles[TopAnchor]->setPos(top);
objectselectiontool.cpp:        mResizeHandles[TopAnchor]->setResizingOrigin(bottom);
objectselectiontool.cpp:        mResizeHandles[LeftAnchor]->setPos(left);
objectselectiontool.cpp:        mResizeHandles[LeftAnchor]->setResizingOrigin(right);
objectselectiontool.cpp:        mResizeHandles[RightAnchor]->setPos(right);
objectselectiontool.cpp:        mResizeHandles[RightAnchor]->setResizingOrigin(left);
objectselectiontool.cpp:        mResizeHandles[BottomAnchor]->setPos(bottom);
objectselectiontool.cpp:        mResizeHandles[BottomAnchor]->setResizingOrigin(top);
objectselectiontool.cpp:        mResizeHandles[TopLeftAnchor]->setPos(topLeft);
objectselectiontool.cpp:        mResizeHandles[TopLeftAnchor]->setResizingOrigin(bottomRight);
objectselectiontool.cpp:        mResizeHandles[TopRightAnchor]->setPos(topRight);
objectselectiontool.cpp:        mResizeHandles[TopRightAnchor]->setResizingOrigin(bottomLeft);
objectselectiontool.cpp:        mResizeHandles[BottomLeftAnchor]->setPos(bottomLeft);
objectselectiontool.cpp:        mResizeHandles[BottomLeftAnchor]->setResizingOrigin(topRight);
objectselectiontool.cpp:        mResizeHandles[BottomRightAnchor]->setPos(bottomRight);
objectselectiontool.cpp:        mResizeHandles[BottomRightAnchor]->setResizingOrigin(topLeft);
objectselectiontool.cpp:            mRotateHandles[i]->setRotation(handleRotation);
objectselectiontool.cpp:            mResizeHandles[i]->setRotation(handleRotation);
objectselectiontool.cpp:    const bool hasSelection = !mapDocument()->selectedObjects().isEmpty();
objectselectiontool.cpp:        mRotateHandles[i]->setVisible(showHandles && mMode == Rotate);
objectselectiontool.cpp:        mResizeHandles[i]->setVisible(showHandles && mMode == Resize);
objectselectiontool.cpp:    mOriginIndicator->setVisible(showOrigin);
objectselectiontool.cpp:    for (int i = mMovingObjects.size() - 1; i >= 0; --i) {
objectselectiontool.cpp:        MapObject *mapObject = object.item->mapObject();
objectselectiontool.cpp:            mapObject->setPosition(object.oldPosition);
objectselectiontool.cpp:            mapObject->setSize(object.oldSize);
objectselectiontool.cpp:            mapObject->setPolygon(object.oldPolygon);
objectselectiontool.cpp:            mapObject->setRotation(object.oldRotation);
objectselectiontool.cpp:    mapDocument()->mapObjectModel()->emitObjectsChanged(changingObjects());
objectselectiontool.cpp:    foreach (QGraphicsItem *item, mapScene()->items(rect)) {
objectselectiontool.cpp:        selectedItems |= mapScene()->selectedObjectItems();
objectselectiontool.cpp:    mapScene()->setSelectedObjectItems(selectedItems);
objectselectiontool.cpp:    mapScene()->addItem(mSelectionRectangle);
objectselectiontool.cpp:        if (!mapScene()->selectedObjectItems().contains(mClickedObjectItem))
objectselectiontool.cpp:            mapScene()->setSelectedObjectItems(QSet<MapObjectItem*>() << mClickedObjectItem);
objectselectiontool.cpp:    const MapRenderer *renderer = mapDocument()->renderer();
objectselectiontool.cpp:    const QPointF diff = snapToGrid(pos - mStart, modifiers);
objectselectiontool.cpp:        const QPointF newPos = renderer->screenToPixelCoords(newPixelPos);
objectselectiontool.cpp:        MapObject *mapObject = object.item->mapObject();
objectselectiontool.cpp:        mapObject->setPosition(newPos);
objectselectiontool.cpp:    mapDocument()->mapObjectModel()->emitObjectsChanged(changingObjects());
objectselectiontool.cpp:    if (mStart == pos) // Move is a no-op
objectselectiontool.cpp:    QUndoStack *undoStack = mapDocument()->undoStack();
objectselectiontool.cpp:    undoStack->beginMacro(tr("Move %n Object(s)", "", mMovingObjects.size()));
objectselectiontool.cpp:        undoStack->push(new MoveMapObject(mapDocument(),
objectselectiontool.cpp:                                          object.item->mapObject(),
objectselectiontool.cpp:    undoStack->endMacro();
objectselectiontool.cpp:    mOrigin = mOriginIndicator->pos();
objectselectiontool.cpp:    MapRenderer *renderer = mapDocument()->renderer();
objectselectiontool.cpp:    const QPointF startDiff = mOrigin - mStart;
objectselectiontool.cpp:    const QPointF currentDiff = mOrigin - pos;
objectselectiontool.cpp:    qreal angleDiff = currentAngle - startAngle;
objectselectiontool.cpp:        MapObject *mapObject = object.item->mapObject();
objectselectiontool.cpp:        const QPointF offset = mapObject->objectGroup()->offset();
objectselectiontool.cpp:        const QPointF oldRelPos = object.oldItemPosition + offset - mOrigin;
objectselectiontool.cpp:        const QPointF newRelPos(oldRelPos.x() * cs - oldRelPos.y() * sn,
objectselectiontool.cpp:        const QPointF newPixelPos = mOrigin + newRelPos - offset;
objectselectiontool.cpp:        const QPointF newPos = renderer->screenToPixelCoords(newPixelPos);
objectselectiontool.cpp:        mapObject->setPosition(newPos);
objectselectiontool.cpp:        mapObject->setRotation(newRotation);
objectselectiontool.cpp:    mapDocument()->mapObjectModel()->emitObjectsChanged(changingObjects());
objectselectiontool.cpp:    QUndoStack *undoStack = mapDocument()->undoStack();
objectselectiontool.cpp:    undoStack->beginMacro(tr("Rotate %n Object(s)", "", mMovingObjects.size()));
objectselectiontool.cpp:        MapObject *mapObject = object.item->mapObject();
objectselectiontool.cpp:        undoStack->push(new MoveMapObject(mapDocument(), mapObject, object.oldPosition));
objectselectiontool.cpp:        undoStack->push(new RotateMapObject(mapDocument(), mapObject, object.oldRotation));
objectselectiontool.cpp:    undoStack->endMacro();
objectselectiontool.cpp:    mOrigin = mOriginIndicator->pos();
objectselectiontool.cpp:    mResizingLimitHorizontal = mClickedResizeHandle->resizingLimitHorizontal();
objectselectiontool.cpp:    mResizingLimitVertical = mClickedResizeHandle->resizingLimitVertical();
objectselectiontool.cpp:    mStart = mClickedResizeHandle->pos();
objectselectiontool.cpp:    MapRenderer *renderer = mapDocument()->renderer();
objectselectiontool.cpp:    QPointF resizingOrigin = mClickedResizeHandle->resizingOrigin();
objectselectiontool.cpp:    mOriginIndicator->setPos(resizingOrigin);
objectselectiontool.cpp:    QPointF pixelPos = renderer->screenToPixelCoords(pos);
objectselectiontool.cpp:    QPointF snappedScreenPos = renderer->pixelToScreenCoords(pixelPos);
objectselectiontool.cpp:    QPointF diff = snappedScreenPos - resizingOrigin;
objectselectiontool.cpp:    QPointF startDiff = mStart - resizingOrigin;
objectselectiontool.cpp:         * handling of 0-sized objects.
objectselectiontool.cpp:     * everything 0-sized and non-recoverable (it's still possibly to run into
objectselectiontool.cpp:        MapObject *mapObject = object.item->mapObject();
objectselectiontool.cpp:        const QPointF offset = mapObject->objectGroup()->offset();
objectselectiontool.cpp:        const QPointF oldRelPos = object.oldItemPosition + offset - resizingOrigin;
objectselectiontool.cpp:        const QPointF newScreenPos = resizingOrigin + scaledRelPos - offset;
objectselectiontool.cpp:        const QPointF newPos = renderer->screenToPixelCoords(newScreenPos);
objectselectiontool.cpp:        if (mapObject->polygon().isEmpty() == false) {
objectselectiontool.cpp:            qreal rotation = object.item->rotation() * M_PI / -180;
objectselectiontool.cpp:                                       oldPoint.y() * cs - oldPoint.x() * sn);
objectselectiontool.cpp:                const QPointF newPoint(scaledPoint.x() * cs - scaledPoint.y() * sn,
objectselectiontool.cpp:            mapObject->setPolygon(newPolygon);
objectselectiontool.cpp:        mapObject->setSize(newSize);
objectselectiontool.cpp:        mapObject->setPosition(newPos);
objectselectiontool.cpp:    mapDocument()->mapObjectModel()->emitObjectsChanged(changingObjects());
objectselectiontool.cpp:    const MapRenderer *renderer = mapDocument()->renderer();
objectselectiontool.cpp:    MapObject *mapObject = object.item->mapObject();
objectselectiontool.cpp:     * offset. We will un-apply it to these variables since the resize for
objectselectiontool.cpp:    QPointF offset = mapObject->objectGroup()->offset();
objectselectiontool.cpp:    QTransform unrotate = rotateAt(object.oldItemPosition, -object.oldRotation);
objectselectiontool.cpp:    QPointF origin = (resizingOrigin - offset) * unrotate;
objectselectiontool.cpp:    QPointF pos = (screenPos - offset) * unrotate;
objectselectiontool.cpp:    QPointF start = (mStart - offset) * unrotate;
objectselectiontool.cpp:        origin = renderer->screenToPixelCoords(origin);
objectselectiontool.cpp:        pos = renderer->screenToPixelCoords(pos);
objectselectiontool.cpp:        start = renderer->screenToPixelCoords(start);
objectselectiontool.cpp:    /* In case one of the anchors was used as-is, the desired size can be
objectselectiontool.cpp:     * and ellipse objects. This allows scaling up a 0-sized object without
objectselectiontool.cpp:    if (mClickedResizeHandle->resizingOrigin() == resizingOrigin &&
objectselectiontool.cpp:            (mapObject->shape() == MapObject::Rectangle ||
objectselectiontool.cpp:             mapObject->shape() == MapObject::Ellipse) && !preserveAspect) {
objectselectiontool.cpp:        align(newBounds, mapObject->alignment());
objectselectiontool.cpp:        switch (mClickedResizeHandle->anchorPosition()) {
objectselectiontool.cpp:        switch (mClickedResizeHandle->anchorPosition()) {
objectselectiontool.cpp:        unalign(newBounds, mapObject->alignment());
objectselectiontool.cpp:        const QPointF relPos = pos - origin;
objectselectiontool.cpp:        const QPointF startDiff = start - origin;
objectselectiontool.cpp:        QPointF oldRelPos = oldPos - origin;
objectselectiontool.cpp:            mapObject->setPolygon(newPolygon);
objectselectiontool.cpp:        newPos = renderer->pixelToScreenCoords(newPos);
objectselectiontool.cpp:    newPos = renderer->screenToPixelCoords(newPos * rotate);
objectselectiontool.cpp:    mapObject->setSize(newSize);
objectselectiontool.cpp:    mapObject->setPosition(newPos);
objectselectiontool.cpp:    mapDocument()->mapObjectModel()->emitObjectsChanged(changingObjects());
objectselectiontool.cpp:    QUndoStack *undoStack = mapDocument()->undoStack();
objectselectiontool.cpp:    undoStack->beginMacro(tr("Resize %n Object(s)", "", mMovingObjects.size()));
objectselectiontool.cpp:        MapObject *mapObject = object.item->mapObject();
objectselectiontool.cpp:        undoStack->push(new MoveMapObject(mapDocument(), mapObject, object.oldPosition));
objectselectiontool.cpp:        undoStack->push(new ResizeMapObject(mapDocument(), mapObject, object.oldSize));
objectselectiontool.cpp:            undoStack->push(new ChangePolygon(mapDocument(), mapObject, object.oldPolygon));
objectselectiontool.cpp:    undoStack->endMacro();
objectselectiontool.cpp:    foreach (MapObjectItem *item, mapScene()->selectedObjectItems()) {
objectselectiontool.cpp:        MapObject *mapObject = item->mapObject();
objectselectiontool.cpp:            item->pos(),
objectselectiontool.cpp:            mapObject->position(),
objectselectiontool.cpp:            mapObject->size(),
objectselectiontool.cpp:            mapObject->polygon(),
objectselectiontool.cpp:            mapObject->rotation()
objectselectiontool.cpp:        const bool hasSelection = !mapScene()->selectedObjectItems().isEmpty();
objectselectiontool.cpp:    MapRenderer *renderer = mapDocument()->renderer();
objectselectiontool.cpp:        const QPointF alignScreenPos = renderer->pixelToScreenCoords(mAlignPosition);
objectselectiontool.cpp:        QPointF newAlignPixelPos = renderer->screenToPixelCoords(newAlignScreenPos);
objectselectiontool.cpp:        return renderer->pixelToScreenCoords(newAlignPixelPos) - alignScreenPos;
objectselectiontool.cpp:        changingObjects.append(movingObject.item->mapObject());
editterraindialog.ui:<?xml version="1.0" encoding="UTF-8"?>
editterraindialog.ui:         <normaloff>:/images/24x24/edit-undo.png</normaloff>:/images/24x24/edit-undo.png</iconset>
editterraindialog.ui:         <normaloff>:/images/24x24/edit-redo.png</normaloff>:/images/24x24/edit-redo.png</iconset>
editterraindialog.ui:         <normaloff>:/images/22x22/stock-tool-eraser.png</normaloff>:/images/22x22/stock-tool-eraser.png</iconset>
Binary file flipmapobjects.o matches
terrainview.h: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file changemapobject.o matches
Binary file tilesetmodel.o matches
Binary file changeobjectgroupproperties.o matches
moc_createobjecttool.cpp:        - idx * sizeof(QByteArrayData) \
moc_createobjecttool.cpp:        case 0: _t->setTile((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_createobjecttool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_createobjecttool.cpp:        _id -= 1;
moc_createobjecttool.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_createobjecttool.cpp:        _id -= 1;
moc_objecttypesmodel.cpp:        - idx * sizeof(QByteArrayData) \
moc_objecttypesmodel.cpp:        case 0: _t->appendNewObjectType(); break;
moc_objecttypesmodel.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_objecttypesmodel.cpp:        _id -= 1;
moc_objecttypesmodel.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_objecttypesmodel.cpp:        _id -= 1;
Binary file createmultipointobjecttool.o matches
layerdock.cpp: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
layerdock.cpp:    layout->setMargin(5);
layerdock.cpp:    mOpacitySlider->setRange(0, 100);
layerdock.cpp:    mOpacitySlider->setEnabled(false);
layerdock.cpp:    opacityLayout->addWidget(mOpacityLabel);
layerdock.cpp:    opacityLayout->addWidget(mOpacitySlider);
layerdock.cpp:    mOpacityLabel->setBuddy(mOpacitySlider);
layerdock.cpp:    newLayerMenu->addAction(handler->actionAddTileLayer());
layerdock.cpp:    newLayerMenu->addAction(handler->actionAddObjectGroup());
layerdock.cpp:    newLayerMenu->addAction(handler->actionAddImageLayer());
layerdock.cpp:    const QIcon newIcon(QLatin1String(":/images/16x16/document-new.png"));
layerdock.cpp:    newLayerButton->setPopupMode(QToolButton::InstantPopup);
layerdock.cpp:    newLayerButton->setMenu(newLayerMenu);
layerdock.cpp:    newLayerButton->setIcon(newIcon);
layerdock.cpp:    Utils::setThemeIcon(newLayerButton, "document-new");
layerdock.cpp:    buttonContainer->setFloatable(false);
layerdock.cpp:    buttonContainer->setMovable(false);
layerdock.cpp:    buttonContainer->setIconSize(QSize(16, 16));
layerdock.cpp:    buttonContainer->addWidget(newLayerButton);
layerdock.cpp:    buttonContainer->addAction(handler->actionMoveLayerUp());
layerdock.cpp:    buttonContainer->addAction(handler->actionMoveLayerDown());
layerdock.cpp:    buttonContainer->addAction(handler->actionDuplicateLayer());
layerdock.cpp:    buttonContainer->addAction(handler->actionRemoveLayer());
layerdock.cpp:    buttonContainer->addSeparator();
layerdock.cpp:    buttonContainer->addAction(handler->actionToggleOtherLayers());
layerdock.cpp:    listAndToolBar->setSpacing(0);
layerdock.cpp:    listAndToolBar->addWidget(mLayerView);
layerdock.cpp:    listAndToolBar->addWidget(buttonContainer);
layerdock.cpp:    layout->addLayout(opacityLayout);
layerdock.cpp:    layout->addLayout(listAndToolBar);
layerdock.cpp:        mMapDocument->disconnect(this);
layerdock.cpp:    mLayerView->setMapDocument(mapDocument);
layerdock.cpp:    switch (e->type()) {
layerdock.cpp:                         mMapDocument->currentLayerIndex() != -1;
layerdock.cpp:    mOpacitySlider->setEnabled(enabled);
layerdock.cpp:    mOpacityLabel->setEnabled(enabled);
layerdock.cpp:        qreal opacity = mMapDocument->currentLayer()->opacity();
layerdock.cpp:        mOpacitySlider->setValue((int) (opacity * 100));
layerdock.cpp:        mOpacitySlider->setValue(100);
layerdock.cpp:    if (index != mMapDocument->currentLayerIndex())
layerdock.cpp:    const LayerModel *layerModel = mMapDocument->layerModel();
layerdock.cpp:    const int currentLayerIndex = mMapDocument->currentLayerIndex();
layerdock.cpp:    const int row = layerModel->layerIndexToRow(currentLayerIndex);
layerdock.cpp:    mLayerView->edit(layerModel->index(row));
layerdock.cpp:    const int layerIndex = mMapDocument->currentLayerIndex();
layerdock.cpp:    if (layerIndex == -1)
layerdock.cpp:    const Layer *layer = mMapDocument->map()->layerAt(layerIndex);
layerdock.cpp:    if ((int) (layer->opacity() * 100) != opacity) {
layerdock.cpp:        LayerModel *layerModel = mMapDocument->layerModel();
layerdock.cpp:        const int row = layerModel->layerIndexToRow(layerIndex);
layerdock.cpp:        layerModel->setData(layerModel->index(row),
layerdock.cpp:    mOpacityLabel->setText(tr("Opacity:"));
layerdock.cpp:        mMapDocument->disconnect(this);
layerdock.cpp:        setModel(mMapDocument->layerModel());
layerdock.cpp:        currentLayerIndexChanged(mMapDocument->currentLayerIndex());
layerdock.cpp:    const int layer = mMapDocument->layerModel()->toLayerIndex(index);
layerdock.cpp:    mMapDocument->setCurrentLayerIndex(layer);
layerdock.cpp:    const int layerIndex = mMapDocument->layerModel()->toLayerIndex(index);
layerdock.cpp:    if (layerIndex != -1) {
layerdock.cpp:        Layer *layer = mMapDocument->map()->layerAt(layerIndex);
layerdock.cpp:        mMapDocument->setCurrentObject(layer);
layerdock.cpp:    if (index > -1) {
layerdock.cpp:        const LayerModel *layerModel = mMapDocument->layerModel();
layerdock.cpp:        const int row = layerModel->layerIndexToRow(index);
layerdock.cpp:        setCurrentIndex(layerModel->index(row, 0));
layerdock.cpp:    const QModelIndex index = indexAt(event->pos());
layerdock.cpp:    const LayerModel *m = mMapDocument->layerModel();
layerdock.cpp:    const int layerIndex = m->toLayerIndex(index);
layerdock.cpp:    menu.addAction(handler->actionAddTileLayer());
layerdock.cpp:    menu.addAction(handler->actionAddObjectGroup());
layerdock.cpp:    menu.addAction(handler->actionAddImageLayer());
layerdock.cpp:        menu.addAction(handler->actionDuplicateLayer());
layerdock.cpp:        menu.addAction(handler->actionMergeLayerDown());
layerdock.cpp:        menu.addAction(handler->actionRemoveLayer());
layerdock.cpp:        menu.addAction(handler->actionMoveLayerUp());
layerdock.cpp:        menu.addAction(handler->actionMoveLayerDown());
layerdock.cpp:        menu.addAction(handler->actionToggleOtherLayers());
layerdock.cpp:        menu.addAction(handler->actionLayerProperties());
layerdock.cpp:    menu.exec(event->globalPos());
layerdock.cpp:    const LayerModel *m = mMapDocument->layerModel();
layerdock.cpp:    const int layerIndex = m->toLayerIndex(index);
layerdock.cpp:    if (event->key() == Qt::Key_Delete) {
layerdock.cpp:        mMapDocument->removeLayer(layerIndex);
mainwindow.cpp: * Copyright 2008-2015, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
mainwindow.cpp: * Copyright 2009-2010, Jeff Bland <jksb@member.fsf.org>
mainwindow.cpp: * Copyright 2010-2011, Stefan Beller <stefanbeller@googlemail.com>
mainwindow.cpp:    mUi->setupUi(this);
mainwindow.cpp:    setCentralWidget(mDocumentManager->widget());
mainwindow.cpp:    QIcon redoIcon(QLatin1String(":images/16x16/edit-redo.png"));
mainwindow.cpp:    QIcon undoIcon(QLatin1String(":images/16x16/edit-undo.png"));
mainwindow.cpp:    QIcon newIcon = mUi->actionNew->icon();
mainwindow.cpp:    QIcon openIcon = mUi->actionOpen->icon();
mainwindow.cpp:    QIcon saveIcon = mUi->actionSave->icon();
mainwindow.cpp:    newIcon.addFile(QLatin1String(":images/24x24/document-new.png"));
mainwindow.cpp:    openIcon.addFile(QLatin1String(":images/24x24/document-open.png"));
mainwindow.cpp:    saveIcon.addFile(QLatin1String(":images/24x24/document-save.png"));
mainwindow.cpp:    redoIcon.addFile(QLatin1String(":images/24x24/edit-redo.png"));
mainwindow.cpp:    undoIcon.addFile(QLatin1String(":images/24x24/edit-undo.png"));
mainwindow.cpp:    mUi->actionNew->setIcon(newIcon);
mainwindow.cpp:    mUi->actionOpen->setIcon(openIcon);
mainwindow.cpp:    mUi->actionSave->setIcon(saveIcon);
mainwindow.cpp:    QUndoGroup *undoGroup = mDocumentManager->undoGroup();
mainwindow.cpp:    QAction *undoAction = undoGroup->createUndoAction(this, tr("Undo"));
mainwindow.cpp:    QAction *redoAction = undoGroup->createRedoAction(this, tr("Redo"));
mainwindow.cpp:    mUi->mainToolBar->setToolButtonStyle(Qt::ToolButtonFollowStyle);
mainwindow.cpp:    mUi->actionNew->setPriority(QAction::LowPriority);
mainwindow.cpp:    undoAction->setPriority(QAction::LowPriority);
mainwindow.cpp:    redoAction->setPriority(QAction::LowPriority);
mainwindow.cpp:    redoAction->setIcon(redoIcon);
mainwindow.cpp:    undoAction->setIcon(undoIcon);
mainwindow.cpp:    redoAction->setIconText(tr("Redo"));
mainwindow.cpp:    undoAction->setIconText(tr("Undo"));
mainwindow.cpp:    undoDock->setVisible(false);
mainwindow.cpp:    mMapsDock->setVisible(false);
mainwindow.cpp:    mConsoleDock->setVisible(false);
mainwindow.cpp:    tileStampsDock->setVisible(false);
mainwindow.cpp:    statusBar()->addPermanentWidget(mZoomComboBox);
mainwindow.cpp:    mUi->actionNew->setShortcuts(QKeySequence::New);
mainwindow.cpp:    mUi->actionOpen->setShortcuts(QKeySequence::Open);
mainwindow.cpp:    mUi->actionSave->setShortcuts(QKeySequence::Save);
mainwindow.cpp:    mUi->actionSaveAs->setShortcuts(QKeySequence::SaveAs);
mainwindow.cpp:    mUi->actionClose->setShortcuts(QKeySequence::Close);
mainwindow.cpp:    mUi->actionQuit->setShortcuts(QKeySequence::Quit);
mainwindow.cpp:    mUi->actionCut->setShortcuts(QKeySequence::Cut);
mainwindow.cpp:    mUi->actionCopy->setShortcuts(QKeySequence::Copy);
mainwindow.cpp:    mUi->actionPaste->setShortcuts(QKeySequence::Paste);
mainwindow.cpp:    mUi->actionDelete->setShortcuts(deleteKeys);
mainwindow.cpp:    undoAction->setShortcuts(QKeySequence::Undo);
mainwindow.cpp:    redoAction->setShortcuts(QKeySequence::Redo);
mainwindow.cpp:    mUi->actionShowGrid->setChecked(preferences->showGrid());
mainwindow.cpp:    mUi->actionShowTileObjectOutlines->setChecked(preferences->showTileObjectOutlines());
mainwindow.cpp:    mUi->actionShowTileAnimations->setChecked(preferences->showTileAnimations());
mainwindow.cpp:    mUi->actionSnapToGrid->setChecked(preferences->snapToGrid());
mainwindow.cpp:    mUi->actionSnapToFineGrid->setChecked(preferences->snapToFineGrid());
mainwindow.cpp:    mUi->actionHighlightCurrentLayer->setChecked(preferences->highlightCurrentLayer());
mainwindow.cpp:    mUi->actionNoLabels->setActionGroup(objectLabelVisibilityGroup);
mainwindow.cpp:    mUi->actionLabelsForSelectedObjects->setActionGroup(objectLabelVisibilityGroup);
mainwindow.cpp:    mUi->actionLabelsForAllObjects->setActionGroup(objectLabelVisibilityGroup);
mainwindow.cpp:    switch (preferences->objectLabelVisibility()) {
mainwindow.cpp:        mUi->actionNoLabels->setChecked(true);
mainwindow.cpp:        mUi->actionLabelsForSelectedObjects->setChecked(true);
mainwindow.cpp:        mUi->actionLabelsForAllObjects->setChecked(true);
mainwindow.cpp:    mUi->actionZoomIn->setShortcuts(keys);
mainwindow.cpp:    keys += QKeySequence(tr("-"));
mainwindow.cpp:    mUi->actionZoomOut->setShortcuts(keys);
mainwindow.cpp:    mUi->menuEdit->insertAction(mUi->actionCut, undoAction);
mainwindow.cpp:    mUi->menuEdit->insertAction(mUi->actionCut, redoAction);
mainwindow.cpp:    mUi->menuEdit->insertSeparator(mUi->actionCut);
mainwindow.cpp:    mUi->menuEdit->insertAction(mUi->actionPreferences,
mainwindow.cpp:                                mActionHandler->actionSelectAll());
mainwindow.cpp:    mUi->menuEdit->insertAction(mUi->actionPreferences,
mainwindow.cpp:                                mActionHandler->actionSelectNone());
mainwindow.cpp:    mUi->menuEdit->insertSeparator(mUi->actionPreferences);
mainwindow.cpp:    mUi->mainToolBar->addAction(undoAction);
mainwindow.cpp:    mUi->mainToolBar->addAction(redoAction);
mainwindow.cpp:    mUi->mainToolBar->addSeparator();
mainwindow.cpp:    mUi->mainToolBar->addWidget(mCommandButton);
mainwindow.cpp:    mUi->menuMap->insertAction(mUi->actionOffsetMap,
mainwindow.cpp:                               mActionHandler->actionCropToSelection());
mainwindow.cpp:    mRandomButton->setToolTip(tr("Random Mode"));
mainwindow.cpp:    mRandomButton->setIcon(QIcon(QLatin1String(":images/24x24/dice.png")));
mainwindow.cpp:    mRandomButton->setCheckable(true);
mainwindow.cpp:    mRandomButton->setShortcut(QKeySequence(tr("D")));
mainwindow.cpp:    mUi->mainToolBar->addWidget(mRandomButton);
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionAddTileLayer());
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionAddObjectGroup());
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionAddImageLayer());
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionDuplicateLayer());
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionMergeLayerDown());
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionRemoveLayer());
mainwindow.cpp:    mLayerMenu->addSeparator();
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionSelectPreviousLayer());
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionSelectNextLayer());
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionMoveLayerUp());
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionMoveLayerDown());
mainwindow.cpp:    mLayerMenu->addSeparator();
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionToggleOtherLayers());
mainwindow.cpp:    mLayerMenu->addSeparator();
mainwindow.cpp:    mLayerMenu->addAction(mActionHandler->actionLayerProperties());
mainwindow.cpp:    menuBar()->insertMenu(mUi->menuHelp->menuAction(), mLayerMenu);
mainwindow.cpp:    connect(mUi->actionSelectAllTiles, SIGNAL(triggered()), SLOT(selectAllTiles()));
mainwindow.cpp:    connect(mUi->actionNew, SIGNAL(triggered()), SLOT(newMap()));
mainwindow.cpp:    connect(mUi->actionOpen, SIGNAL(triggered()), SLOT(openFile()));
mainwindow.cpp:    connect(mUi->actionClearRecentFiles, SIGNAL(triggered()),
mainwindow.cpp:    connect(mUi->actionSave, SIGNAL(triggered()), SLOT(saveFile()));
mainwindow.cpp:    connect(mUi->actionSaveAs, SIGNAL(triggered()), SLOT(saveFileAs()));
mainwindow.cpp:    connect(mUi->actionSaveAll, SIGNAL(triggered()), SLOT(saveAll()));
mainwindow.cpp:    connect(mUi->actionExportAsImage, SIGNAL(triggered()), SLOT(exportAsImage()));
mainwindow.cpp:    connect(mUi->actionExport, SIGNAL(triggered()), SLOT(export_()));
mainwindow.cpp:    connect(mUi->actionExportAs, SIGNAL(triggered()), SLOT(exportAs()));
mainwindow.cpp:    connect(mUi->actionReload, SIGNAL(triggered()), SLOT(reload()));
mainwindow.cpp:    connect(mUi->actionClose, SIGNAL(triggered()), SLOT(closeFile()));
mainwindow.cpp:    connect(mUi->actionCloseAll, SIGNAL(triggered()), SLOT(closeAllFiles()));
mainwindow.cpp:    connect(mUi->actionQuit, SIGNAL(triggered()), SLOT(close()));
mainwindow.cpp:    connect(mUi->actionCut, SIGNAL(triggered()), SLOT(cut()));
mainwindow.cpp:    connect(mUi->actionCopy, SIGNAL(triggered()), SLOT(copy()));
mainwindow.cpp:    connect(mUi->actionPaste, SIGNAL(triggered()), SLOT(paste()));
mainwindow.cpp:    connect(mUi->actionDelete, SIGNAL(triggered()), SLOT(delete_()));
mainwindow.cpp:    connect(mUi->actionPreferences, SIGNAL(triggered()),
mainwindow.cpp:    connect(mUi->actionShowGrid, SIGNAL(toggled(bool)),
mainwindow.cpp:    connect(mUi->actionShowTileObjectOutlines, SIGNAL(toggled(bool)),
mainwindow.cpp:    connect(mUi->actionShowTileAnimations, SIGNAL(toggled(bool)),
mainwindow.cpp:    connect(mUi->actionSnapToGrid, SIGNAL(toggled(bool)),
mainwindow.cpp:    connect(mUi->actionSnapToFineGrid, SIGNAL(toggled(bool)),
mainwindow.cpp:    connect(mUi->actionHighlightCurrentLayer, SIGNAL(toggled(bool)),
mainwindow.cpp:    connect(mUi->actionZoomIn, SIGNAL(triggered()), SLOT(zoomIn()));
mainwindow.cpp:    connect(mUi->actionZoomOut, SIGNAL(triggered()), SLOT(zoomOut()));
mainwindow.cpp:    connect(mUi->actionZoomNormal, SIGNAL(triggered()), SLOT(zoomNormal()));
mainwindow.cpp:    connect(mUi->actionNewTileset, SIGNAL(triggered()), SLOT(newTileset()));
mainwindow.cpp:    connect(mUi->actionAddExternalTileset, SIGNAL(triggered()),
mainwindow.cpp:    connect(mUi->actionResizeMap, SIGNAL(triggered()), SLOT(resizeMap()));
mainwindow.cpp:    connect(mUi->actionOffsetMap, SIGNAL(triggered()), SLOT(offsetMap()));
mainwindow.cpp:    connect(mUi->actionMapProperties, SIGNAL(triggered()),
mainwindow.cpp:    connect(mUi->actionAutoMap, SIGNAL(triggered()),
mainwindow.cpp:    connect(mUi->actionDocumentation, SIGNAL(triggered()), SLOT(openDocumentation()));
mainwindow.cpp:    connect(mUi->actionBecomePatron, SIGNAL(triggered()), SLOT(becomePatron()));
mainwindow.cpp:    connect(mUi->actionAbout, SIGNAL(triggered()), SLOT(aboutTiled()));
mainwindow.cpp:         mUi->menuRecentFiles->insertAction(mUi->actionClearRecentFiles,
mainwindow.cpp:         mRecentFiles[i]->setVisible(false);
mainwindow.cpp:    mUi->menuRecentFiles->insertSeparator(mUi->actionClearRecentFiles);
mainwindow.cpp:    setThemeIcon(mUi->actionNew, "document-new");
mainwindow.cpp:    setThemeIcon(mUi->actionSelectAllTiles, "select-tile");
mainwindow.cpp:    setThemeIcon(mUi->actionOpen, "document-open");
mainwindow.cpp:    setThemeIcon(mUi->menuRecentFiles, "document-open-recent");
mainwindow.cpp:    setThemeIcon(mUi->actionClearRecentFiles, "edit-clear");
mainwindow.cpp:    setThemeIcon(mUi->actionSave, "document-save");
mainwindow.cpp:    setThemeIcon(mUi->actionSaveAs, "document-save-as");
mainwindow.cpp:    setThemeIcon(mUi->actionClose, "window-close");
mainwindow.cpp:    setThemeIcon(mUi->actionQuit, "application-exit");
mainwindow.cpp:    setThemeIcon(mUi->actionCut, "edit-cut");
mainwindow.cpp:    setThemeIcon(mUi->actionCopy, "edit-copy");
mainwindow.cpp:    setThemeIcon(mUi->actionPaste, "edit-paste");
mainwindow.cpp:    setThemeIcon(mUi->actionDelete, "edit-delete");
mainwindow.cpp:    setThemeIcon(redoAction, "edit-redo");
mainwindow.cpp:    setThemeIcon(undoAction, "edit-undo");
mainwindow.cpp:    setThemeIcon(mUi->actionZoomIn, "zoom-in");
mainwindow.cpp:    setThemeIcon(mUi->actionZoomOut, "zoom-out");
mainwindow.cpp:    setThemeIcon(mUi->actionZoomNormal, "zoom-original");
mainwindow.cpp:    setThemeIcon(mUi->actionNewTileset, "document-new");
mainwindow.cpp:    setThemeIcon(mUi->actionResizeMap, "document-page-setup");
mainwindow.cpp:    setThemeIcon(mUi->actionMapProperties, "document-properties");
mainwindow.cpp:    setThemeIcon(mUi->actionDocumentation, "help-contents");
mainwindow.cpp:    setThemeIcon(mUi->actionAbout, "help-about");
mainwindow.cpp:    QToolBar *toolBar = mUi->toolsToolBar;
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(mStampBrush));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(mTerrainBrush));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(mBucketFillTool));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(new Eraser(this)));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(new TileSelectionTool(this)));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(new MagicWandTool(this)));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(new SelectSameTileTool(this)));
mainwindow.cpp:    toolBar->addSeparator();
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(new ObjectSelectionTool(this)));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(new EditPolygonTool(this)));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(rectangleObjectsTool));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(ellipseObjectsTool));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(polygonObjectsTool));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(polylineObjectsTool));
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(tileObjectsTool));
mainwindow.cpp:    toolBar->addSeparator();
mainwindow.cpp:    toolBar->addAction(mToolManager->registerTool(new ImageMovementTool(this)));
mainwindow.cpp:    mDocumentManager->setSelectedTool(mToolManager->selectedTool());
mainwindow.cpp:    statusBar()->addWidget(mStatusInfoLabel);
mainwindow.cpp:    statusBar()->addWidget(mCurrentLayerLabel);
mainwindow.cpp:    mShowTileAnimationEditor->setCheckable(true);
mainwindow.cpp:    mShowTileCollisionEditor->setCheckable(true);
mainwindow.cpp:    mShowTileCollisionEditor->setShortcut(tr("Ctrl+Shift+O"));
mainwindow.cpp:    mShowTileCollisionEditor->setShortcutContext(Qt::ApplicationShortcut);
mainwindow.cpp:    popupMenu->setParent(this);
mainwindow.cpp:    mViewsAndToolbarsMenu->setMenu(popupMenu);
mainwindow.cpp:    mUi->menuView->insertAction(mUi->actionShowGrid, mViewsAndToolbarsMenu);
mainwindow.cpp:    mUi->menuView->insertAction(mUi->actionShowGrid, mShowTileAnimationEditor);
mainwindow.cpp:    mUi->menuView->insertAction(mUi->actionShowGrid, mShowTileCollisionEditor);
mainwindow.cpp:    mUi->menuView->insertSeparator(mUi->actionShowGrid);
mainwindow.cpp:    mDocumentManager->closeAllDocuments();
mainwindow.cpp:    mTileAnimationEditor->setTile(nullptr);
mainwindow.cpp:    mTileAnimationEditor->writeSettings();
mainwindow.cpp:    mTileCollisionEditor->setTile(nullptr);
mainwindow.cpp:    mTileCollisionEditor->writeSettings();
mainwindow.cpp:        event->accept();
mainwindow.cpp:        event->ignore();
mainwindow.cpp:    switch (event->type()) {
mainwindow.cpp:        mUi->retranslateUi(this);
mainwindow.cpp:    if (event->key() == Qt::Key_Space && !event->isAutoRepeat())
mainwindow.cpp:        if (MapView *mapView = mDocumentManager->currentMapView())
mainwindow.cpp:            mapView->setHandScrolling(true);
mainwindow.cpp:    if (event->key() == Qt::Key_Space && !event->isAutoRepeat())
mainwindow.cpp:        if (MapView *mapView = mDocumentManager->currentMapView())
mainwindow.cpp:            mapView->setHandScrolling(false);
mainwindow.cpp:    const QList<QUrl> urls = e->mimeData()->urls();
mainwindow.cpp:        e->accept();
mainwindow.cpp:    foreach (const QUrl &url, e->mimeData()->urls())
mainwindow.cpp:    mDocumentManager->addDocument(mapDocument);
mainwindow.cpp:    int documentIndex = mDocumentManager->findDocument(fileName);
mainwindow.cpp:    if (documentIndex != -1) {
mainwindow.cpp:        mDocumentManager->switchToDocument(documentIndex);
mainwindow.cpp:    mDocumentManager->addDocument(mapDocument);
mainwindow.cpp:        for (; openCount; --openCount)
mainwindow.cpp:            lastOpenFiles.append(recentFiles.at(openCount - 1));
mainwindow.cpp:            MapView *mapView = mDocumentManager->currentMapView();
mainwindow.cpp:                mapView->zoomable()->setScale(scale);
mainwindow.cpp:            mapView->horizontalScrollBar()->setSliderPosition(hor);
mainwindow.cpp:            mapView->verticalScrollBar()->setSliderPosition(ver);
mainwindow.cpp:            if (layer > 0 && layer < mMapDocument->map()->layerCount())
mainwindow.cpp:                mMapDocument->setCurrentLayerIndex(layer);
mainwindow.cpp:    int documentIndex = mDocumentManager->findDocument(lastActiveDocument);
mainwindow.cpp:    if (documentIndex != -1)
mainwindow.cpp:        mDocumentManager->switchToDocument(documentIndex);
mainwindow.cpp:    if (!mMapDocument->save(fileName, &error)) {
mainwindow.cpp:    const QString currentFileName = mMapDocument->fileName();
mainwindow.cpp:        if (MapFormat *format = mMapDocument->writerFormat())
mainwindow.cpp:            selectedFilter = format->nameFilter();
mainwindow.cpp:    if (mMapDocument && !mMapDocument->fileName().isEmpty()) {
mainwindow.cpp:        suggestedFileName = mMapDocument->fileName();
mainwindow.cpp:    mMapDocument->setWriterFormat(format);
mainwindow.cpp:    foreach (MapDocument *mapDoc, mDocumentManager->documents()) {
mainwindow.cpp:        if (!mapDoc->isModified())
mainwindow.cpp:        QString fileName(mapDoc->fileName());
mainwindow.cpp:            mDocumentManager->switchToDocument(mapDoc);
mainwindow.cpp:        } else if (!mapDoc->save(fileName, &error)) {
mainwindow.cpp:            mDocumentManager->switchToDocument(mapDoc);
mainwindow.cpp:    if (!mapDocument || !mapDocument->isModified())
mainwindow.cpp:    mDocumentManager->switchToDocument(mapDocument);
mainwindow.cpp:    for (int i = 0; i < mDocumentManager->documentCount(); ++i) {
mainwindow.cpp:        if (!confirmSave(mDocumentManager->documents().at(i)))
mainwindow.cpp:    QString exportFileName = mMapDocument->lastExportFileName();
mainwindow.cpp:        MapFormat *exportFormat = mMapDocument->exportFormat();
mainwindow.cpp:        if (exportFormat->write(mMapDocument->map(), exportFileName)) {
mainwindow.cpp:            statusBar()->showMessage(tr("Exported to %1").arg(exportFileName),
mainwindow.cpp:                              exportFormat->errorString());
mainwindow.cpp:    QString suggestedFilename = mMapDocument->lastExportFileName();
mainwindow.cpp:        QFileInfo baseNameInfo = QFileInfo(mMapDocument->fileName());
mainwindow.cpp:        QString lastExportedFilePath = pref->lastPath(Preferences::ExportedFile);
mainwindow.cpp:            if (format->nameFilter().contains(suffix, Qt::CaseInsensitive)) {
mainwindow.cpp:                    QMessageBox::warning(this, tr("Non-unique file extension"),
mainwindow.cpp:                                         tr("Non-unique file extension.\n"
mainwindow.cpp:    QStringList outputFiles = chosenFormat->outputFiles(mMapDocument->map(),
mainwindow.cpp:    pref->setLastPath(Preferences::ExportedFile, QFileInfo(fileName).path());
mainwindow.cpp:    if (!chosenFormat->write(mMapDocument->map(), fileName)) {
mainwindow.cpp:                              chosenFormat->errorString());
mainwindow.cpp:        mMapDocument->setLastExportFileName(fileName);
mainwindow.cpp:            mMapDocument->setExportFormat(chosenFormat);
mainwindow.cpp:    MapView *mapView = mDocumentManager->currentMapView();
mainwindow.cpp:                               mMapDocument->fileName(),
mainwindow.cpp:                               mapView->zoomable()->scale(),
mainwindow.cpp:    if (confirmSave(mDocumentManager->currentDocument()))
mainwindow.cpp:        mDocumentManager->reloadCurrentDocument();
mainwindow.cpp:    if (confirmSave(mDocumentManager->currentDocument()))
mainwindow.cpp:        mDocumentManager->closeCurrentDocument();
mainwindow.cpp:        mDocumentManager->closeAllDocuments();
mainwindow.cpp:    Layer *currentLayer = mMapDocument->currentLayer();
mainwindow.cpp:    const QRegion &selectedArea = mMapDocument->selectedArea();
mainwindow.cpp:    const QList<MapObject*> &selectedObjects = mMapDocument->selectedObjects();
mainwindow.cpp:    QUndoStack *stack = mMapDocument->undoStack();
mainwindow.cpp:    stack->beginMacro(tr("Cut"));
mainwindow.cpp:        stack->push(new EraseTiles(mMapDocument, tileLayer, selectedArea));
mainwindow.cpp:            stack->push(new RemoveMapObject(mMapDocument, mapObject));
mainwindow.cpp:    mActionHandler->selectNone();
mainwindow.cpp:    stack->endMacro();
mainwindow.cpp:    ClipboardManager::instance()->copySelection(mMapDocument);
mainwindow.cpp:    Layer *currentLayer = mMapDocument->currentLayer();
mainwindow.cpp:    QScopedPointer<Map> map(clipboardManager->map());
mainwindow.cpp:    if (map->layerCount() != 1)
mainwindow.cpp:    tilesetManager->addReferences(map->tilesets());
mainwindow.cpp:    mMapDocument->unifyTilesets(map.data());
mainwindow.cpp:    Layer *layer = map->layerAt(0);
mainwindow.cpp:    if (layer->isTileLayer()) {
mainwindow.cpp:        mActionHandler->selectNone();
mainwindow.cpp:        tilesetManager->removeReferences(stamp->tilesets());
mainwindow.cpp:        mToolManager->selectTool(mStampBrush);
mainwindow.cpp:    } else if (ObjectGroup *objectGroup = layer->asObjectGroup()) {
mainwindow.cpp:        const MapView *view = mDocumentManager->currentMapView();
mainwindow.cpp:        clipboardManager->pasteObjectGroup(objectGroup, mMapDocument, view);
mainwindow.cpp:        tilesetManager->removeReferences(map->tilesets());
mainwindow.cpp:    Layer *currentLayer = mMapDocument->currentLayer();
mainwindow.cpp:    const QRegion &selectedArea = mMapDocument->selectedArea();
mainwindow.cpp:    const QList<MapObject*> &selectedObjects = mMapDocument->selectedObjects();
mainwindow.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
mainwindow.cpp:    undoStack->beginMacro(tr("Delete"));
mainwindow.cpp:        undoStack->push(new EraseTiles(mMapDocument, tileLayer, selectedArea));
mainwindow.cpp:            undoStack->push(new RemoveMapObject(mMapDocument, mapObject));
mainwindow.cpp:    mActionHandler->selectNone();
mainwindow.cpp:    undoStack->endMacro();
mainwindow.cpp:    if (action == mUi->actionLabelsForSelectedObjects)
mainwindow.cpp:    else if (action == mUi->actionLabelsForAllObjects)
mainwindow.cpp:    Preferences::instance()->setObjectLabelVisibility(visibility);
mainwindow.cpp:    if (MapView *mapView = mDocumentManager->currentMapView())
mainwindow.cpp:        mapView->zoomable()->zoomIn();
mainwindow.cpp:    if (MapView *mapView = mDocumentManager->currentMapView())
mainwindow.cpp:        mapView->zoomable()->zoomOut();
mainwindow.cpp:    if (MapView *mapView = mDocumentManager->currentMapView())
mainwindow.cpp:        mapView->zoomable()->resetZoom();
mainwindow.cpp:    Map *map = mMapDocument->map();
mainwindow.cpp:            ? QFileInfo(prefs->lastPath(Preferences::ImageFile)).absolutePath()
mainwindow.cpp:    newTileset.setTileWidth(map->tileWidth());
mainwindow.cpp:    newTileset.setTileHeight(map->tileHeight());
mainwindow.cpp:        mMapDocument->undoStack()->push(new AddTileset(mMapDocument, tileset));
mainwindow.cpp:        prefs->setLastPath(Preferences::ImageFile, tileset->imageSource());
mainwindow.cpp:    Map *map = mMapDocument->map();
mainwindow.cpp:    QVector<SharedTileset> tilesets = map->tilesets();
mainwindow.cpp:        tilesetManager->forceTilesetReload(tileset);
mainwindow.cpp:    QString start = prefs->lastPath(Preferences::ExternalTileset);
mainwindow.cpp:    prefs->setLastPath(Preferences::ExternalTileset,
mainwindow.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
mainwindow.cpp:    undoStack->beginMacro(tr("Add %n Tileset(s)", "", tilesets.size()));
mainwindow.cpp:        undoStack->push(new AddTileset(mMapDocument, tileset));
mainwindow.cpp:    undoStack->endMacro();
mainwindow.cpp:    Map *map = mMapDocument->map();
mainwindow.cpp:    resizeDialog.setOldSize(map->size());
mainwindow.cpp:        if (newSize != map->size() || !offset.isNull())
mainwindow.cpp:            mMapDocument->resizeMap(newSize, offset);
mainwindow.cpp:        mMapDocument->offsetMap(layerIndexes,
mainwindow.cpp:    mMapDocument->setCurrentObject(mMapDocument->map());
mainwindow.cpp:    mMapDocument->emitEditCurrentObject();
mainwindow.cpp:    QString error = mAutomappingManager->errorString();
mainwindow.cpp:            statusBar()->showMessage(error, 3000);
mainwindow.cpp:    QString warning = mAutomappingManager->warningString();
mainwindow.cpp:            statusBar()->showMessage(warning, 3000);
mainwindow.cpp:    mShowTileAnimationEditor->setChecked(false);
mainwindow.cpp:    mShowTileCollisionEditor->setChecked(false);
mainwindow.cpp:        openFile(action->data().toString());
mainwindow.cpp:        mRecentFiles[i]->setText(QFileInfo(files[i]).fileName());
mainwindow.cpp:        mRecentFiles[i]->setData(files[i]);
mainwindow.cpp:        mRecentFiles[i]->setVisible(true);
mainwindow.cpp:        mRecentFiles[j]->setVisible(false);
mainwindow.cpp:    mUi->menuRecentFiles->setEnabled(numRecentFiles > 0);
mainwindow.cpp:        Layer *currentLayer = mMapDocument->currentLayer();
mainwindow.cpp:        map = mMapDocument->map();
mainwindow.cpp:        objectsSelected = !mMapDocument->selectedObjects().isEmpty();
mainwindow.cpp:        selection = mMapDocument->selectedArea();
mainwindow.cpp:    mUi->actionSave->setEnabled(map);
mainwindow.cpp:    mUi->actionSelectAllTiles->setEnabled(map);
mainwindow.cpp:    mUi->actionSaveAs->setEnabled(map);
mainwindow.cpp:    mUi->actionSaveAll->setEnabled(map);
mainwindow.cpp:    mUi->actionExportAsImage->setEnabled(map);
mainwindow.cpp:    mUi->actionExport->setEnabled(map);
mainwindow.cpp:    mUi->actionExportAs->setEnabled(map);
mainwindow.cpp:    mUi->actionReload->setEnabled(map);
mainwindow.cpp:    mUi->actionClose->setEnabled(map);
mainwindow.cpp:    mUi->actionCloseAll->setEnabled(map);
mainwindow.cpp:    mUi->actionCut->setEnabled(canCopy);
mainwindow.cpp:    mUi->actionCopy->setEnabled(canCopy);
mainwindow.cpp:    mUi->actionPaste->setEnabled(ClipboardManager::instance()->hasMap());
mainwindow.cpp:    mUi->actionDelete->setEnabled(canCopy);
mainwindow.cpp:    mUi->actionNewTileset->setEnabled(map);
mainwindow.cpp:    mUi->actionAddExternalTileset->setEnabled(map);
mainwindow.cpp:    mUi->actionResizeMap->setEnabled(map);
mainwindow.cpp:    mUi->actionOffsetMap->setEnabled(map);
mainwindow.cpp:    mUi->actionMapProperties->setEnabled(map);
mainwindow.cpp:    mUi->actionAutoMap->setEnabled(map);
mainwindow.cpp:    mCommandButton->setEnabled(map);
mainwindow.cpp:    Layer *layer = mMapDocument ? mMapDocument->currentLayer() : 0;
mainwindow.cpp:    mCurrentLayerLabel->setText(tr("Current layer: %1").arg(
mainwindow.cpp:                                    layer ? layer->name() : tr("<none>")));
mainwindow.cpp:    MapView *mapView = mDocumentManager->currentMapView();
mainwindow.cpp:    Zoomable *zoomable = mapView ? mapView->zoomable() : 0;
mainwindow.cpp:    const qreal scale = zoomable ? zoomable->scale() : 1;
mainwindow.cpp:    mUi->actionZoomIn->setEnabled(zoomable && zoomable->canZoomIn());
mainwindow.cpp:    mUi->actionZoomOut->setEnabled(zoomable && zoomable->canZoomOut());
mainwindow.cpp:    mUi->actionZoomNormal->setEnabled(scale != 1);
mainwindow.cpp:        mZoomComboBox->setEnabled(true);
mainwindow.cpp:        int index = mZoomComboBox->findData((qreal)1.0);
mainwindow.cpp:        mZoomComboBox->setCurrentIndex(index);
mainwindow.cpp:        mZoomComboBox->setEnabled(false);
mainwindow.cpp:    if (mStampBrush->isEnabled()) {
mainwindow.cpp:        const TileStamp &stamp = mStampBrush->stamp();
mainwindow.cpp:        mMapDocument->flipSelectedObjects(direction);
mainwindow.cpp:    if (mStampBrush->isEnabled()) {
mainwindow.cpp:        const TileStamp &stamp = mStampBrush->stamp();
mainwindow.cpp:        mMapDocument->rotateSelectedObjects(direction);
mainwindow.cpp:    mStampBrush->setStamp(stamp);
mainwindow.cpp:    mBucketFillTool->setStamp(stamp);
mainwindow.cpp:    AbstractTool *selectedTool = mToolManager->selectedTool();
mainwindow.cpp:        mToolManager->selectTool(mStampBrush);
mainwindow.cpp:    mTilesetDock->selectTilesInStamp(stamp);
mainwindow.cpp:    mTerrainBrush->setTerrain(terrain);
mainwindow.cpp:    AbstractTool *selectedTool = mToolManager->selectedTool();
mainwindow.cpp:        mToolManager->selectTool(mTerrainBrush);
mainwindow.cpp:    mStatusInfoLabel->setText(statusInfo);
mainwindow.cpp:    if (MapDocument *document = mDocumentManager->currentDocument())
mainwindow.cpp:        mSettings.setValue(QLatin1String("lastActive"), document->fileName());
mainwindow.cpp:    for (int i = 0; i < mDocumentManager->documentCount(); i++) {
mainwindow.cpp:        MapDocument *document = mDocumentManager->documents().at(i);
mainwindow.cpp:        MapView *mapView = mDocumentManager->viewForDocument(document);
mainwindow.cpp:        fileList.append(document->fileName());
mainwindow.cpp:        const int currentLayerIndex = document->currentLayerIndex();
mainwindow.cpp:        mapScales.append(QString::number(mapView->zoomable()->scale()));
mainwindow.cpp:                       mapView->horizontalScrollBar()->sliderPosition()));
mainwindow.cpp:                       mapView->verticalScrollBar()->sliderPosition()));
mainwindow.cpp:        setWindowTitle(tr("[*]%1").arg(mMapDocument->displayName()));
mainwindow.cpp:        setWindowFilePath(mMapDocument->fileName());
mainwindow.cpp:        setWindowModified(mMapDocument->isModified());
mainwindow.cpp:    mRandomButton->setToolTip(tr("Random Mode"));
mainwindow.cpp:    mLayerMenu->setTitle(tr("&Layer"));
mainwindow.cpp:    mViewsAndToolbarsMenu->setText(tr("Views and Toolbars"));
mainwindow.cpp:    mShowTileAnimationEditor->setText(tr("Tile Animation Editor"));
mainwindow.cpp:    mShowTileCollisionEditor->setText(tr("Tile Collision Editor"));
mainwindow.cpp:    mActionHandler->retranslateUi();
mainwindow.cpp:    mToolManager->retranslateTools();
mainwindow.cpp:        mMapDocument->disconnect(this);
mainwindow.cpp:        mZoomable->connectToComboBox(0);
mainwindow.cpp:    mActionHandler->setMapDocument(mapDocument);
mainwindow.cpp:    mLayerDock->setMapDocument(mapDocument);
mainwindow.cpp:    mObjectsDock->setMapDocument(mapDocument);
mainwindow.cpp:    mTilesetDock->setMapDocument(mapDocument);
mainwindow.cpp:    mTerrainDock->setMapDocument(mapDocument);
mainwindow.cpp:    mMiniMapDock->setMapDocument(mapDocument);
mainwindow.cpp:    mTileAnimationEditor->setMapDocument(mapDocument);
mainwindow.cpp:    mTileCollisionEditor->setMapDocument(mapDocument);
mainwindow.cpp:    mToolManager->setMapDocument(mapDocument);
mainwindow.cpp:    mAutomappingManager->setMapDocument(mapDocument);
mainwindow.cpp:        if (MapView *mapView = mDocumentManager->currentMapView()) {
mainwindow.cpp:            mZoomable = mapView->zoomable();
mainwindow.cpp:            mZoomable->connectToComboBox(mZoomComboBox);
mainwindow.cpp:        selectMapper->setMapping(selectStamp, i);
mainwindow.cpp:        createMapper->setMapping(createStamp, i);
mainwindow.cpp:        extendMapper->setMapping(extendStamp, i);
mainwindow.cpp:    if (confirmSave(mDocumentManager->documents().at(index)))
mainwindow.cpp:        mDocumentManager->closeDocumentAt(index);
mainwindow.cpp:    QList<SharedTileset> tilesets = tilesetManager->tilesets();
mainwindow.cpp:	for (Tile* tile : tileset->tiles()) {
mainwindow.cpp:		if (tile->hasProperty(property)) {
mainwindow.cpp:			if (tile->property(property) == value) {
Binary file moc_layerdock.o matches
Binary file automapper.o matches
imagelayeritem.h: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
moc_terrainbrush.cpp:        - idx * sizeof(QByteArrayData) \
moc_terrainbrush.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
automappingmanager.cpp: * Copyright 2010-2011, Stefan Beller, stefanbeller@googlemail.com
automappingmanager.cpp:    Map *map = mMapDocument->map();
automappingmanager.cpp:    int w = map->width();
automappingmanager.cpp:    int h = map->height();
automappingmanager.cpp:    if (Preferences::instance()->automappingDrawing())
automappingmanager.cpp:        const QString mapPath = QFileInfo(mMapDocument->fileName()).path();
automappingmanager.cpp:            if (a->ruleLayerNameUsed(touchedLayer->name()))
automappingmanager.cpp:        QUndoStack *undoStack = mMapDocument->undoStack();
automappingmanager.cpp:        undoStack->beginMacro(tr("Apply AutoMap rules"));
automappingmanager.cpp:        undoStack->push(aw);
automappingmanager.cpp:        undoStack->endMacro();
automappingmanager.cpp:        mWarning += automapper->warningString();
automappingmanager.cpp:        mError += automapper->errorString();
automappingmanager.cpp:            tilesetManager->addReferences(rules->tilesets());
automappingmanager.cpp:            mWarning += autoMapper->warningString();
automappingmanager.cpp:            const QString error = autoMapper->errorString(); 
automappingmanager.cpp:        mMapDocument->disconnect(this);
moc_zoomable.cpp:        - idx * sizeof(QByteArrayData) \
moc_zoomable.cpp:        case 0: _t->scaleChanged((*reinterpret_cast< qreal(*)>(_a[1]))); break;
moc_zoomable.cpp:        case 1: _t->zoomIn(); break;
moc_zoomable.cpp:        case 2: _t->zoomOut(); break;
moc_zoomable.cpp:        case 3: _t->resetZoom(); break;
moc_zoomable.cpp:        case 4: _t->comboActivated((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_zoomable.cpp:        case 5: _t->comboEdited(); break;
moc_zoomable.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_zoomable.cpp:        _id -= 6;
moc_zoomable.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_zoomable.cpp:        _id -= 6;
moc_mapview.cpp:        - idx * sizeof(QByteArrayData) \
moc_mapview.cpp:        case 0: _t->adjustScale((*reinterpret_cast< qreal(*)>(_a[1]))); break;
moc_mapview.cpp:        case 1: _t->setUseOpenGL((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_mapview.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_mapview.cpp:        _id -= 2;
moc_mapview.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_mapview.cpp:        _id -= 2;
tilesetmanager.h: * Copyright 2008-2014, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
moc_commanddatamodel.cpp:        - idx * sizeof(QByteArrayData) \
moc_commanddatamodel.cpp:        case 0: { bool _r = _t->move((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])));
moc_commanddatamodel.cpp:        case 1: _t->append((*reinterpret_cast< const Command(*)>(_a[1]))); break;
moc_commanddatamodel.cpp:        case 2: _t->moveUp((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_commanddatamodel.cpp:        case 3: _t->execute((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_commanddatamodel.cpp:        case 4: _t->executeInTerminal((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_commanddatamodel.cpp:        case 5: _t->remove((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_commanddatamodel.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_commanddatamodel.cpp:        _id -= 6;
moc_commanddatamodel.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_commanddatamodel.cpp:        _id -= 6;
Binary file moc_varianteditorfactory.o matches
mapobjectitem.cpp: * Copyright 2008-2011, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
mapobjectitem.cpp:    if (mName != mObject->name() || mPolygon != mObject->polygon() || mColor != color) {
mapobjectitem.cpp:        mName = mObject->name();
mapobjectitem.cpp:        mPolygon = mObject->polygon();
mapobjectitem.cpp:    const QString &type = mObject->type();
mapobjectitem.cpp:    MapRenderer *renderer = mMapDocument->renderer();
mapobjectitem.cpp:    const QPointF pixelPos = renderer->pixelToScreenCoords(mObject->position());
mapobjectitem.cpp:    QRectF bounds = renderer->boundingRect(mObject);
mapobjectitem.cpp:    bounds.translate(-pixelPos);
mapobjectitem.cpp:    setRotation(mObject->rotation());
mapobjectitem.cpp:    if (ObjectGroup *objectGroup = mObject->objectGroup())
mapobjectitem.cpp:        if (objectGroup->drawOrder() == ObjectGroup::TopDownOrder)
mapobjectitem.cpp:    setVisible(mObject->isVisible());
mapobjectitem.cpp:    QPainterPath path = mMapDocument->renderer()->shape(mObject);
mapobjectitem.cpp:    path.translate(-pos());
mapobjectitem.cpp:    qreal scale = static_cast<MapView*>(widget->parent())->zoomable()->scale();
mapobjectitem.cpp:    painter->translate(-pos());
mapobjectitem.cpp:    mMapDocument->renderer()->setPainterScale(scale);
mapobjectitem.cpp:    mMapDocument->renderer()->drawMapObject(painter, mObject, mColor);
mapobjectitem.cpp:    mObject->setSize(size);
mapobjectitem.cpp:    mObject->setPolygon(polygon);
mapobjectitem.cpp:    for (const ObjectType &type : Preferences::instance()->objectTypes()) {
mapobjectitem.cpp:        if (type.name.compare(object->type(), Qt::CaseInsensitive) == 0)
mapobjectitem.cpp:    const ObjectGroup *objectGroup = object->objectGroup();
mapobjectitem.cpp:    if (objectGroup && objectGroup->color().isValid())
mapobjectitem.cpp:        return objectGroup->color();
tiledapplication.cpp:    if (event->type() == QEvent::FileOpen) {
tiledapplication.cpp:        emit fileOpenRequest(fileOpenEvent->file());
Binary file moc_terrainmodel.o matches
mapview.h: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
mapview.h:     * See https://codereview.qt-project.org/#change,74595 for my attempt at
Binary file changepolygon.o matches
mapobjectmodel.cpp:    mObjectGroupIcon(QLatin1String(":/images/16x16/layer-object.png"))
mapobjectmodel.cpp:    if (row >= og->objectCount())
mapobjectmodel.cpp:    if (!mObjects.contains(og->objects().at(row)))
mapobjectmodel.cpp:    return createIndex(row, column, mObjects[og->objects()[row]]);
mapobjectmodel.cpp:        return this->index(mapObject->objectGroup());
mapobjectmodel.cpp:        return og->objectCount();
mapobjectmodel.cpp:            return index.column() ? mapObject->type() : mapObject->name();
mapobjectmodel.cpp:            return QVariant(); // no icon -> maybe the color?
mapobjectmodel.cpp:            return mapObject->isVisible() ? Qt::Checked : Qt::Unchecked;
mapobjectmodel.cpp:            return index.column() ? QVariant() : objectGroup->name();
mapobjectmodel.cpp:            return objectGroup->isVisible() ? Qt::Checked : Qt::Unchecked;
mapobjectmodel.cpp:            return objectGroup->opacity();
mapobjectmodel.cpp:            if (visible != mapObject->isVisible()) {
mapobjectmodel.cpp:                mMapDocument->undoStack()->push(command);
mapobjectmodel.cpp:            if (index.column() == 0 && s != mapObject->name()) {
mapobjectmodel.cpp:                QUndoStack *undo = mMapDocument->undoStack();
mapobjectmodel.cpp:                undo->beginMacro(tr("Change Object Name"));
mapobjectmodel.cpp:                undo->push(new ChangeMapObject(mMapDocument, mapObject,
mapobjectmodel.cpp:                                               s, mapObject->type()));
mapobjectmodel.cpp:                undo->endMacro();
mapobjectmodel.cpp:            if (index.column() == 1 && s != mapObject->type()) {
mapobjectmodel.cpp:                QUndoStack *undo = mMapDocument->undoStack();
mapobjectmodel.cpp:                undo->beginMacro(tr("Change Object Type"));
mapobjectmodel.cpp:                undo->push(new ChangeMapObject(mMapDocument, mapObject,
mapobjectmodel.cpp:                                               mapObject->name(), s));
mapobjectmodel.cpp:                undo->endMacro();
mapobjectmodel.cpp:            LayerModel *layerModel = mMapDocument->layerModel();
mapobjectmodel.cpp:            const int layerIndex = mMap->layers().indexOf(objectGroup);
mapobjectmodel.cpp:            const int row = layerModel->layerIndexToRow(layerIndex);
mapobjectmodel.cpp:            layerModel->setData(layerModel->index(row), value, role);
mapobjectmodel.cpp:            if (objectGroup->name() != newName) {
mapobjectmodel.cpp:                const int layerIndex = mMap->layers().indexOf(objectGroup);
mapobjectmodel.cpp:                mMapDocument->undoStack()->push(rename);
mapobjectmodel.cpp:    const int row = o->objectGroup()->objects().indexOf(o);
mapobjectmodel.cpp:    return oog->mGroup;
mapobjectmodel.cpp:    return oog->mObject;
mapobjectmodel.cpp:    return oog->mGroup ? oog->mGroup : oog->mObject->objectGroup();
mapobjectmodel.cpp:        mMapDocument->disconnect(this);
mapobjectmodel.cpp:        mMap = mMapDocument->map();
mapobjectmodel.cpp:        for (ObjectGroup *og : mMap->objectGroups()) {
mapobjectmodel.cpp:            foreach (MapObject *o, og->objects())
mapobjectmodel.cpp:    Layer *layer = mMap->layerAt(index);
mapobjectmodel.cpp:    if (ObjectGroup *og = layer->asObjectGroup()) {
mapobjectmodel.cpp:            for (index = index - 1; index >= 0; --index)
mapobjectmodel.cpp:                if ((prev = mMap->layerAt(index)->asObjectGroup()))
mapobjectmodel.cpp:            foreach (MapObject *o, og->objects()) {
mapobjectmodel.cpp:    Layer *layer = mMap->layerAt(index);
mapobjectmodel.cpp:    if (ObjectGroup *og = layer->asObjectGroup()) {
mapobjectmodel.cpp:        QModelIndex index = this->index(og);
mapobjectmodel.cpp:    Layer *layer = mMap->layerAt(index);
mapobjectmodel.cpp:    if (ObjectGroup *og = layer->asObjectGroup()) {
mapobjectmodel.cpp:        foreach (MapObject *o, og->objects())
mapobjectmodel.cpp:    const int row = (index >= 0) ? index : og->objectCount();
mapobjectmodel.cpp:    beginInsertRows(this->index(og), row, row);
mapobjectmodel.cpp:    og->insertObject(row, o);
mapobjectmodel.cpp:    const int row = og->objects().indexOf(o);
mapobjectmodel.cpp:    og->removeObjectAt(row);
mapobjectmodel.cpp:    if (!beginMoveRows(parent, from, from + count - 1, parent, to)) {
mapobjectmodel.cpp:    og->moveObjects(from, to, count);
mapobjectmodel.cpp:    if (o->name() == name)
mapobjectmodel.cpp:    o->setName(name);
mapobjectmodel.cpp:    QModelIndex index = this->index(o);
mapobjectmodel.cpp:    if (o->type() == type)
mapobjectmodel.cpp:    o->setType(type);
mapobjectmodel.cpp:    QModelIndex index = this->index(o, 1);
mapobjectmodel.cpp:    if (o->polygon() == polygon)
mapobjectmodel.cpp:    o->setPolygon(polygon);
mapobjectmodel.cpp:    if (o->position() == pos)
mapobjectmodel.cpp:    o->setPosition(pos);
mapobjectmodel.cpp:    if (o->size() == size)
mapobjectmodel.cpp:    o->setSize(size);
mapobjectmodel.cpp:    if (o->rotation() == rotation)
mapobjectmodel.cpp:    o->setRotation(rotation);
mapobjectmodel.cpp:    if (o->isVisible() == visible)
mapobjectmodel.cpp:    o->setVisible(visible);
mapobjectmodel.cpp:    QModelIndex index = this->index(o);
Binary file eraser.o matches
Binary file moc_mapdocumentactionhandler.o matches
magicwandtool.cpp: * Copyright 2009-2010, Jeff Bland <jksb@member.fsf.org>
magicwandtool.cpp:                               ":images/22x22/stock-tool-fuzzy-select-22.png")),
magicwandtool.cpp:    brushItem()->setTileRegion(mSelectedRegion);
magicwandtool.cpp:    if (event->button() != Qt::LeftButton)
magicwandtool.cpp:    const Qt::KeyboardModifiers modifiers = event->modifiers();
magicwandtool.cpp:    QRegion selection = document->selectedArea();
magicwandtool.cpp:        selection -= mSelectedRegion;
magicwandtool.cpp:    if (selection != document->selectedArea()) {
magicwandtool.cpp:        document->undoStack()->push(cmd);
moc_objectselectionitem.cpp:        - idx * sizeof(QByteArrayData) \
moc_objectselectionitem.cpp:        case 0: _t->selectedObjectsChanged(); break;
moc_objectselectionitem.cpp:        case 1: _t->mapChanged(); break;
moc_objectselectionitem.cpp:        case 2: _t->layerChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_objectselectionitem.cpp:        case 3: _t->syncOverlayItems((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_objectselectionitem.cpp:        case 4: _t->objectLabelVisibilityChanged(); break;
moc_objectselectionitem.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_objectselectionitem.cpp:        _id -= 5;
moc_objectselectionitem.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_objectselectionitem.cpp:        _id -= 5;
Binary file tiledapplication.o matches
Binary file mainwindow.o matches
Binary file objectselectiontool.o matches
renameterrain.h: * Copyright 2012-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
moc_layermodel.cpp:        - idx * sizeof(QByteArrayData) \
moc_layermodel.cpp:        case 0: _t->layerAdded((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_layermodel.cpp:        case 1: _t->layerAboutToBeRemoved((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_layermodel.cpp:        case 2: _t->layerRemoved((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_layermodel.cpp:        case 3: _t->layerAboutToBeRenamed((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_layermodel.cpp:        case 4: _t->layerRenamed((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_layermodel.cpp:        case 5: _t->layerChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_layermodel.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_layermodel.cpp:        _id -= 6;
moc_layermodel.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_layermodel.cpp:        _id -= 6;
Binary file zoomable.o matches
tilesetchanges.h: * Copyright 2011-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
moc_mapsdock.cpp:        - idx * sizeof(QByteArrayData) \
moc_mapsdock.cpp:        case 0: _t->browse(); break;
moc_mapsdock.cpp:        case 1: _t->editedMapsDirectory(); break;
moc_mapsdock.cpp:        case 2: _t->onMapsDirectoryChanged(); break;
moc_mapsdock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_mapsdock.cpp:        _id -= 3;
moc_mapsdock.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_mapsdock.cpp:        _id -= 3;
moc_mapsdock.cpp:        - idx * sizeof(QByteArrayData) \
moc_mapsdock.cpp:        case 0: _t->onMapsDirectoryChanged(); break;
moc_mapsdock.cpp:        case 1: _t->onActivated((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_mapsdock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_mapsdock.cpp:        _id -= 2;
moc_mapsdock.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_mapsdock.cpp:        _id -= 2;
thumbnailrenderer.h: * Copyright 2011-2015, Thorbj√∏rn Lindeijer <bjorn@lindeijer.nl>
Binary file moc_automappingmanager.o matches
moc_exportasimagedialog.cpp:        - idx * sizeof(QByteArrayData) \
moc_exportasimagedialog.cpp:        case 0: _t->browse(); break;
moc_exportasimagedialog.cpp:        case 1: _t->updateAcceptEnabled(); break;
moc_exportasimagedialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_exportasimagedialog.cpp:        _id -= 2;
moc_exportasimagedialog.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_exportasimagedialog.cpp:        _id -= 2;
Binary file geometry.o matches
Binary file qtvariantproperty.o matches
moc_offsetmapdialog.cpp:        - idx * sizeof(QByteArrayData) \
moc_offsetmapdialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
Binary file movabletabwidget.o matches
Binary file createscalableobjecttool.o matches
Binary file moc_newtilesetdialog.o matches
Binary file qtgroupboxpropertybrowser.o matches
moc_selectsametiletool.cpp:        - idx * sizeof(QByteArrayData) \
moc_selectsametiletool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
movemapobject.cpp:    , mNewPos(mapObject->position())
movemapobject.cpp:    mMapDocument->mapObjectModel()->setObjectPosition(mMapObject, mOldPos);
movemapobject.cpp:    mMapDocument->mapObjectModel()->setObjectPosition(mMapObject, mNewPos);
Binary file languagemanager.o matches
addremovetiles.cpp:    mTileset->insertTiles(mIndex, mTiles);
addremovetiles.cpp:    mMapDocument->emitTilesetChanged(mTileset);
addremovetiles.cpp:    mTiles = mTileset->tiles().mid(mIndex, mCount);
addremovetiles.cpp:    mTileset->removeTiles(mIndex, mCount);
addremovetiles.cpp:    mMapDocument->emitTilesetChanged(mTileset);
addremovetiles.cpp:                     tileset->tileCount(),
tilesetview.h: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tilesetview.h:     * The id of the terrain currently being specified. Set to -1 for erasing
tilesetview.h:     * Sets the id of the terrain to specify on the tiles. An id of -1 allows
resizedialog.cpp: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
resizedialog.cpp:    mUi->setupUi(this);
resizedialog.cpp:    mUi->resizeHelper->setNewSize(QSize(mUi->widthSpinBox->value(),
resizedialog.cpp:                                        mUi->heightSpinBox->value()));
resizedialog.cpp:    connect(mUi->resizeHelper, SIGNAL(offsetBoundsChanged(QRect)),
resizedialog.cpp:    mUi->resizeHelper->setOldSize(size);
resizedialog.cpp:    mUi->widthSpinBox->setValue(size.width());
resizedialog.cpp:    mUi->heightSpinBox->setValue(size.height());
resizedialog.cpp:    return mUi->resizeHelper->newSize();
resizedialog.cpp:    return mUi->resizeHelper->offset();
resizedialog.cpp:    mUi->offsetXSpinBox->setRange(bounds.left(), bounds.right());
resizedialog.cpp:    mUi->offsetYSpinBox->setRange(bounds.top(), bounds.bottom());
moc_qtvariantproperty.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtvariantproperty.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QVariant(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 1: _t->attributeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2])),(*reinterpret_cast< const QVariant(*)>(_a[3]))); break;
moc_qtvariantproperty.cpp:        case 2: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QVariant(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 3: _t->setAttribute((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2])),(*reinterpret_cast< const QVariant(*)>(_a[3]))); break;
moc_qtvariantproperty.cpp:        case 4: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 5: _t->d_func()->slotRangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_qtvariantproperty.cpp:        case 6: _t->d_func()->slotSingleStepChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 7: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 8: _t->d_func()->slotRangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2])),(*reinterpret_cast< double(*)>(_a[3]))); break;
moc_qtvariantproperty.cpp:        case 9: _t->d_func()->slotSingleStepChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 10: _t->d_func()->slotDecimalsChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 11: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 12: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 13: _t->d_func()->slotRegExpChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRegExp(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 14: _t->d_func()->slotEchoModeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 15: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDate(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 16: _t->d_func()->slotRangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDate(*)>(_a[2])),(*reinterpret_cast< const QDate(*)>(_a[3]))); break;
moc_qtvariantproperty.cpp:        case 17: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QTime(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 18: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDateTime(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 19: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QKeySequence(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 20: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QChar(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 21: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QLocale(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 22: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QPoint(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 23: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QPointF(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 24: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSize(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 25: _t->d_func()->slotRangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSize(*)>(_a[2])),(*reinterpret_cast< const QSize(*)>(_a[3]))); break;
moc_qtvariantproperty.cpp:        case 26: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSizeF(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 27: _t->d_func()->slotRangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSizeF(*)>(_a[2])),(*reinterpret_cast< const QSizeF(*)>(_a[3]))); break;
moc_qtvariantproperty.cpp:        case 28: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRect(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 29: _t->d_func()->slotConstraintChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRect(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 30: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRectF(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 31: _t->d_func()->slotConstraintChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRectF(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 32: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QColor(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 33: _t->d_func()->slotEnumNamesChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QStringList(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 34: _t->d_func()->slotEnumIconsChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QMap<int,QIcon>(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 35: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSizePolicy(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 36: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QFont(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 37: _t->d_func()->slotValueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QCursor(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 38: _t->d_func()->slotFlagNamesChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QStringList(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 39: _t->d_func()->slotReadOnlyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 40: _t->d_func()->slotTextVisibleChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:        case 41: _t->d_func()->slotPropertyInserted((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< QtProperty*(*)>(_a[2])),(*reinterpret_cast< QtProperty*(*)>(_a[3]))); break;
moc_qtvariantproperty.cpp:        case 42: _t->d_func()->slotPropertyRemoved((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< QtProperty*(*)>(_a[2]))); break;
moc_qtvariantproperty.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtvariantproperty.cpp:        _id -= 43;
moc_qtvariantproperty.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtvariantproperty.cpp:        _id -= 43;
moc_qtvariantproperty.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtvariantproperty.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
Binary file layermodel.o matches
Binary file moc_movabletabwidget.o matches
tilesetdock.h: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
propertybrowser.cpp:        mMapDocument->disconnect(this);
propertybrowser.cpp:        mMapDocument->terrainModel()->disconnect(this);
propertybrowser.cpp:        TerrainModel *terrainModel = mapDocument->terrainModel();
propertybrowser.cpp:    return item && mPropertyToId[item->property()] == CustomProperty;
propertybrowser.cpp:    if (event->type() == QEvent::LanguageChange)
propertybrowser.cpp:    if (mObject == mMapDocument->map())
propertybrowser.cpp:    if (mObject && mObject->typeId() == Object::MapObjectType)
propertybrowser.cpp:    if (mObject == mMapDocument->map()->layerAt(index))
propertybrowser.cpp:    if (mObject == tileset->terrain(index))
propertybrowser.cpp:    if (!mMapDocument->currentObjects().contains(object))
propertybrowser.cpp:            mNameToProperty[name]->setValue(mObject->property(name));
propertybrowser.cpp:        const int index = mObject->properties().keys().indexOf(name);
propertybrowser.cpp:        const QList<QtProperty *> properties = mCustomPropertiesGroup->subProperties();
propertybrowser.cpp:        QtProperty *precedingProperty = (index > 0) ? properties.at(index - 1) : 0;
propertybrowser.cpp:        QtVariantProperty *property = mVariantManager->addProperty(QVariant::String, name);
propertybrowser.cpp:        property->setValue(mObject->property(name));
propertybrowser.cpp:        mCustomPropertiesGroup->insertSubProperty(property, precedingProperty);
propertybrowser.cpp:    if (!mMapDocument->currentObjects().contains(object))
propertybrowser.cpp:        for (Object *obj : mMapDocument->currentObjects()) {
propertybrowser.cpp:            if (obj->properties().contains(name)) {
propertybrowser.cpp:                mNameToProperty[name]->setValue(tr(""));
propertybrowser.cpp:        mNameToProperty[name]->setValue(object->property(name));
propertybrowser.cpp:    if (mMapDocument->currentObjects().contains(object))
propertybrowser.cpp:    if (mMapDocument->currentObjects().contains(object))
propertybrowser.cpp:        QUndoStack *undoStack = mMapDocument->undoStack();
propertybrowser.cpp:        undoStack->push(new SetProperty(mMapDocument,
propertybrowser.cpp:                                        mMapDocument->currentObjects(),
propertybrowser.cpp:                                        property->propertyName(),
propertybrowser.cpp:    switch (mObject->typeId()) {
propertybrowser.cpp:    QtProperty *groupProperty = mGroupManager->addProperty(tr("Map"));
propertybrowser.cpp:    orientationProperty->setAttribute(QLatin1String("enumNames"), mOrientationNames);
propertybrowser.cpp:    createProperty(WidthProperty, QVariant::Int, tr("Width"), groupProperty)->setEnabled(false);
propertybrowser.cpp:    createProperty(HeightProperty, QVariant::Int, tr("Height"), groupProperty)->setEnabled(false);
propertybrowser.cpp:    staggerAxisProperty->setAttribute(QLatin1String("enumNames"), mStaggerAxisNames);
propertybrowser.cpp:    staggerIndexProperty->setAttribute(QLatin1String("enumNames"), mStaggerIndexNames);
propertybrowser.cpp:    layerFormatProperty->setAttribute(QLatin1String("enumNames"), mLayerFormatNames);
propertybrowser.cpp:    renderOrderProperty->setAttribute(QLatin1String("enumNames"), mRenderOrderNames);
propertybrowser.cpp:    for (const ObjectType &type : Preferences::instance()->objectTypes())
propertybrowser.cpp:    QtProperty *groupProperty = mGroupManager->addProperty(tr("Object"));
propertybrowser.cpp:    createProperty(IdProperty, QVariant::Int, tr("ID"), groupProperty)->setEnabled(false);
propertybrowser.cpp:    typeProperty->setAttribute(QLatin1String("suggestions"), objectTypeNames());
propertybrowser.cpp:    if (!static_cast<const MapObject*>(mObject)->cell().isEmpty()) {
propertybrowser.cpp:        flippingProperty->setAttribute(QLatin1String("flagNames"), mFlippingFlagNames);
propertybrowser.cpp:    opacityProperty->setAttribute(QLatin1String("minimum"), 0.0);
propertybrowser.cpp:    opacityProperty->setAttribute(QLatin1String("maximum"), 1.0);
propertybrowser.cpp:    opacityProperty->setAttribute(QLatin1String("singleStep"), 0.1);
propertybrowser.cpp:    QtProperty *groupProperty = mGroupManager->addProperty(tr("Tile Layer"));
propertybrowser.cpp:    QtProperty *groupProperty = mGroupManager->addProperty(tr("Object Layer"));
propertybrowser.cpp:    drawOrderProperty->setAttribute(QLatin1String("enumNames"), mDrawOrderNames);
propertybrowser.cpp:    QtProperty *groupProperty = mGroupManager->addProperty(tr("Image Layer"));
propertybrowser.cpp:    imageSourceProperty->setAttribute(QLatin1String("filter"),
propertybrowser.cpp:    QtProperty *groupProperty = mGroupManager->addProperty(tr("Tileset"));
propertybrowser.cpp:    if (!currentTileset->imageSource().isEmpty()) {
propertybrowser.cpp:        // Make these properties read-only
propertybrowser.cpp:        srcImgProperty->setEnabled(false);
propertybrowser.cpp:        tileWidthProperty->setEnabled(false);
propertybrowser.cpp:        tileHeightProperty->setEnabled(false);
propertybrowser.cpp:        marginProperty->setEnabled(false);
propertybrowser.cpp:        spacingProperty->setEnabled(false);
propertybrowser.cpp:    QtProperty *groupProperty = mGroupManager->addProperty(tr("Tile"));
propertybrowser.cpp:    createProperty(IdProperty, QVariant::Int, tr("ID"), groupProperty)->setEnabled(false);
propertybrowser.cpp:    probabilityProperty->setAttribute(QLatin1String("decimals"), 3);
propertybrowser.cpp:    probabilityProperty->setToolTip(tr("Relative chance this tile will be picked"));
propertybrowser.cpp:    QtProperty *groupProperty = mGroupManager->addProperty(tr("Terrain"));
propertybrowser.cpp:        mMapDocument->undoStack()->push(command);
propertybrowser.cpp:                                      mIdToProperty[NameProperty]->value().toString(),
propertybrowser.cpp:                                      mIdToProperty[TypeProperty]->value().toString());
propertybrowser.cpp:        const QPointF oldPos = mapObject->position();
propertybrowser.cpp:        const QPointF oldPos = mapObject->position();
propertybrowser.cpp:        const QSizeF oldSize = mapObject->size();
propertybrowser.cpp:        const QSizeF oldSize = mapObject->size();
propertybrowser.cpp:        const qreal oldRotation = mapObject->rotation();
propertybrowser.cpp:        if (mapObject->cell().flippedHorizontally != flippedHorizontally) {
propertybrowser.cpp:        } else if (mapObject->cell().flippedVertically != flippedVertically) {
propertybrowser.cpp:    mMapDocument->undoStack()->beginMacro(command->text());
propertybrowser.cpp:    mMapDocument->undoStack()->push(command);
propertybrowser.cpp:    //Used to share non-custom properties.
propertybrowser.cpp:    QList<MapObject*> selectedObjects = mMapDocument->selectedObjects();
propertybrowser.cpp:                    mMapDocument->undoStack()->push(cmd);
propertybrowser.cpp:    mMapDocument->undoStack()->endMacro();
propertybrowser.cpp:    const int layerIndex = mMapDocument->map()->layers().indexOf(layer);
propertybrowser.cpp:        QPointF offset = layer->offset();
propertybrowser.cpp:        switch (layer->layerType()) {
propertybrowser.cpp:        mMapDocument->undoStack()->push(command);
propertybrowser.cpp:                                                  objectGroup->drawOrder());
propertybrowser.cpp:                                                  objectGroup->color(),
propertybrowser.cpp:        mMapDocument->undoStack()->push(command);
propertybrowser.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
propertybrowser.cpp:        const QColor &color = imageLayer->transparentColor();
propertybrowser.cpp:        undoStack->push(new ChangeImageLayerProperties(mMapDocument,
propertybrowser.cpp:        const QString &imageSource = imageLayer->imageSource();
propertybrowser.cpp:        undoStack->push(new ChangeImageLayerProperties(mMapDocument,
propertybrowser.cpp:        QPoint pos(val.toReal(), imageLayer->y());
propertybrowser.cpp:        undoStack->push(new ChangeImageLayerPosition(mMapDocument,
propertybrowser.cpp:        QPoint pos(imageLayer->x(), val.toReal());
propertybrowser.cpp:        undoStack->push(new ChangeImageLayerPosition(mMapDocument,
propertybrowser.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
propertybrowser.cpp:        undoStack->push(new RenameTileset(mMapDocument,
propertybrowser.cpp:        undoStack->push(new ChangeTilesetTileOffset(mMapDocument,
propertybrowser.cpp:        QUndoStack *undoStack = mMapDocument->undoStack();
propertybrowser.cpp:        undoStack->push(new ChangeTileProbability(mMapDocument,
propertybrowser.cpp:        QUndoStack *undoStack = mMapDocument->undoStack();
propertybrowser.cpp:        undoStack->push(new RenameTerrain(mMapDocument,
propertybrowser.cpp:                                          terrain->tileset(),
propertybrowser.cpp:                                          terrain->id(),
propertybrowser.cpp:    QtVariantProperty *property = mVariantManager->addProperty(type, name);
propertybrowser.cpp:        property->setAttribute(QLatin1String("textVisible"), false);
propertybrowser.cpp:    parent->addSubProperty(property);
propertybrowser.cpp:    // Add the built-in properties for each object type
propertybrowser.cpp:    switch (mObject->typeId()) {
propertybrowser.cpp:        switch (static_cast<Layer*>(mObject)->layerType()) {
propertybrowser.cpp:    mCustomPropertiesGroup = mGroupManager->addProperty(tr("Custom Properties"));
propertybrowser.cpp:    mVariantManager->clear();
propertybrowser.cpp:    mGroupManager->clear();
propertybrowser.cpp:    switch (mObject->typeId()) {
propertybrowser.cpp:        mIdToProperty[WidthProperty]->setValue(map->width());
propertybrowser.cpp:        mIdToProperty[HeightProperty]->setValue(map->height());
propertybrowser.cpp:        mIdToProperty[TileWidthProperty]->setValue(map->tileWidth());
propertybrowser.cpp:        mIdToProperty[TileHeightProperty]->setValue(map->tileHeight());
propertybrowser.cpp:        mIdToProperty[OrientationProperty]->setValue(map->orientation() - 1);
propertybrowser.cpp:        mIdToProperty[HexSideLengthProperty]->setValue(map->hexSideLength());
propertybrowser.cpp:        mIdToProperty[StaggerAxisProperty]->setValue(map->staggerAxis());
propertybrowser.cpp:        mIdToProperty[StaggerIndexProperty]->setValue(map->staggerIndex());
propertybrowser.cpp:        mIdToProperty[LayerFormatProperty]->setValue(map->layerDataFormat());
propertybrowser.cpp:        mIdToProperty[RenderOrderProperty]->setValue(map->renderOrder());
propertybrowser.cpp:        QColor backgroundColor = map->backgroundColor();
propertybrowser.cpp:        mIdToProperty[ColorProperty]->setValue(backgroundColor);
propertybrowser.cpp:        mIdToProperty[IdProperty]->setValue(mapObject->id());
propertybrowser.cpp:        mIdToProperty[NameProperty]->setValue(mapObject->name());
propertybrowser.cpp:        mIdToProperty[TypeProperty]->setValue(mapObject->type());
propertybrowser.cpp:        mIdToProperty[VisibleProperty]->setValue(mapObject->isVisible());
propertybrowser.cpp:        mIdToProperty[XProperty]->setValue(mapObject->x());
propertybrowser.cpp:        mIdToProperty[YProperty]->setValue(mapObject->y());
propertybrowser.cpp:        mIdToProperty[WidthProperty]->setValue(mapObject->width());
propertybrowser.cpp:        mIdToProperty[HeightProperty]->setValue(mapObject->height());
propertybrowser.cpp:        mIdToProperty[RotationProperty]->setValue(mapObject->rotation());
propertybrowser.cpp:            if (mapObject->cell().flippedHorizontally)
propertybrowser.cpp:            if (mapObject->cell().flippedVertically)
propertybrowser.cpp:            property->setValue(flippingFlags);
propertybrowser.cpp:        mIdToProperty[NameProperty]->setValue(layer->name());
propertybrowser.cpp:        mIdToProperty[VisibleProperty]->setValue(layer->isVisible());
propertybrowser.cpp:        mIdToProperty[OpacityProperty]->setValue(layer->opacity());
propertybrowser.cpp:        mIdToProperty[OffsetXProperty]->setValue(layer->offset().x());
propertybrowser.cpp:        mIdToProperty[OffsetYProperty]->setValue(layer->offset().y());
propertybrowser.cpp:        switch (layer->layerType()) {
propertybrowser.cpp:            QColor color = objectGroup->color();
propertybrowser.cpp:            mIdToProperty[ColorProperty]->setValue(color);
propertybrowser.cpp:            mIdToProperty[DrawOrderProperty]->setValue(objectGroup->drawOrder());
propertybrowser.cpp:            mIdToProperty[ImageSourceProperty]->setValue(imageLayer->imageSource());
propertybrowser.cpp:            mIdToProperty[ColorProperty]->setValue(imageLayer->transparentColor());
propertybrowser.cpp:            mIdToProperty[XProperty]->setValue(imageLayer->x());
propertybrowser.cpp:            mIdToProperty[YProperty]->setValue(imageLayer->y());
propertybrowser.cpp:        mIdToProperty[NameProperty]->setValue(tileset->name());
propertybrowser.cpp:        mIdToProperty[TileOffsetProperty]->setValue(tileset->tileOffset());
propertybrowser.cpp:        if (!tileset->imageSource().isEmpty()) {
propertybrowser.cpp:            mIdToProperty[SourceImageProperty]->setValue(tileset->imageSource());
propertybrowser.cpp:            mIdToProperty[TileWidthProperty]->setValue(tileset->tileWidth());
propertybrowser.cpp:            mIdToProperty[TileHeightProperty]->setValue(tileset->tileHeight());
propertybrowser.cpp:            mIdToProperty[MarginProperty]->setValue(tileset->margin());
propertybrowser.cpp:            mIdToProperty[SpacingProperty]->setValue(tileset->tileSpacing());
propertybrowser.cpp:        mIdToProperty[IdProperty]->setValue(tile->id());
propertybrowser.cpp:        mIdToProperty[TileProbabilityProperty]->setValue(tile->probability());
propertybrowser.cpp:        mIdToProperty[NameProperty]->setValue(terrain->name());
propertybrowser.cpp:    mCombinedProperties = mObject->properties();
propertybrowser.cpp:    for (Object *obj : mMapDocument->currentObjects()) {
propertybrowser.cpp:        QMapIterator<QString,QString> it(obj->properties());
propertybrowser.cpp:        property->setValue(it.value());
propertybrowser.cpp:    QString propertyName = property->propertyName();
propertybrowser.cpp:    QString propertyValue = property->valueText();
propertybrowser.cpp:    for (Object *obj : mMapDocument->currentObjects()) {
propertybrowser.cpp:        if (!obj->hasProperty(propertyName)) {
propertybrowser.cpp:            property->setNameColor(Qt::gray);
propertybrowser.cpp:            property->setValueColor(Qt::gray);
propertybrowser.cpp:    for (Object *obj : mMapDocument->currentObjects()) {
propertybrowser.cpp:        if (obj->property(propertyName) != propertyValue) {
propertybrowser.cpp:            property->setValueColor(Qt::gray);
propertybrowser.cpp:    property->setNameColor(Qt::black);
propertybrowser.cpp:    property->setValueColor(Qt::black);
filesystemwatcher.cpp:        mWatcher->addPath(path);
filesystemwatcher.cpp:    --entry.value();
filesystemwatcher.cpp:        mWatcher->removePath(path);
filesystemwatcher.cpp:    // to be re-added to keep watching it for changes. This happens commonly
filesystemwatcher.cpp:    if (!mWatcher->files().contains(path))
filesystemwatcher.cpp:            mWatcher->addPath(path);
Binary file mapview.o matches
Binary file varianteditorfactory.o matches
Binary file moc_tilestampsdock.o matches
eraser.h: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file layerdock.o matches
moc_tilesetview.cpp:        - idx * sizeof(QByteArrayData) \
moc_tilesetview.cpp:        case 0: _t->createNewTerrain((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_tilesetview.cpp:        case 1: _t->terrainImageSelected((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_tilesetview.cpp:        case 2: _t->createNewTerrain(); break;
moc_tilesetview.cpp:        case 3: _t->selectTerrainImage(); break;
moc_tilesetview.cpp:        case 4: _t->editTileProperties(); break;
moc_tilesetview.cpp:        case 5: _t->setDrawGrid((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_tilesetview.cpp:        case 6: _t->adjustScale(); break;
moc_tilesetview.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tilesetview.cpp:        _id -= 7;
moc_tilesetview.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tilesetview.cpp:        _id -= 7;
clipboardmanager.cpp:    const QMimeData *mimeData = mClipboard->mimeData();
clipboardmanager.cpp:    const QByteArray data = mimeData->data(QLatin1String(TMX_MIMETYPE));
clipboardmanager.cpp:    mimeData->setData(QLatin1String(TMX_MIMETYPE), format.toByteArray(map));
clipboardmanager.cpp:    mClipboard->setMimeData(mimeData);
clipboardmanager.cpp:    const Layer *currentLayer = mapDocument->currentLayer();
clipboardmanager.cpp:    const Map *map = mapDocument->map();
clipboardmanager.cpp:    const QRegion &selectedArea = mapDocument->selectedArea();
clipboardmanager.cpp:    const QList<MapObject*> &selectedObjects = mapDocument->selectedObjects();
clipboardmanager.cpp:        copyLayer = tileLayer->copy(selectedArea.translated(-tileLayer->x(),
clipboardmanager.cpp:                                                             -tileLayer->y()));
clipboardmanager.cpp:            objectGroup->addObject(mapObject->clone());
clipboardmanager.cpp:    Map copyMap(map->orientation(),
clipboardmanager.cpp:                copyLayer->width(), copyLayer->height(),
clipboardmanager.cpp:                map->tileWidth(), map->tileHeight());
clipboardmanager.cpp:    copyMap.setRenderOrder(map->renderOrder());
clipboardmanager.cpp:    foreach (const SharedTileset &tileset, copyLayer->usedTilesets())
clipboardmanager.cpp:    Layer *currentLayer = mapDocument->currentLayer();
clipboardmanager.cpp:    ObjectGroup *currentObjectGroup = currentLayer->asObjectGroup();
clipboardmanager.cpp:    const MapRenderer *renderer = mapDocument->renderer();
clipboardmanager.cpp:    const QPointF center = objectGroup->objectsBoundingRect().center();
clipboardmanager.cpp:    if (view->underMouse())
clipboardmanager.cpp:        viewPos = view->mapFromGlobal(QCursor::pos());
clipboardmanager.cpp:        viewPos = QPoint(view->width() / 2, view->height() / 2);
clipboardmanager.cpp:    const QPointF scenePos = view->mapToScene(viewPos);
clipboardmanager.cpp:    QPointF insertPos = renderer->screenToPixelCoords(scenePos) - center;
clipboardmanager.cpp:    QUndoStack *undoStack = mapDocument->undoStack();
clipboardmanager.cpp:    pastedObjects.reserve(objectGroup->objectCount());
clipboardmanager.cpp:    undoStack->beginMacro(tr("Paste Objects"));
clipboardmanager.cpp:    foreach (const MapObject *mapObject, objectGroup->objects()) {
clipboardmanager.cpp:        if (mode == NoTileObjects && !mapObject->cell().isEmpty())
clipboardmanager.cpp:        MapObject *objectClone = mapObject->clone();
clipboardmanager.cpp:        objectClone->setPosition(objectClone->position() + insertPos);
clipboardmanager.cpp:        undoStack->push(new AddMapObject(mapDocument,
clipboardmanager.cpp:    undoStack->endMacro();
clipboardmanager.cpp:    mapDocument->setSelectedObjects(pastedObjects);
clipboardmanager.cpp:    const QMimeData *data = mClipboard->mimeData();
clipboardmanager.cpp:            data && data->hasFormat(QLatin1String(TMX_MIMETYPE));
Binary file moc_fileedit.o matches
Binary file consoledock.o matches
newtilesetdialog.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
newtilesetdialog.cpp:    switch (ui->tilesetType->currentIndex()) {
newtilesetdialog.cpp:    mUi->setupUi(this);
newtilesetdialog.cpp:    QSettings *s = Preferences::instance()->settings();
newtilesetdialog.cpp:    int tilesetType = s->value(QLatin1String(TYPE_KEY)).toInt();
newtilesetdialog.cpp:    bool colorEnabled = s->value(QLatin1String(COLOR_ENABLED_KEY)).toBool();
newtilesetdialog.cpp:    QString colorName = s->value(QLatin1String(COLOR_KEY)).toString();
newtilesetdialog.cpp:    int spacing = s->value(QLatin1String(SPACING_KEY)).toInt();
newtilesetdialog.cpp:    int margin = s->value(QLatin1String(MARGIN_KEY)).toInt();
newtilesetdialog.cpp:    mUi->tilesetType->setCurrentIndex(tilesetType);
newtilesetdialog.cpp:    mUi->useTransparentColor->setChecked(colorEnabled);
newtilesetdialog.cpp:    mUi->colorButton->setColor(color);
newtilesetdialog.cpp:    mUi->spacing->setValue(spacing);
newtilesetdialog.cpp:    mUi->margin->setValue(margin);
newtilesetdialog.cpp:    connect(mUi->browseButton, SIGNAL(clicked()), SLOT(browse()));
newtilesetdialog.cpp:    connect(mUi->name, SIGNAL(textEdited(QString)), SLOT(nameEdited(QString)));
newtilesetdialog.cpp:    connect(mUi->name, SIGNAL(textChanged(QString)), SLOT(updateOkButton()));
newtilesetdialog.cpp:    connect(mUi->image, SIGNAL(textChanged(QString)), SLOT(updateOkButton()));
newtilesetdialog.cpp:    connect(mUi->tilesetType, SIGNAL(currentIndexChanged(int)),
newtilesetdialog.cpp:        mUi->image->setText(path);
newtilesetdialog.cpp:        mUi->name->setText(fileInfo.completeBaseName());
newtilesetdialog.cpp:    mUi->imageGroupBox->setVisible(tilesetType == 0);
newtilesetdialog.cpp:    mUi->tileWidth->setValue(width);
newtilesetdialog.cpp:    mUi->tileHeight->setValue(height);
newtilesetdialog.cpp:    QSettings *s = Preferences::instance()->settings();
newtilesetdialog.cpp:    const QString name = mUi->name->text();
newtilesetdialog.cpp:        const QString image = mUi->image->text();
newtilesetdialog.cpp:        const bool useTransparentColor = mUi->useTransparentColor->isChecked();
newtilesetdialog.cpp:        const QColor transparentColor = mUi->colorButton->color();
newtilesetdialog.cpp:        const int tileWidth = mUi->tileWidth->value();
newtilesetdialog.cpp:        const int tileHeight = mUi->tileHeight->value();
newtilesetdialog.cpp:        const int spacing = mUi->spacing->value();
newtilesetdialog.cpp:        const int margin = mUi->margin->value();
newtilesetdialog.cpp:            tileset->setTransparentColor(transparentColor);
newtilesetdialog.cpp:            if (!tileset->loadFromImage(image)) {
newtilesetdialog.cpp:            if (tileset->tileCount() == 0) {
newtilesetdialog.cpp:        s->setValue(QLatin1String(COLOR_ENABLED_KEY), useTransparentColor);
newtilesetdialog.cpp:        s->setValue(QLatin1String(COLOR_KEY), transparentColor.name());
newtilesetdialog.cpp:        s->setValue(QLatin1String(SPACING_KEY), spacing);
newtilesetdialog.cpp:        s->setValue(QLatin1String(MARGIN_KEY), margin);
newtilesetdialog.cpp:    s->setValue(QLatin1String(TYPE_KEY), mUi->tilesetType->currentIndex());
newtilesetdialog.cpp:        mUi->image->setText(f);
newtilesetdialog.cpp:            mUi->name->setText(QFileInfo(f).completeBaseName());
newtilesetdialog.cpp:    mUi->imageGroupBox->setVisible(index == 0);
newtilesetdialog.cpp:    QPushButton *okButton = mUi->buttonBox->button(QDialogButtonBox::Ok);
newtilesetdialog.cpp:    bool enabled = !mUi->name->text().isEmpty();
newtilesetdialog.cpp:        enabled &= !mUi->image->text().isEmpty();
newtilesetdialog.cpp:    okButton->setEnabled(enabled);
moc_newtilesetdialog.cpp:        - idx * sizeof(QByteArrayData) \
moc_newtilesetdialog.cpp:        case 0: _t->browse(); break;
moc_newtilesetdialog.cpp:        case 1: _t->nameEdited((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_newtilesetdialog.cpp:        case 2: _t->tilesetTypeChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_newtilesetdialog.cpp:        case 3: _t->updateOkButton(); break;
moc_newtilesetdialog.cpp:        case 4: _t->tryAccept(); break;
moc_newtilesetdialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_newtilesetdialog.cpp:        _id -= 5;
moc_newtilesetdialog.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_newtilesetdialog.cpp:        _id -= 5;
exportasimagedialog.h: * Copyright 2009-2015, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Info.plist:<?xml version="1.0" encoding="UTF-8"?>
Info.plist:<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
Info.plist:	<string>Tiled 0.14.0, Copyright 2008-2015 Thorbj√∏rn Lindeijer, GNU General Public License</string>
Info.plist:	<string>tiled-icon-mac</string>
Info.plist:	<string>Copyright 2008-2015 Thorbj√∏rn Lindeijer</string>
Info.plist:			<string>tmx-icon-mac</string>
Binary file moc_documentmanager.o matches
Binary file moc_tilestampmanager.o matches
moc_createellipseobjecttool.cpp:        - idx * sizeof(QByteArrayData) \
moc_createellipseobjecttool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
qttreepropertybrowser.moc:        - idx * sizeof(QByteArrayData) \
qttreepropertybrowser.moc:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
qttreepropertybrowser.moc:        - idx * sizeof(QByteArrayData) \
qttreepropertybrowser.moc:        case 0: _t->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
qttreepropertybrowser.moc:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
qttreepropertybrowser.moc:        _id -= 1;
qttreepropertybrowser.moc:            *reinterpret_cast<int*>(_a[0]) = -1;
qttreepropertybrowser.moc:        _id -= 1;
Binary file patreondialog.o matches
rangeset.h:        { return (*this)->first; }
rangeset.h:        { return (*this)->second; }
rangeset.h:        { return last() - first() + 1; }
rangeset.h:        // This is the only full-tree search of the map, everything else is
rangeset.h:            --it;
rangeset.h:            // assert: it->first < value
rangeset.h:            if (it->second >= value)
rangeset.h:            if (++it->second == value)
rangeset.h:            --it->second;
rangeset.h:        // assert: it->first >= value
rangeset.h:        if (it->first == value)
rangeset.h:        if (it->first == value + 1) {
rangeset.h:                --prev;
rangeset.h:                if (prev->second == value - 1) {
rangeset.h:                    prev->second = it->second;
rangeset.h:            mMap.insert(prev, std::make_pair(value, it->second));
rangeset.h:            --it;
rangeset.h:            if (it->second == value - 1) {
rangeset.h:                ++it->second;
addremovetileset.cpp:    TilesetManager::instance()->addReference(mTileset);
addremovetileset.cpp:    TilesetManager::instance()->removeReference(mTileset);
addremovetileset.cpp:    mMapDocument->removeTilesetAt(mIndex);
addremovetileset.cpp:    mMapDocument->insertTileset(mIndex, mTileset);
addremovetileset.cpp:                       mapDocument->map()->tilesets().size(),
addremovetileset.cpp:                       mapDocument->map()->tilesetAt(index))
moc_command.cpp:        - idx * sizeof(QByteArrayData) \
moc_command.cpp:        case 0: _t->handleError((*reinterpret_cast< QProcess::ProcessError(*)>(_a[1]))); break;
moc_command.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_command.cpp:        _id -= 1;
moc_command.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_command.cpp:        _id -= 1;
Binary file moc_bucketfilltool.o matches
Binary file tmxmapformat.o matches
selectsametiletool.cpp:                               ":images/22x22/stock-tool-by-color-select.png")),
selectsametiletool.cpp:    if (tileLayer->contains(tilePos)) {
selectsametiletool.cpp:        const Cell &matchCell = tileLayer->cellAt(tilePos);
selectsametiletool.cpp:        resultRegion = tileLayer->region([&] (const Cell &cell) { return cell == matchCell; });
selectsametiletool.cpp:    brushItem()->setTileRegion(mSelectedRegion);
selectsametiletool.cpp:    if (event->button() != Qt::LeftButton)
selectsametiletool.cpp:    const Qt::KeyboardModifiers modifiers = event->modifiers();
selectsametiletool.cpp:    QRegion selection = document->selectedArea();
selectsametiletool.cpp:        selection -= mSelectedRegion;
selectsametiletool.cpp:    if (selection != document->selectedArea()) {
selectsametiletool.cpp:        document->undoStack()->push(cmd);
mapdocumentactionhandler.cpp:    mActionSelectAll->setShortcuts(QKeySequence::SelectAll);
mapdocumentactionhandler.cpp:    mActionSelectNone->setShortcut(tr("Ctrl+Shift+A"));
mapdocumentactionhandler.cpp:    mActionDuplicateLayer->setShortcut(tr("Ctrl+Shift+D"));
mapdocumentactionhandler.cpp:    mActionDuplicateLayer->setIcon(
mapdocumentactionhandler.cpp:            QIcon(QLatin1String(":/images/16x16/stock-duplicate-16.png")));
mapdocumentactionhandler.cpp:    mActionRemoveLayer->setIcon(
mapdocumentactionhandler.cpp:            QIcon(QLatin1String(":/images/16x16/edit-delete.png")));
mapdocumentactionhandler.cpp:    mActionSelectPreviousLayer->setShortcut(tr("Ctrl+PgUp"));
mapdocumentactionhandler.cpp:    mActionSelectNextLayer->setShortcut(tr("Ctrl+PgDown"));
mapdocumentactionhandler.cpp:    mActionMoveLayerUp->setShortcut(tr("Ctrl+Shift+Up"));
mapdocumentactionhandler.cpp:    mActionMoveLayerUp->setIcon(
mapdocumentactionhandler.cpp:            QIcon(QLatin1String(":/images/16x16/go-up.png")));
mapdocumentactionhandler.cpp:    mActionMoveLayerDown->setShortcut(tr("Ctrl+Shift+Down"));
mapdocumentactionhandler.cpp:    mActionMoveLayerDown->setIcon(
mapdocumentactionhandler.cpp:            QIcon(QLatin1String(":/images/16x16/go-down.png")));
mapdocumentactionhandler.cpp:    mActionToggleOtherLayers->setShortcut(tr("Ctrl+Shift+H"));
mapdocumentactionhandler.cpp:    mActionToggleOtherLayers->setIcon(
mapdocumentactionhandler.cpp:    mActionLayerProperties->setIcon(
mapdocumentactionhandler.cpp:            QIcon(QLatin1String(":images/16x16/document-properties.png")));
mapdocumentactionhandler.cpp:    mActionDuplicateObjects->setIcon(QIcon(QLatin1String(":/images/16x16/stock-duplicate-16.png")));
mapdocumentactionhandler.cpp:    mActionRemoveObjects->setIcon(QIcon(QLatin1String(":/images/16x16/edit-delete.png")));
mapdocumentactionhandler.cpp:    Utils::setThemeIcon(mActionRemoveLayer, "edit-delete");
mapdocumentactionhandler.cpp:    Utils::setThemeIcon(mActionMoveLayerUp, "go-up");
mapdocumentactionhandler.cpp:    Utils::setThemeIcon(mActionMoveLayerDown, "go-down");
mapdocumentactionhandler.cpp:    Utils::setThemeIcon(mActionLayerProperties, "document-properties");
mapdocumentactionhandler.cpp:    Utils::setThemeIcon(mActionRemoveObjects, "edit-delete");
mapdocumentactionhandler.cpp:    mActionSelectAll->setText(tr("Select &All"));
mapdocumentactionhandler.cpp:    mActionSelectNone->setText(tr("Select &None"));
mapdocumentactionhandler.cpp:    mActionCropToSelection->setText(tr("&Crop to Selection"));
mapdocumentactionhandler.cpp:    mActionAddTileLayer->setText(tr("Add &Tile Layer"));
mapdocumentactionhandler.cpp:    mActionAddObjectGroup->setText(tr("Add &Object Layer"));
mapdocumentactionhandler.cpp:    mActionAddImageLayer->setText(tr("Add &Image Layer"));
mapdocumentactionhandler.cpp:    mActionDuplicateLayer->setText(tr("&Duplicate Layer"));
mapdocumentactionhandler.cpp:    mActionMergeLayerDown->setText(tr("&Merge Layer Down"));
mapdocumentactionhandler.cpp:    mActionRemoveLayer->setText(tr("&Remove Layer"));
mapdocumentactionhandler.cpp:    mActionSelectPreviousLayer->setText(tr("Select Pre&vious Layer"));
mapdocumentactionhandler.cpp:    mActionSelectNextLayer->setText(tr("Select &Next Layer"));
mapdocumentactionhandler.cpp:    mActionMoveLayerUp->setText(tr("R&aise Layer"));
mapdocumentactionhandler.cpp:    mActionMoveLayerDown->setText(tr("&Lower Layer"));
mapdocumentactionhandler.cpp:    mActionToggleOtherLayers->setText(tr("Show/&Hide all Other Layers"));
mapdocumentactionhandler.cpp:    mActionLayerProperties->setText(tr("Layer &Properties..."));
mapdocumentactionhandler.cpp:        mMapDocument->disconnect(this);
mapdocumentactionhandler.cpp:    Layer *layer = mMapDocument->currentLayer();
mapdocumentactionhandler.cpp:    if (TileLayer *tileLayer = layer->asTileLayer()) {
mapdocumentactionhandler.cpp:        QRect all(tileLayer->x(), tileLayer->y(),
mapdocumentactionhandler.cpp:                  tileLayer->width(), tileLayer->height());
mapdocumentactionhandler.cpp:        if (mMapDocument->selectedArea() == all)
mapdocumentactionhandler.cpp:        mMapDocument->undoStack()->push(command);
mapdocumentactionhandler.cpp:    } else if (ObjectGroup *objectGroup = layer->asObjectGroup()) {
mapdocumentactionhandler.cpp:        mMapDocument->setSelectedObjects(objectGroup->objects());
mapdocumentactionhandler.cpp:    if (mMapDocument->selectedArea().isEmpty())
mapdocumentactionhandler.cpp:    mMapDocument->undoStack()->push(command);
mapdocumentactionhandler.cpp:    const MapView *view = DocumentManager::instance()->currentMapView();
mapdocumentactionhandler.cpp:    const QPoint viewportPos = view->viewport()->mapFromGlobal(globalPos);
mapdocumentactionhandler.cpp:    const QPointF scenePos = view->mapToScene(viewportPos);
mapdocumentactionhandler.cpp:    const MapRenderer *renderer = mapDocument()->renderer();
mapdocumentactionhandler.cpp:    const QPointF tilePos = renderer->screenToTileCoords(scenePos);
mapdocumentactionhandler.cpp:    QApplication::clipboard()->setText(QString::number(x) +
mapdocumentactionhandler.cpp:    const QRect bounds = mMapDocument->selectedArea().boundingRect();
mapdocumentactionhandler.cpp:    mMapDocument->resizeMap(bounds.size(), -bounds.topLeft());
mapdocumentactionhandler.cpp:        mMapDocument->addLayer(Layer::TileLayerType);
mapdocumentactionhandler.cpp:        mMapDocument->addLayer(Layer::ObjectGroupType);
mapdocumentactionhandler.cpp:         mMapDocument->addLayer(Layer::ImageLayerType);
mapdocumentactionhandler.cpp:        mMapDocument->duplicateLayer();
mapdocumentactionhandler.cpp:        mMapDocument->mergeLayerDown();
mapdocumentactionhandler.cpp:        const int currentLayer = mMapDocument->currentLayerIndex();
mapdocumentactionhandler.cpp:        if (currentLayer < mMapDocument->map()->layerCount() - 1)
mapdocumentactionhandler.cpp:            mMapDocument->setCurrentLayerIndex(currentLayer + 1);
mapdocumentactionhandler.cpp:        const int currentLayer = mMapDocument->currentLayerIndex();
mapdocumentactionhandler.cpp:            mMapDocument->setCurrentLayerIndex(currentLayer - 1);
mapdocumentactionhandler.cpp:        mMapDocument->moveLayerUp(mMapDocument->currentLayerIndex());
mapdocumentactionhandler.cpp:        mMapDocument->moveLayerDown(mMapDocument->currentLayerIndex());
mapdocumentactionhandler.cpp:        mMapDocument->removeLayer(mMapDocument->currentLayerIndex());
mapdocumentactionhandler.cpp:        mMapDocument->toggleOtherLayers(mMapDocument->currentLayerIndex());
mapdocumentactionhandler.cpp:        mMapDocument->setCurrentObject(mMapDocument->currentLayer());
mapdocumentactionhandler.cpp:        mMapDocument->emitEditCurrentObject();
mapdocumentactionhandler.cpp:        mMapDocument->duplicateObjects(mMapDocument->selectedObjects());
mapdocumentactionhandler.cpp:        mMapDocument->removeObjects(mMapDocument->selectedObjects());
mapdocumentactionhandler.cpp:        mMapDocument->moveObjectsToGroup(mMapDocument->selectedObjects(),
mapdocumentactionhandler.cpp:    int currentLayerIndex = -1;
mapdocumentactionhandler.cpp:        map = mMapDocument->map();
mapdocumentactionhandler.cpp:        currentLayerIndex = mMapDocument->currentLayerIndex();
mapdocumentactionhandler.cpp:        selection = mMapDocument->selectedArea();
mapdocumentactionhandler.cpp:        selectedObjectsCount = mMapDocument->selectedObjects().count();
mapdocumentactionhandler.cpp:            Layer *upper = map->layerAt(currentLayerIndex);
mapdocumentactionhandler.cpp:            Layer *lower = map->layerAt(currentLayerIndex - 1);
mapdocumentactionhandler.cpp:            canMergeDown = lower->canMergeWith(upper);
mapdocumentactionhandler.cpp:    mActionSelectAll->setEnabled(map);
mapdocumentactionhandler.cpp:    mActionSelectNone->setEnabled(!selection.isEmpty());
mapdocumentactionhandler.cpp:    mActionCropToSelection->setEnabled(!selection.isEmpty());
mapdocumentactionhandler.cpp:    mActionAddTileLayer->setEnabled(map);
mapdocumentactionhandler.cpp:    mActionAddObjectGroup->setEnabled(map);
mapdocumentactionhandler.cpp:    mActionAddImageLayer->setEnabled(map);
mapdocumentactionhandler.cpp:    const int layerCount = map ? map->layerCount() : 0;
mapdocumentactionhandler.cpp:            && currentLayerIndex < layerCount - 1;
mapdocumentactionhandler.cpp:    mActionDuplicateLayer->setEnabled(currentLayerIndex >= 0);
mapdocumentactionhandler.cpp:    mActionMergeLayerDown->setEnabled(canMergeDown);
mapdocumentactionhandler.cpp:    mActionSelectPreviousLayer->setEnabled(hasPreviousLayer);
mapdocumentactionhandler.cpp:    mActionSelectNextLayer->setEnabled(hasNextLayer);
mapdocumentactionhandler.cpp:    mActionMoveLayerUp->setEnabled(hasPreviousLayer);
mapdocumentactionhandler.cpp:    mActionMoveLayerDown->setEnabled(hasNextLayer);
mapdocumentactionhandler.cpp:    mActionToggleOtherLayers->setEnabled(layerCount > 1);
mapdocumentactionhandler.cpp:    mActionRemoveLayer->setEnabled(currentLayerIndex >= 0);
mapdocumentactionhandler.cpp:    mActionLayerProperties->setEnabled(currentLayerIndex >= 0);
mapdocumentactionhandler.cpp:    mActionDuplicateObjects->setEnabled(selectedObjectsCount > 0);
mapdocumentactionhandler.cpp:    mActionRemoveObjects->setEnabled(selectedObjectsCount > 0);
mapdocumentactionhandler.cpp:    mActionDuplicateObjects->setText(duplicateText);
mapdocumentactionhandler.cpp:    mActionRemoveObjects->setText(removeText);
Binary file colorbutton.o matches
Binary file moc_imagemovementtool.o matches
newmapdialog.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
newmapdialog.cpp:    mUi->setupUi(this);
newmapdialog.cpp:    QSettings *s = prefs->settings();
newmapdialog.cpp:    const int orientation = s->value(QLatin1String(ORIENTATION_KEY)).toInt();
newmapdialog.cpp:    const int mapWidth = s->value(QLatin1String(MAP_WIDTH_KEY), 100).toInt();
newmapdialog.cpp:    const int mapHeight = s->value(QLatin1String(MAP_HEIGHT_KEY), 100).toInt();
newmapdialog.cpp:    const int tileWidth = s->value(QLatin1String(TILE_WIDTH_KEY), 32).toInt();
newmapdialog.cpp:    const int tileHeight = s->value(QLatin1String(TILE_HEIGHT_KEY),
newmapdialog.cpp:    mUi->layerFormat->addItem(QCoreApplication::translate("PreferencesDialog", "XML"));
newmapdialog.cpp:    mUi->layerFormat->addItem(QCoreApplication::translate("PreferencesDialog", "Base64 (uncompressed)"));
newmapdialog.cpp:    mUi->layerFormat->addItem(QCoreApplication::translate("PreferencesDialog", "Base64 (gzip compressed)"));
newmapdialog.cpp:    mUi->layerFormat->addItem(QCoreApplication::translate("PreferencesDialog", "Base64 (zlib compressed)"));
newmapdialog.cpp:    mUi->layerFormat->addItem(QCoreApplication::translate("PreferencesDialog", "CSV"));
newmapdialog.cpp:    mUi->renderOrder->addItem(QCoreApplication::translate("PreferencesDialog", "Right Down"));
newmapdialog.cpp:    mUi->renderOrder->addItem(QCoreApplication::translate("PreferencesDialog", "Right Up"));
newmapdialog.cpp:    mUi->renderOrder->addItem(QCoreApplication::translate("PreferencesDialog", "Left Down"));
newmapdialog.cpp:    mUi->renderOrder->addItem(QCoreApplication::translate("PreferencesDialog", "Left Up"));
newmapdialog.cpp:    mUi->orientation->addItem(tr("Orthogonal"), Map::Orthogonal);
newmapdialog.cpp:    mUi->orientation->addItem(tr("Isometric"), Map::Isometric);
newmapdialog.cpp:    mUi->orientation->addItem(tr("Isometric (Staggered)"), Map::Staggered);
newmapdialog.cpp:    mUi->orientation->addItem(tr("Hexagonal (Staggered)"), Map::Hexagonal);
newmapdialog.cpp:    mUi->orientation->setCurrentIndex(orientation);
newmapdialog.cpp:    mUi->layerFormat->setCurrentIndex(prefs->layerDataFormat());
newmapdialog.cpp:    mUi->renderOrder->setCurrentIndex(prefs->mapRenderOrder());
newmapdialog.cpp:    mUi->mapWidth->setValue(mapWidth);
newmapdialog.cpp:    mUi->mapHeight->setValue(mapHeight);
newmapdialog.cpp:    mUi->tileWidth->setValue(tileWidth);
newmapdialog.cpp:    mUi->tileHeight->setValue(tileHeight);
newmapdialog.cpp:    QFont font = mUi->pixelSizeLabel->font();
newmapdialog.cpp:    font.setPointSizeF(size - 1);
newmapdialog.cpp:    mUi->pixelSizeLabel->setFont(font);
newmapdialog.cpp:    connect(mUi->mapWidth, SIGNAL(valueChanged(int)), SLOT(refreshPixelSize()));
newmapdialog.cpp:    connect(mUi->mapHeight, SIGNAL(valueChanged(int)), SLOT(refreshPixelSize()));
newmapdialog.cpp:    connect(mUi->tileWidth, SIGNAL(valueChanged(int)), SLOT(refreshPixelSize()));
newmapdialog.cpp:    connect(mUi->tileHeight, SIGNAL(valueChanged(int)), SLOT(refreshPixelSize()));
newmapdialog.cpp:    connect(mUi->orientation, SIGNAL(currentIndexChanged(int)), SLOT(refreshPixelSize()));
newmapdialog.cpp:    const int mapWidth = mUi->mapWidth->value();
newmapdialog.cpp:    const int mapHeight = mUi->mapHeight->value();
newmapdialog.cpp:    const int tileWidth = mUi->tileWidth->value();
newmapdialog.cpp:    const int tileHeight = mUi->tileHeight->value();
newmapdialog.cpp:    const int orientationIndex = mUi->orientation->currentIndex();
newmapdialog.cpp:    const QVariant orientationData = mUi->orientation->itemData(orientationIndex);
newmapdialog.cpp:            static_cast<Map::LayerDataFormat>(mUi->layerFormat->currentIndex());
newmapdialog.cpp:            static_cast<Map::RenderOrder>(mUi->renderOrder->currentIndex());
newmapdialog.cpp:    map->setLayerDataFormat(layerFormat);
newmapdialog.cpp:    map->setRenderOrder(renderOrder);
newmapdialog.cpp:        map->addLayer(new TileLayer(tr("Tile Layer 1"), 0, 0,
newmapdialog.cpp:    prefs->setLayerDataFormat(layerFormat);
newmapdialog.cpp:    prefs->setMapRenderOrder(renderOrder);
newmapdialog.cpp:    QSettings *s = Preferences::instance()->settings();
newmapdialog.cpp:    s->setValue(QLatin1String(ORIENTATION_KEY), orientationIndex);
newmapdialog.cpp:    s->setValue(QLatin1String(MAP_WIDTH_KEY), mapWidth);
newmapdialog.cpp:    s->setValue(QLatin1String(MAP_HEIGHT_KEY), mapHeight);
newmapdialog.cpp:    s->setValue(QLatin1String(TILE_WIDTH_KEY), tileWidth);
newmapdialog.cpp:    s->setValue(QLatin1String(TILE_HEIGHT_KEY), tileHeight);
newmapdialog.cpp:    const int orientationIndex = mUi->orientation->currentIndex();
newmapdialog.cpp:    const QVariant orientationData = mUi->orientation->itemData(orientationIndex);
newmapdialog.cpp:                  mUi->mapWidth->value(),
newmapdialog.cpp:                  mUi->mapHeight->value(),
newmapdialog.cpp:                  mUi->tileWidth->value(),
newmapdialog.cpp:                  mUi->tileHeight->value());
newmapdialog.cpp:    mUi->pixelSizeLabel->setText(tr("%1 x %2 pixels")
changetileobjectgroup.cpp:    mObjectGroup = mTile->swapObjectGroup(mObjectGroup);
changetileobjectgroup.cpp:    mMapDocument->emitTileObjectGroupChanged(mTile);
moc_tilesetdock.cpp:        - idx * sizeof(QByteArrayData) \
moc_tilesetdock.cpp:        case 0: _t->currentTileChanged((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_tilesetdock.cpp:        case 1: _t->stampCaptured((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_tilesetdock.cpp:        case 2: _t->tilesetsDropped((*reinterpret_cast< const QStringList(*)>(_a[1]))); break;
moc_tilesetdock.cpp:        case 3: _t->newTileset(); break;
moc_tilesetdock.cpp:        case 4: _t->selectAllTiles(); break;
moc_tilesetdock.cpp:        case 5: _t->currentTilesetChanged(); break;
moc_tilesetdock.cpp:        case 6: _t->selectionChanged(); break;
moc_tilesetdock.cpp:        case 7: _t->currentChanged((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_tilesetdock.cpp:        case 8: _t->updateActions(); break;
moc_tilesetdock.cpp:        case 9: _t->updateCurrentTiles(); break;
moc_tilesetdock.cpp:        case 10: _t->indexPressed((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_tilesetdock.cpp:        case 11: _t->tilesetAdded((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< Tileset*(*)>(_a[2]))); break;
moc_tilesetdock.cpp:        case 12: _t->tilesetChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_tilesetdock.cpp:        case 13: _t->tilesetRemoved((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_tilesetdock.cpp:        case 14: _t->tilesetMoved((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_tilesetdock.cpp:        case 15: _t->tilesetNameChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_tilesetdock.cpp:        case 16: _t->tileAnimationChanged((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_tilesetdock.cpp:        case 17: _t->removeTileset(); break;
moc_tilesetdock.cpp:        case 18: _t->removeTileset((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_tilesetdock.cpp:        case 19: _t->moveTileset((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_tilesetdock.cpp:        case 20: _t->editTilesetProperties(); break;
moc_tilesetdock.cpp:        case 21: _t->importTileset(); break;
moc_tilesetdock.cpp:        case 22: _t->exportTileset(); break;
moc_tilesetdock.cpp:        case 23: _t->editTerrain(); break;
moc_tilesetdock.cpp:        case 24: _t->addTiles(); break;
moc_tilesetdock.cpp:        case 25: _t->removeTiles(); break;
moc_tilesetdock.cpp:        case 26: _t->documentAboutToClose((*reinterpret_cast< MapDocument*(*)>(_a[1]))); break;
moc_tilesetdock.cpp:        case 27: _t->refreshTilesetMenu(); break;
moc_tilesetdock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tilesetdock.cpp:        _id -= 28;
moc_tilesetdock.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tilesetdock.cpp:        _id -= 28;
tilesetview.cpp: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tilesetview.cpp:        painter->drawPie(rect.translated(-hx, -hy), -90 * 16, 90 * 16);
tilesetview.cpp:        painter->drawPie(rect.translated(hx, -hy), 180 * 16, 90 * 16);
tilesetview.cpp:        painter->drawRect(rect.x(), rect.y(), rect.width(), hy);
tilesetview.cpp:        painter->drawPie(rect.translated(-hx, hy), 0, 90 * 16);
tilesetview.cpp:        painter->drawRect(rect.x(), rect.y(), hx, rect.height());
tilesetview.cpp:        painter->drawPie(rect.translated(-hx, hy), 0, 90 * 16);
tilesetview.cpp:        painter->drawPie(rect.translated(hx, -hy), 180 * 16, 90 * 16);
tilesetview.cpp:        painter->drawPath(fill.subtracted(ellipse));
tilesetview.cpp:        painter->drawPie(rect.translated(hx, hy), 90 * 16, 90 * 16);
tilesetview.cpp:        painter->drawPie(rect.translated(-hx, -hy), -90 * 16, 90 * 16);
tilesetview.cpp:        painter->drawPie(rect.translated(hx, hy), 90 * 16, 90 * 16);
tilesetview.cpp:        painter->drawRect(rect.x() + hx, rect.y(), hx, rect.height());
tilesetview.cpp:        ellipse.addEllipse(rect.translated(-hx, hy));
tilesetview.cpp:        painter->drawPath(fill.subtracted(ellipse));
tilesetview.cpp:        painter->drawRect(rect.x(), rect.y() + hy, rect.width(), hy);
tilesetview.cpp:        ellipse.addEllipse(rect.translated(hx, -hy));
tilesetview.cpp:        painter->drawPath(fill.subtracted(ellipse));
tilesetview.cpp:        ellipse.addEllipse(rect.translated(-hx, -hy));
tilesetview.cpp:        painter->drawPath(fill.subtracted(ellipse));
tilesetview.cpp:        painter->drawRect(rect);
tilesetview.cpp:    painter->save();
tilesetview.cpp:    painter->setClipRect(rect);
tilesetview.cpp:    painter->setRenderHint(QPainter::Antialiasing);
tilesetview.cpp:    painter->setBrush(QColor(128, 128, 128, 100));
tilesetview.cpp:    painter->setPen(QPen(Qt::gray, 2));
tilesetview.cpp:    paintCorners(painter, invertCorners(terrainCorners(terrain, -1)), rect);
tilesetview.cpp:    if (terrainTypeId != -1) {
tilesetview.cpp:        painter->translate(1, 1);
tilesetview.cpp:        painter->setBrush(Qt::NoBrush);
tilesetview.cpp:        painter->setPen(QPen(Qt::black, 2));
tilesetview.cpp:        painter->translate(-1, -1);
tilesetview.cpp:        painter->setBrush(QColor(color.red(), color.green(), color.blue(), 100));
tilesetview.cpp:        painter->setPen(QPen(color, 2));
tilesetview.cpp:    painter->restore();
tilesetview.cpp:    const Tile *tile = model->tileAt(index);
tilesetview.cpp:    const QPixmap &tileImage = tile->image();
tilesetview.cpp:    const int extra = mTilesetView->drawGrid() ? 1 : 0;
tilesetview.cpp:    const qreal zoom = mTilesetView->scale();
tilesetview.cpp:    // Compute rectangle to draw the image in: bottom- and left-aligned
tilesetview.cpp:    QRect targetRect = option.rect.adjusted(0, 0, -extra, -extra);
tilesetview.cpp:    targetRect.setTop(targetRect.bottom() - tileSize.height() + 1);
tilesetview.cpp:    targetRect.setRight(targetRect.left() + tileSize.width() - 1);
tilesetview.cpp:    if (Zoomable *zoomable = mTilesetView->zoomable())
tilesetview.cpp:        if (zoomable->smoothTransform())
tilesetview.cpp:            painter->setRenderHint(QPainter::SmoothPixmapTransform);
tilesetview.cpp:    painter->drawPixmap(targetRect, tileImage);
tilesetview.cpp:    if (mTilesetView->markAnimatedTiles() && tile->isAnimated()) {
tilesetview.cpp:        painter->save();
tilesetview.cpp:        painter->setClipRect(targetRect);
tilesetview.cpp:        painter->translate(targetRect.right(),
tilesetview.cpp:        painter->scale(scale * zoom, scale * zoom);
tilesetview.cpp:        painter->translate(-18, 3);
tilesetview.cpp:        painter->rotate(-45);
tilesetview.cpp:        painter->setOpacity(0.8);
tilesetview.cpp:        painter->fillRect(strip, Qt::black);
tilesetview.cpp:        painter->setRenderHint(QPainter::Antialiasing);
tilesetview.cpp:        painter->setBrush(Qt::white);
tilesetview.cpp:        painter->setPen(Qt::NoPen);
tilesetview.cpp:        qreal step = (strip.height() - hole.height()) + hole.width();
tilesetview.cpp:        qreal margin = (strip.height() - hole.height()) / 2;
tilesetview.cpp:        for (qreal x = (step - hole.width()) / 2; x < strip.right(); x += step) {
tilesetview.cpp:            painter->drawRoundedRect(hole, 25, 25, Qt::RelativeSize);
tilesetview.cpp:        painter->restore();
tilesetview.cpp:        const qreal opacity = painter->opacity();
tilesetview.cpp:        painter->setOpacity(0.5);
tilesetview.cpp:        painter->fillRect(targetRect, option.palette.highlight());
tilesetview.cpp:        painter->setOpacity(opacity);
tilesetview.cpp:    if (mTilesetView->isEditTerrain()) {
tilesetview.cpp:        const unsigned terrain = tile->terrain();
tilesetview.cpp:                            mTilesetView->terrainId(), targetRect,
tilesetview.cpp:        if (index == mTilesetView->hoveredIndex()) {
tilesetview.cpp:            switch (mTilesetView->hoveredCorner()) {
tilesetview.cpp:            painter->save();
tilesetview.cpp:            painter->setBrush(option.palette.highlight());
tilesetview.cpp:            painter->setClipRect(targetRect);
tilesetview.cpp:            painter->setRenderHint(QPainter::Antialiasing);
tilesetview.cpp:            painter->setPen(pen);
tilesetview.cpp:            painter->drawEllipse(pos,
tilesetview.cpp:            painter->restore();
tilesetview.cpp:    const int extra = mTilesetView->drawGrid() ? 1 : 0;
tilesetview.cpp:    if (const Tile *tile = m->tileAt(index)) {
tilesetview.cpp:        const QSize tileSize = tile->size() * mTilesetView->scale();
tilesetview.cpp:    , mTerrainId(-1)
tilesetview.cpp:    hHeader->hide();
tilesetview.cpp:    vHeader->hide();
tilesetview.cpp:    hHeader->setSectionResizeMode(QHeaderView::ResizeToContents);
tilesetview.cpp:    vHeader->setSectionResizeMode(QHeaderView::ResizeToContents);
tilesetview.cpp:    hHeader->setMinimumSectionSize(1);
tilesetview.cpp:    vHeader->setMinimumSectionSize(1);
tilesetview.cpp:    mDrawGrid = prefs->showTilesetGrid();
tilesetview.cpp:        return -1;
tilesetview.cpp:    if (model->tileset()->imageSource().isEmpty())
tilesetview.cpp:    const int tileWidth = model->tileset()->tileWidth();
tilesetview.cpp:        return -1;
tilesetview.cpp:    if (model->tileset()->imageSource().isEmpty())
tilesetview.cpp:    const int tileHeight = model->tileset()->tileHeight();
tilesetview.cpp:        mZoomable->disconnect(this);
tilesetview.cpp:    return mZoomable ? mZoomable->scale() : 1;
tilesetview.cpp:    viewport()->update();
tilesetview.cpp:    if (mZoomable && event->type() == QEvent::Gesture) {
tilesetview.cpp:        if (QGesture *gesture = gestureEvent->gesture(Qt::PinchGesture))
tilesetview.cpp:            mZoomable->handlePinchGesture(static_cast<QPinchGesture *>(gesture));
tilesetview.cpp:    viewport()->update();
tilesetview.cpp:        viewport()->update();
tilesetview.cpp:    if (event->button() == Qt::LeftButton)
tilesetview.cpp:    const QPoint pos = event->pos();
tilesetview.cpp:    if (event->buttons() & Qt::LeftButton)
tilesetview.cpp:    if (event->button() == Qt::LeftButton)
tilesetview.cpp:            event->modifiers() & Qt::ControlModifier &&
tilesetview.cpp:            event->orientation() == Qt::Vertical)
tilesetview.cpp:        mZoomable->handleWheelDelta(event->delta());
tilesetview.cpp:    const QModelIndex index = indexAt(event->pos());
tilesetview.cpp:    Tile *tile = model->tileAt(index);
tilesetview.cpp:    const bool isExternal = model->tileset()->isExternal();
tilesetview.cpp:    QIcon propIcon(QLatin1String(":images/16x16/document-properties.png"));
tilesetview.cpp:            selectionModel()->setCurrentIndex(index,
tilesetview.cpp:            addTerrain->setEnabled(!isExternal);
tilesetview.cpp:            if (mTerrainId != -1) {
tilesetview.cpp:                setImage->setEnabled(!isExternal);
tilesetview.cpp:            tileProperties->setEnabled(!isExternal);
tilesetview.cpp:            Utils::setThemeIcon(tileProperties, "document-properties");
tilesetview.cpp:    toggleGrid->setCheckable(true);
tilesetview.cpp:    toggleGrid->setChecked(mDrawGrid);
tilesetview.cpp:    menu.exec(event->globalPos());
tilesetview.cpp:    mMapDocument->setCurrentObject(tile);
tilesetview.cpp:    mMapDocument->emitEditCurrentObject();
tilesetview.cpp:        model->tilesetChanged();
tilesetview.cpp:        model->tilesetChanged();
tilesetview.cpp:    Tile *tile = tilesetModel()->tileAt(mHoveredIndex);
tilesetview.cpp:    unsigned terrain = setTerrainCorner(tile->terrain(),
tilesetview.cpp:    if (terrain == tile->terrain())
tilesetview.cpp:    mMapDocument->undoStack()->push(command);
tilesetview.cpp:    mMapDocument->undoStack()->push(new ChangeTileTerrain);
tilesetview.cpp:    return model ? model->tileAt(currentIndex()) : 0;
changetileterrain.cpp:    , mTileset(tile->tileset())
changetileterrain.cpp:    mChanges.insert(tile, Change(tile->terrain(), terrain));
changetileterrain.cpp:    , mTileset(changes.begin().key()->tileset())
changetileterrain.cpp:        tile->setTerrain(change.from);
changetileterrain.cpp:    mMapDocument->emitTileTerrainChanged(changedTiles);
changetileterrain.cpp:        tile->setTerrain(change.to);
changetileterrain.cpp:    mMapDocument->emitTileTerrainChanged(changedTiles);
changetileterrain.cpp:    if (o->mMapDocument && !(mMapDocument == o->mMapDocument &&
changetileterrain.cpp:                             mTileset == o->mTileset))
changetileterrain.cpp:    Changes::const_iterator i = o->mChanges.constBegin();
changetileterrain.cpp:    Changes::const_iterator i_end = o->mChanges.constEnd();
changetileterrain.cpp:            tileChange->to = change.to;
changetileterrain.cpp:    mMergeable = o->mMergeable;
Binary file moc_tilesetdock.o matches
Binary file automappingmanager.o matches
moc_minimapdock.cpp:        - idx * sizeof(QByteArrayData) \
moc_minimapdock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
ui_commanddialog.h:        if (CommandDialog->objectName().isEmpty())
ui_commanddialog.h:            CommandDialog->setObjectName(QStringLiteral("CommandDialog"));
ui_commanddialog.h:        CommandDialog->resize(479, 258);
ui_commanddialog.h:        verticalLayout->setObjectName(QStringLiteral("verticalLayout"));
ui_commanddialog.h:        treeView->setObjectName(QStringLiteral("treeView"));
ui_commanddialog.h:        treeView->setDragDropMode(QAbstractItemView::DragDrop);
ui_commanddialog.h:        treeView->setAlternatingRowColors(true);
ui_commanddialog.h:        treeView->setSelectionMode(QAbstractItemView::ExtendedSelection);
ui_commanddialog.h:        treeView->setSelectionBehavior(QAbstractItemView::SelectRows);
ui_commanddialog.h:        verticalLayout->addWidget(treeView);
ui_commanddialog.h:        horizontalLayout->setObjectName(QStringLiteral("horizontalLayout"));
ui_commanddialog.h:        saveBox->setObjectName(QStringLiteral("saveBox"));
ui_commanddialog.h:        horizontalLayout->addWidget(saveBox);
ui_commanddialog.h:        buttonBox->setObjectName(QStringLiteral("buttonBox"));
ui_commanddialog.h:        buttonBox->setOrientation(Qt::Horizontal);
ui_commanddialog.h:        buttonBox->setStandardButtons(QDialogButtonBox::Cancel|QDialogButtonBox::Ok);
ui_commanddialog.h:        horizontalLayout->addWidget(buttonBox);
ui_commanddialog.h:        verticalLayout->addLayout(horizontalLayout);
ui_commanddialog.h:        CommandDialog->setWindowTitle(QApplication::translate("CommandDialog", "Properties", 0));
ui_commanddialog.h:        saveBox->setText(QApplication::translate("CommandDialog", "&Save map before executing", 0));
Binary file command.o matches
Binary file preferencesdialog.o matches
Binary file resizehelper.o matches
ui_tileanimationeditor.h:        if (TileAnimationEditor->objectName().isEmpty())
ui_tileanimationeditor.h:            TileAnimationEditor->setObjectName(QStringLiteral("TileAnimationEditor"));
ui_tileanimationeditor.h:        TileAnimationEditor->resize(669, 410);
ui_tileanimationeditor.h:        verticalLayout->setObjectName(QStringLiteral("verticalLayout"));
ui_tileanimationeditor.h:        horizontalLayout->setObjectName(QStringLiteral("horizontalLayout"));
ui_tileanimationeditor.h:        horizontalLayout->addItem(horizontalSpacer);
ui_tileanimationeditor.h:        zoomComboBox->setObjectName(QStringLiteral("zoomComboBox"));
ui_tileanimationeditor.h:        horizontalLayout->addWidget(zoomComboBox);
ui_tileanimationeditor.h:        verticalLayout->addLayout(horizontalLayout);
ui_tileanimationeditor.h:        horizontalSplitter->setObjectName(QStringLiteral("horizontalSplitter"));
ui_tileanimationeditor.h:        horizontalSplitter->setOrientation(Qt::Horizontal);
ui_tileanimationeditor.h:        horizontalSplitter->setChildrenCollapsible(false);
ui_tileanimationeditor.h:        verticalSplitter->setObjectName(QStringLiteral("verticalSplitter"));
ui_tileanimationeditor.h:        verticalSplitter->setOrientation(Qt::Vertical);
ui_tileanimationeditor.h:        frameList->setObjectName(QStringLiteral("frameList"));
ui_tileanimationeditor.h:        sizePolicy.setHeightForWidth(frameList->sizePolicy().hasHeightForWidth());
ui_tileanimationeditor.h:        frameList->setSizePolicy(sizePolicy);
ui_tileanimationeditor.h:        frameList->setMinimumSize(QSize(128, 0));
ui_tileanimationeditor.h:        frameList->setMaximumSize(QSize(16777215, 16777215));
ui_tileanimationeditor.h:        frameList->setAcceptDrops(true);
ui_tileanimationeditor.h:        frameList->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
ui_tileanimationeditor.h:        frameList->setDragEnabled(true);
ui_tileanimationeditor.h:        frameList->setDragDropMode(QAbstractItemView::DragDrop);
ui_tileanimationeditor.h:        frameList->setDefaultDropAction(Qt::MoveAction);
ui_tileanimationeditor.h:        frameList->setSelectionMode(QAbstractItemView::ExtendedSelection);
ui_tileanimationeditor.h:        frameList->setHorizontalScrollMode(QAbstractItemView::ScrollPerPixel);
ui_tileanimationeditor.h:        frameList->setViewMode(QListView::ListMode);
ui_tileanimationeditor.h:        verticalSplitter->addWidget(frameList);
ui_tileanimationeditor.h:        preview->setObjectName(QStringLiteral("preview"));
ui_tileanimationeditor.h:        sizePolicy1.setHeightForWidth(preview->sizePolicy().hasHeightForWidth());
ui_tileanimationeditor.h:        preview->setSizePolicy(sizePolicy1);
ui_tileanimationeditor.h:        preview->setMinimumSize(QSize(0, 64));
ui_tileanimationeditor.h:        preview->setFrameShape(QFrame::Box);
ui_tileanimationeditor.h:        preview->setFrameShadow(QFrame::Sunken);
ui_tileanimationeditor.h:        preview->setAlignment(Qt::AlignCenter);
ui_tileanimationeditor.h:        verticalSplitter->addWidget(preview);
ui_tileanimationeditor.h:        horizontalSplitter->addWidget(verticalSplitter);
ui_tileanimationeditor.h:        tilesetView->setObjectName(QStringLiteral("tilesetView"));
ui_tileanimationeditor.h:        sizePolicy2.setHeightForWidth(tilesetView->sizePolicy().hasHeightForWidth());
ui_tileanimationeditor.h:        tilesetView->setSizePolicy(sizePolicy2);
ui_tileanimationeditor.h:        tilesetView->setMinimumSize(QSize(128, 0));
ui_tileanimationeditor.h:        tilesetView->setDragEnabled(true);
ui_tileanimationeditor.h:        tilesetView->setDragDropMode(QAbstractItemView::DragOnly);
ui_tileanimationeditor.h:        horizontalSplitter->addWidget(tilesetView);
ui_tileanimationeditor.h:        verticalLayout->addWidget(horizontalSplitter);
ui_tileanimationeditor.h:        buttonBox->setObjectName(QStringLiteral("buttonBox"));
ui_tileanimationeditor.h:        buttonBox->setStandardButtons(QDialogButtonBox::Close);
ui_tileanimationeditor.h:        verticalLayout->addWidget(buttonBox);
ui_tileanimationeditor.h:        TileAnimationEditor->setWindowTitle(QApplication::translate("TileAnimationEditor", "Tile Animation Editor", 0));
ui_tileanimationeditor.h:        preview->setText(QApplication::translate("TileAnimationEditor", "Preview", 0));
moc_abstractimagetool.cpp:        - idx * sizeof(QByteArrayData) \
moc_abstractimagetool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
Binary file automapperwrapper.o matches
Binary file tilelayeritem.o matches
tilesetchanges.cpp: * Copyright 2011-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tilesetchanges.cpp:    , mOldName(tileset->name())
tilesetchanges.cpp:    mMapDocument->setTilesetName(mTileset, mOldName);
tilesetchanges.cpp:    mMapDocument->setTilesetName(mTileset, mNewName);
tilesetchanges.cpp:    , mOldTileOffset(tileset->tileOffset())
tilesetchanges.cpp:    mMapDocument->setTilesetTileOffset(mTileset, mOldTileOffset);
tilesetchanges.cpp:    mMapDocument->setTilesetTileOffset(mTileset, mNewTileOffset);
tilesetchanges.cpp:    if (!(mMapDocument == o->mMapDocument && mTileset == o->mTileset))
tilesetchanges.cpp:    mNewTileOffset = o->mNewTileOffset;
Binary file moc_editpolygontool.o matches
resizemapobject.cpp:    , mNewSize(mapObject->size())
resizemapobject.cpp:    mMapDocument->mapObjectModel()->setObjectSize(mMapObject, mOldSize);
resizemapobject.cpp:    mMapDocument->mapObjectModel()->setObjectSize(mMapObject, mNewSize);
tilestampmodel.cpp:        return createIndex(id - 1, 0);
tilestampmodel.cpp:                Map *map = variation->map;
tilestampmodel.cpp:                return variation->probability;
tilestampmodel.cpp:        if (stamp.variations().size() - count == 1)
tilestampmodel.cpp:            beginRemoveRows(parent, row, row + count - 1);
tilestampmodel.cpp:        for (; count > 0; --count) {
tilestampmodel.cpp:        beginRemoveRows(parent, row, row + count - 1);
tilestampmodel.cpp:        for (; count > 0; --count) {
tilestampmodel.cpp:    if (index == -1)
tilestampmodel.cpp:    if (index == -1)
moc_layerdock.cpp:        - idx * sizeof(QByteArrayData) \
moc_layerdock.cpp:        case 0: _t->updateOpacitySlider(); break;
moc_layerdock.cpp:        case 1: _t->layerChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_layerdock.cpp:        case 2: _t->editLayerName(); break;
moc_layerdock.cpp:        case 3: _t->sliderValueChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_layerdock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_layerdock.cpp:        _id -= 4;
moc_layerdock.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_layerdock.cpp:        _id -= 4;
moc_layerdock.cpp:        - idx * sizeof(QByteArrayData) \
moc_layerdock.cpp:        case 0: _t->currentRowChanged((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_layerdock.cpp:        case 1: _t->indexPressed((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_layerdock.cpp:        case 2: _t->currentLayerIndexChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_layerdock.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_layerdock.cpp:        _id -= 3;
moc_layerdock.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_layerdock.cpp:        _id -= 3;
mapsdock.cpp:    layout->setMargin(5);
mapsdock.cpp:    model->setFilter(QDir::AllDirs | QDir::Dirs | QDir::Drives | QDir::NoDotAndDotDot);
mapsdock.cpp:    mDirectoryEdit->setCompleter(completer);
mapsdock.cpp:    dirLayout->addWidget(mDirectoryEdit);
mapsdock.cpp:    dirLayout->addWidget(button);
mapsdock.cpp:    layout->addWidget(mMapsView);
mapsdock.cpp:    layout->addLayout(dirLayout);
mapsdock.cpp:    mDirectoryEdit->setText(prefs->mapsDirectory());
mapsdock.cpp:                                                  mDirectoryEdit->text());
mapsdock.cpp:        prefs->setMapsDirectory(f);
mapsdock.cpp:    prefs->setMapsDirectory(mDirectoryEdit->text());
mapsdock.cpp:    mDirectoryEdit->setText(prefs->mapsDirectory());
mapsdock.cpp:    switch (e->type()) {
mapsdock.cpp:    QDir mapsDir(prefs->mapsDirectory());
mapsdock.cpp:    mFSModel->setRootPath(mapsDir.absolutePath());
mapsdock.cpp:        if (!(format->capabilities() & MapFormat::Read))
mapsdock.cpp:        const QString filter = format->nameFilter();
mapsdock.cpp:        if (filterFinder.indexIn(filter) != -1)
mapsdock.cpp:    mFSModel->setFilter(QDir::AllDirs | QDir::Files | QDir::NoDot);
mapsdock.cpp:    mFSModel->setNameFilters(nameFilters);
mapsdock.cpp:    mFSModel->setNameFilterDisables(false); // hide filtered files
mapsdock.cpp:    headerView->hideSection(1); // Size column
mapsdock.cpp:    headerView->hideSection(2);
mapsdock.cpp:    headerView->hideSection(3);
mapsdock.cpp:    setRootIndex(mFSModel->index(mapsDir.absolutePath()));
mapsdock.cpp:    header()->setStretchLastSection(false);
mapsdock.cpp:    header()->setSectionResizeMode(0, QHeaderView::Stretch);
mapsdock.cpp:    QModelIndex index = indexAt(event->pos());
mapsdock.cpp:        // Prevent drag-and-drop starting when clicking on an unselected item.
mapsdock.cpp:        setDragEnabled(selectionModel()->isSelected(index));
mapsdock.cpp:    QDir mapsDir(prefs->mapsDirectory());
mapsdock.cpp:    model()->setRootPath(mapsDir.canonicalPath());
mapsdock.cpp:    setRootIndex(model()->index(mapsDir.absolutePath()));
mapsdock.cpp:    QString path = model()->filePath(index);
mapsdock.cpp:        prefs->setMapsDirectory(fileInfo.canonicalFilePath());
mapsdock.cpp:    mMainWindow->openFile(path);
images/tilelayer-icon.svg:<?xml version="1.0" encoding="UTF-8" standalone="no"?>
images/tilelayer-icon.svg:<!-- Created with Inkscape (http://www.inkscape.org/) -->
images/tilelayer-icon.svg:   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
images/tilelayer-icon.svg:   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
images/tilelayer-icon.svg:   inkscape:export-filename="/home/bjorn/projects/tiled-qt/src/tiled/images/16x16/layer-tile.png"
images/tilelayer-icon.svg:   inkscape:export-xdpi="90"
images/tilelayer-icon.svg:   inkscape:export-ydpi="90"
images/tilelayer-icon.svg:   sodipodi:docname="tilelayer-icon.svg">
images/tilelayer-icon.svg:       inkscape:persp3d-origin="372.04724 : 350.78739 : 1"
images/tilelayer-icon.svg:     inkscape:cx="-0.25591059"
images/tilelayer-icon.svg:     inkscape:document-units="px"
images/tilelayer-icon.svg:     inkscape:current-layer="layer1"
images/tilelayer-icon.svg:     inkscape:window-width="1270"
images/tilelayer-icon.svg:     inkscape:window-height="626"
images/tilelayer-icon.svg:     inkscape:window-x="0"
images/tilelayer-icon.svg:     inkscape:window-y="137"
images/tilelayer-icon.svg:     inkscape:window-maximized="0">
images/tilelayer-icon.svg:     transform="translate(0,-1036.3622)">
images/tilelayer-icon.svg:       style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-opacity:1"
images/tilelayer-icon.svg:         style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-opacity:1">
images/tilelayer-icon.svg:           style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-width:1;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/tilelayer-icon.svg:           style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-width:1;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
images/tilelayer-icon.svg:           transform="translate(4,1.7382813e-5)"
images/tilelayer-icon.svg:           style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-opacity:1" />
images/tilelayer-icon.svg:         transform="translate(-0.5,-0.5000174)"
images/tilelayer-icon.svg:         style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-opacity:1">
images/tilelayer-icon.svg:           style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-opacity:1">
images/tilelayer-icon.svg:             style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-width:1;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/tilelayer-icon.svg:             style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-width:1;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
images/tilelayer-icon.svg:             transform="translate(4,1.7382813e-5)"
images/tilelayer-icon.svg:             style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-opacity:1" />
images/tilelayer-icon.svg:           style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-opacity:1">
images/tilelayer-icon.svg:             transform="translate(0,-4.0000174)"
images/tilelayer-icon.svg:             style="fill:#c7d8f9;fill-opacity:1;stroke:#375084;stroke-opacity:1" />
Binary file images/22x22/stock-tool-by-color-select.png matches
Binary file images/22x22/stock-tool-clone.png matches
Binary file images/22x22/stock-tool-fuzzy-select-22.png matches
Binary file images/22x22/stock-tool-rect-select.png matches
Binary file images/22x22/tool-select-objects.png matches
Binary file images/22x22/stock-tool-bucket-fill.png matches
Binary file images/22x22/stock-tool-eraser.png matches
Binary file images/22x22/remove.png matches
Binary file images/22x22/add.png matches
Binary file images/about-tiled-logo.png matches
Binary file images/16x16/go-down.png matches
Binary file images/16x16/layer-image.png matches
Binary file images/16x16/document-import.png matches
Binary file images/16x16/edit-paste.png matches
Binary file images/16x16/stock-duplicate-16.png matches
Binary file images/16x16/edit-cut.png matches
Binary file images/16x16/edit-delete.png matches
Binary file images/16x16/zoom-original.png matches
Binary file images/16x16/document-page-setup.png matches
Binary file images/16x16/document-open.png matches
Binary file images/16x16/document-save-as.png matches
Binary file images/16x16/terrain.png matches
Binary file images/16x16/go-up.png matches
Binary file images/16x16/document-properties.png matches
Binary file images/16x16/document-save.png matches
Binary file images/16x16/rename.png matches
Binary file images/16x16/terminal.png matches
Binary file images/16x16/edit-undo.png matches
Binary file images/16x16/zoom-out.png matches
Binary file images/16x16/terminal-green.png matches
Binary file images/16x16/terminal-red.png matches
Binary file images/16x16/document-export.png matches
Binary file images/16x16/drive-harddisk.png matches
Binary file images/16x16/remove.png matches
Binary file images/16x16/window-close.png matches
Binary file images/16x16/zoom-in.png matches
Binary file images/16x16/document-open-recent.png matches
Binary file images/16x16/edit-clear.png matches
Binary file images/16x16/layer-object.png matches
Binary file images/16x16/document-new.png matches
Binary file images/16x16/help-about.png matches
images/scalable/application-x-tiled.svg:<?xml version="1.0" encoding="UTF-8" standalone="no"?>
images/scalable/application-x-tiled.svg:<!-- Created with Inkscape (http://www.inkscape.org/) -->
images/scalable/application-x-tiled.svg:   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
images/scalable/application-x-tiled.svg:   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
images/scalable/application-x-tiled.svg:   inkscape:export-filename="/home/bjorn/projects/tiled-qt/src/images/tiled-icon-32.png"
images/scalable/application-x-tiled.svg:   inkscape:export-xdpi="90"
images/scalable/application-x-tiled.svg:   inkscape:export-ydpi="90"
images/scalable/application-x-tiled.svg:       inkscape:persp3d-origin="372.04724 : 350.78739 : 1"
images/scalable/application-x-tiled.svg:     inkscape:document-units="px"
images/scalable/application-x-tiled.svg:     inkscape:current-layer="layer1"
images/scalable/application-x-tiled.svg:     inkscape:window-width="1080"
images/scalable/application-x-tiled.svg:     inkscape:window-height="670"
images/scalable/application-x-tiled.svg:     inkscape:window-x="4"
images/scalable/application-x-tiled.svg:     inkscape:window-y="71">
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:       transform="translate(-0.5,1.3395986)">
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:       style="opacity:0.38009050999999999;stroke-width:1;stroke-miterlimit:4;stroke-dasharray:none"
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/application-x-tiled.svg:       style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#2b2b2b;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
images/scalable/application-x-tiled.svg:       style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#2b2b2b;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
images/scalable/application-x-tiled.svg:       style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#2b2b2b;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
images/scalable/application-x-tiled.svg:       style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#2b2b2b;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
images/scalable/application-x-tiled.svg:       style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#2b2b2b;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
images/scalable/tiled.svg:<?xml version="1.0" encoding="UTF-8" standalone="no"?>
images/scalable/tiled.svg:<!-- Created with Inkscape (http://www.inkscape.org/) -->
images/scalable/tiled.svg:   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
images/scalable/tiled.svg:   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
images/scalable/tiled.svg:   inkscape:export-filename="/home/bjorn/projects/tiled-qt/src/images/tiled-icon-32.png"
images/scalable/tiled.svg:   inkscape:export-xdpi="90"
images/scalable/tiled.svg:   inkscape:export-ydpi="90"
images/scalable/tiled.svg:       inkscape:persp3d-origin="372.04724 : 350.78739 : 1"
images/scalable/tiled.svg:     inkscape:document-units="px"
images/scalable/tiled.svg:     inkscape:current-layer="layer1"
images/scalable/tiled.svg:     inkscape:window-width="1080"
images/scalable/tiled.svg:     inkscape:window-height="670"
images/scalable/tiled.svg:     inkscape:window-x="4"
images/scalable/tiled.svg:     inkscape:window-y="71">
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:       transform="translate(-0.5,1.3395986)">
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:       style="opacity:0.38009050999999999;stroke-width:1;stroke-miterlimit:4;stroke-dasharray:none"
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:         style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />
images/scalable/tiled.svg:       style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#2b2b2b;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
images/scalable/tiled.svg:       style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#2b2b2b;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
images/scalable/tiled.svg:       style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#2b2b2b;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
images/scalable/tiled.svg:       style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#2b2b2b;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
images/scalable/tiled.svg:       style="fill:#616bdd;fill-opacity:1;fill-rule:evenodd;stroke:#2b2b2b;stroke-width:1;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
Binary file images/tmx-icon-mac.icns matches
Binary file images/24x24/go-down.png matches
images/24x24/dice.svg:<?xml version="1.0" encoding="UTF-8" standalone="no"?>
images/24x24/dice.svg:<!-- Created with Inkscape (http://www.inkscape.org/) -->
images/24x24/dice.svg:   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
images/24x24/dice.svg:       color-interpolation-filters="sRGB"
images/24x24/dice.svg:     style="stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none">
images/24x24/dice.svg:       d="m 9.77086,2.2673666 c 0.260285,-0.433809 0.867618,-0.9543798 1.301427,-0.9543798 l 9.543798,5.3792316 c 0.173524,0.1735236 0.607333,1.301427 0.260285,1.735236 L 11.419334,13.98021 c -0.260285,0.08676 -1.388189,0 -1.7352358,-0.867618 L 9.77086,2.2673666 z"
images/24x24/dice.svg:       style="fill:#404040;fill-opacity:1;fill-rule:evenodd;stroke:#404040;stroke-width:0.5;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       d="m 10.710405,13.320061 c -0.247896,0.430318 -0.65352,0.430312 -0.9014161,-5e-6 L 7.0628107,8.5530318 c -0.2478868,-0.4303007 -0.2478966,-1.1344235 0,-1.564741 L 9.8089889,2.2212669 c 0.2478901,-0.4303063 0.6535291,-0.4303063 0.9014161,-5.6e-6 l 2.746178,4.7670239 c 0.247897,0.4303176 0.24789,1.1344459 0,1.5647522 l -2.746178,4.7670236 z"
images/24x24/dice.svg:       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none" />
images/24x24/dice.svg:       transform="matrix(0.00431067,-0.00919099,0.00431067,0.00919099,7.9836534,7.4894113)"
images/24x24/dice.svg:       style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:56.1696167;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       d="m 20.417027,7.6596349 c 0.496614,-4.739e-4 0.699421,0.350809 0.450703,0.7806527 l -2.755275,4.7617734 c -0.248708,0.429827 -0.858492,0.781896 -1.355106,0.78237 l -5.501454,0.0053 c -0.496601,4.74e-4 -0.699421,-0.35082 -0.450713,-0.780647 l 2.755276,-4.7617731 c 0.248717,-0.4298436 0.858514,-0.7819022 1.355115,-0.7823761 l 5.501454,-0.00525 z"
images/24x24/dice.svg:       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none" />
images/24x24/dice.svg:       transform="matrix(-0.00937309,9.0606728e-6,0.00469429,-0.0082168,17.181512,13.173584)"
images/24x24/dice.svg:       style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:56.98981094;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       transform="matrix(-0.00815032,8.155676e-6,0.0040819,-0.00739609,16.571187,12.673435)"
images/24x24/dice.svg:       style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:64.4171524;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       transform="matrix(-0.01328595,1.268066e-5,0.00665396,-0.01149963,17.683467,14.023774)"
images/24x24/dice.svg:       style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:40.46240616;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       transform="matrix(-0.00961764,6.9490136e-6,0.00481677,-0.00630181,17.189125,12.968402)"
images/24x24/dice.svg:       style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:64.24259186;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       transform="matrix(-0.00790579,6.3457104e-6,0.00395943,-0.0057547,17.087927,13.367836)"
images/24x24/dice.svg:       style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:74.14911652;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       d="M 10.659581,2.1039699 C 10.410863,1.6741263 10.61368,1.3228488 11.110294,1.3233228 l 5.501454,0.00525 c 0.496595,4.739e-4 1.106388,0.3525269 1.355106,0.7823705 l 2.755275,4.7617733 c 0.248711,0.4298324 0.04589,0.7811266 -0.450703,0.7806527 l -5.501454,-0.00525 C 14.273358,7.6476453 13.663568,7.2955755 13.414857,6.8657432 L 10.659581,2.1039699 z"
images/24x24/dice.svg:       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.5;stroke-miterlimit:4;stroke-dasharray:none" />
images/24x24/dice.svg:       transform="matrix(0.00432686,0.00630181,-0.00863943,-6.9490136e-6,16.500221,2.3793665)"
images/24x24/dice.svg:       style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:67.78205872;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       transform="matrix(0.00506173,0.00739609,-0.01010675,-8.1556769e-6,17.449014,2.5458202)"
images/24x24/dice.svg:       style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:57.84730148;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       transform="matrix(0.00383692,0.00712248,-0.00766116,-7.8539692e-6,17.290919,2.870745)"
images/24x24/dice.svg:       style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:67.70598602;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       transform="matrix(0.00432686,0.00602826,-0.00863944,-6.6473736e-6,16.719561,2.3975667)"
images/24x24/dice.svg:       style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:69.30286407;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       transform="matrix(0,0.03470472,-0.03470472,0,31.271733,-11.962296)"
images/24x24/dice.svg:       style="stroke-width:14.40726185;stroke-miterlimit:4;stroke-dasharray:none">
images/24x24/dice.svg:         d="m 628.93236,528.61822 c 7.5,-12.5 25,-27.5 37.5,-27.5 l 278.6825,160.82693 c 4.11647,6.65796 12.40666,21.07873 5.29642,41.57018 L 676.43236,866.11822 c -7.5,2.5 -40,0 -50,-25 l 2.5,-312.5 z"
images/24x24/dice.svg:         style="fill:#404040;fill-opacity:1;fill-rule:evenodd;stroke:#404040;stroke-width:14.40726185;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:         d="m 656.00495,846.19589 c -7.14303,12.3994 -18.83087,12.39924 -25.97389,-1.6e-4 L 550.90121,708.83622 c -7.14274,-12.39891 -7.14302,-32.68787 0,-45.08726 l 79.12985,-137.35951 c 7.14283,-12.39907 18.83114,-12.39907 25.97389,-1.6e-4 l 79.12984,137.35951 c 7.14303,12.39939 7.14284,32.68851 0,45.08758 l -79.12984,137.35951 z"
images/24x24/dice.svg:         style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:14.40726185;stroke-miterlimit:4;stroke-dasharray:none" />
images/24x24/dice.svg:         transform="matrix(0.12978404,-0.25368614,0.12978404,0.25368614,575.68083,678.1885)"
images/24x24/dice.svg:         style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:56.14453125;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:         d="m 935.69654,683.99391 c 14.3097,-0.0137 20.15348,10.10839 12.9868,22.49413 l -79.39191,137.2082 c -7.1664,12.38525 -24.73702,22.52998 -39.04672,22.54363 l -158.52176,0.1513 c -14.30933,0.0137 -20.15349,-10.10871 -12.98709,-22.49396 L 738.12778,706.689 c 7.16668,-12.38574 24.73767,-22.53013 39.047,-22.54379 l 158.52176,-0.1513 z"
images/24x24/dice.svg:         style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:14.40726185;stroke-miterlimit:4;stroke-dasharray:none" />
images/24x24/dice.svg:         transform="matrix(-0.27712776,2.4369426e-4,0.13879296,-0.22099742,818.77709,852.14944)"
images/24x24/dice.svg:         style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:58.2328186;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:         transform="matrix(-0.22779952,2.2630837e-4,0.11408806,-0.20523079,829.32393,838.26749)"
images/24x24/dice.svg:         style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:66.65055084;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:         d="m 654.54044,523.91001 c -7.16668,-12.38573 -1.32262,-22.50762 12.98709,-22.49396 l 158.52176,0.1513 c 14.30914,0.0137 31.88004,10.15789 39.04672,22.54363 l 79.39191,137.2082 c 7.1665,12.38541 1.32234,22.50779 -12.9868,22.49413 l -158.52176,-0.1513 c -14.30971,-0.0137 -31.88051,-10.15838 -39.047,-22.54379 L 654.54044,523.91001 z"
images/24x24/dice.svg:         style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:14.40726185;stroke-miterlimit:4;stroke-dasharray:none" />
images/24x24/dice.svg:         transform="matrix(0.1317346,0.20252752,-0.26303436,-2.2332746e-4,838.1154,529.70037)"
images/24x24/dice.svg:         style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:62.43859863;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:         transform="matrix(0.11761727,0.19239949,-0.23484628,-2.1215927e-4,838.76034,546.41292)"
images/24x24/dice.svg:         style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:67.79655457;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:         transform="matrix(0.10764416,0.17370076,-0.21493299,-1.9154014e-4,831.27338,546.09327)"
images/24x24/dice.svg:         style="fill:#404040;fill-opacity:1;stroke:#000000;stroke-width:74.58457184;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none" />
images/24x24/dice.svg:       d="m 8.0390603,17.540838 0.00891,-2.854901 0.1153456,-0.232721 c 0.06344,-0.127997 0.17594,-0.291651 0.25,-0.363678 0.090186,-0.08771 0.9132421,-0.581201 2.4922801,-1.494333 1.296694,-0.749857 2.383447,-1.377195 2.415007,-1.394085 0.05551,-0.02971 0.0571,0.06235 0.04862,2.822458 l -0.0088,2.853167 -0.11236,0.234375 c -0.0618,0.128906 -0.170263,0.291966 -0.241032,0.362355 -0.08721,0.08674 -0.886777,0.566134 -2.48139,1.487755 -1.2939944,0.747876 -2.3848501,1.37659 -2.4241232,1.397142 l -0.071405,0.03737 0.00891,-2.854901 0,0 z m 1.4464056,1.261674 c 0.1655125,-0.07578 0.407486,-0.33991 0.5034641,-0.549553 0.212319,-0.463766 0.126398,-0.911909 -0.2088111,-1.089107 -0.1267095,-0.06698 -0.4023378,-0.05697 -0.5473984,0.01989 -0.1644333,0.08712 -0.3549707,0.305931 -0.4712208,0.541148 -0.1003533,0.203051 -0.1146545,0.260821 -0.1170523,0.472835 -0.00229,0.202793 0.00981,0.26392 0.075482,0.381203 0.1457821,0.26035 0.4751529,0.356548 0.7655364,0.223586 z M 10.77978,16.612427 c 0.274824,-0.140205 0.522003,-0.53718 0.555089,-0.891483 0.03835,-0.410697 -0.189262,-0.704946 -0.543712,-0.702888 -0.53796,0.0031 -1.0151346,0.812952 -0.788895,1.33886 0.124151,0.288598 0.482092,0.406226 0.777518,0.255511 z m 1.321568,-2.065089 c 0.182675,-0.05073 0.436859,-0.306029 0.566069,-0.568543 0.323208,-0.656651 0.119143,-1.273925 -0.421146,-1.273925 -0.249117,0 -0.491355,0.154351 -0.676633,0.431144 -0.159346,0.238051 -0.226031,0.427687 -0.246755,0.70171 -0.0146,0.193067 -0.0062,0.25329 0.05494,0.395499 0.124476,0.289352 0.392972,0.405919 0.723524,0.314115 l 0,0 z"
images/24x24/dice.svg:       style="fill:#c8c8c8;fill-opacity:1;stroke:none" />
images/24x24/dice.svg:       d="M 14.37591,12.323362 C 14.37581,11.68241 14.36222,11.075526 14.34572,10.974731 14.30418,10.721078 14.22071,10.566314 13.998791,10.331475 13.894048,10.22064 13.772895,10.058921 13.729558,9.9721004 13.686221,9.88528 13.608451,9.7697325 13.556736,9.7153282 l -0.09403,-0.098917 0.274814,-0.4792081 c 0.304919,-0.5317018 0.445001,-0.6917916 0.740298,-0.8460303 l 0.195145,-0.1019278 2.886154,-0.00845 2.886154,-0.00845 -0.07767,0.1334471 c -0.04272,0.073396 -0.671396,1.1600097 -1.397057,2.4146969 -0.737561,1.275264 -1.369697,2.333769 -1.43348,2.400347 -0.06275,0.0655 -0.218801,0.170972 -0.346772,0.234375 l -0.232673,0.115278 -1.290764,0.0091 -1.290764,0.0091 -1.81e-4,-1.165366 0,0 z m 2.462128,0.968631 c 0.467158,-0.172968 0.751721,-0.595668 0.617408,-0.917123 -0.112841,-0.270068 -0.31652,-0.374565 -0.684097,-0.350975 -0.612575,0.03931 -1.108594,0.518118 -0.990619,0.956243 0.03663,0.13603 0.232159,0.337643 0.352386,0.363347 0.0391,0.0084 0.09923,0.02143 0.1336,0.02903 0.108488,0.02401 0.399944,-0.01707 0.571322,-0.08052 l 0,0 z M 15.971981,11.87326 c 0.511998,-0.151909 0.84161,-0.466774 0.84161,-0.803954 0,-0.476934 -0.482425,-0.693979 -1.109375,-0.499112 -0.630862,0.196083 -0.966417,0.647457 -0.76895,1.034359 0.07553,0.147981 0.156589,0.220525 0.305944,0.273792 0.163399,0.05828 0.525719,0.05575 0.730771,-0.0051 l 0,0 z m 2.188206,-1.523099 c 0.384026,-0.117649 0.718115,-0.3752102 0.858265,-0.6616674 0.07077,-0.1446453 0.08172,-0.2017956 0.07098,-0.3704944 -0.01648,-0.2588528 -0.107325,-0.3981358 -0.331955,-0.5089629 -0.148198,-0.073118 -0.190654,-0.079906 -0.40625,-0.064956 -0.569561,0.039495 -1.105142,0.4901258 -1.152025,0.9692995 -0.04648,0.4750002 0.439006,0.7966942 0.96099,0.6367812 l 0,0 z m -3.152449,-0.261502 c 0.225651,-0.1055949 0.48318,-0.3434894 0.571884,-0.5282822 0.03198,-0.066622 0.06366,-0.1984755 0.07039,-0.2930067 0.01771,-0.2485196 -0.08089,-0.4222087 -0.307462,-0.5416357 -0.149953,-0.07904 -0.19365,-0.08774 -0.377429,-0.075145 -0.290023,0.019875 -0.57518,0.1579709 -0.79186,0.383482 -0.260239,0.2708455 -0.33289,0.5752304 -0.201889,0.8458442 0.157757,0.3258814 0.59699,0.4143514 1.036363,0.2087444 z"
images/24x24/dice.svg:       style="fill:#8d8d8d;fill-opacity:1;fill-rule:nonzero;stroke:none" />
Binary file images/24x24/edit-paste.png matches
Binary file images/24x24/edit-cut.png matches
Binary file images/24x24/system-run.png matches
Binary file images/24x24/zoom-original.png matches
Binary file images/24x24/document-page-setup.png matches
Binary file images/24x24/document-open.png matches
Binary file images/24x24/document-save-as.png matches
Binary file images/24x24/terrain.png matches
Binary file images/24x24/go-up.png matches
Binary file images/24x24/document-properties.png matches
Binary file images/24x24/document-save.png matches
Binary file images/24x24/insert-rectangle.png matches
Binary file images/24x24/insert-object.png matches
Binary file images/24x24/insert-ellipse.png matches
Binary file images/24x24/insert-polygon.png matches
Binary file images/24x24/edit-undo.png matches
Binary file images/24x24/zoom-out.png matches
Binary file images/24x24/edit-copy.png matches
Binary file images/24x24/dice.png matches
Binary file images/24x24/insert-image.png matches
Binary file images/24x24/drive-harddisk.png matches
Binary file images/24x24/edit-redo.png matches
Binary file images/24x24/insert-polyline.png matches
Binary file images/24x24/move-image-layer.png matches
Binary file images/24x24/terrain-edit.png matches
Binary file images/24x24/zoom-in.png matches
Binary file images/24x24/document-open-recent.png matches
Binary file images/24x24/edit-clear.png matches
Binary file images/24x24/document-new.png matches
Binary file images/24x24/help-about.png matches
images/objectlayer-icon.svg:<?xml version="1.0" encoding="UTF-8" standalone="no"?>
images/objectlayer-icon.svg:<!-- Created with Inkscape (http://www.inkscape.org/) -->
images/objectlayer-icon.svg:   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
images/objectlayer-icon.svg:   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
images/objectlayer-icon.svg:   inkscape:export-filename="/home/tlindeij/projects/tiled-qt/src/tiled/images/16x16/layer-object.png"
images/objectlayer-icon.svg:   inkscape:export-xdpi="90"
images/objectlayer-icon.svg:   inkscape:export-ydpi="90"
images/objectlayer-icon.svg:       inkscape:persp3d-origin="372.04724 : 350.78739 : 1"
images/objectlayer-icon.svg:     inkscape:document-units="px"
images/objectlayer-icon.svg:     inkscape:current-layer="layer1"
images/objectlayer-icon.svg:     inkscape:window-width="1423"
images/objectlayer-icon.svg:     inkscape:window-height="874"
images/objectlayer-icon.svg:     inkscape:window-x="6"
images/objectlayer-icon.svg:     inkscape:window-y="52"
images/objectlayer-icon.svg:     inkscape:window-maximized="0">
images/objectlayer-icon.svg:     transform="translate(-136.88075,-236.82137)">
images/objectlayer-icon.svg:       style="fill:#e39df4;fill-opacity:1;stroke:#68237a;stroke-width:1;stroke-opacity:1"
images/objectlayer-icon.svg:       style="fill:#e39df4;fill-opacity:1;stroke:#68237a;stroke-width:1;stroke-opacity:1"
images/objectlayer-icon.svg:       style="fill:#e39df4;fill-opacity:1;stroke:#68237a;stroke-width:1;stroke-opacity:1"
Binary file images/32x32/application-x-tiled.png matches
Binary file images/32x32/tiled.png matches
Binary file images/tiled-icon-mac.icns matches
resizedialog.h: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
changeproperties.cpp: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
changeproperties.cpp:    const Properties oldProperties = mObject->properties();
changeproperties.cpp:    mMapDocument->setProperties(mObject, mNewProperties);
changeproperties.cpp:        prop.existed = obj->hasProperty(mName);
changeproperties.cpp:        prop.previousValue = obj->property(mName);
changeproperties.cpp:    if (mObjects.size() > 1 || mObjects[0]->hasProperty(mName))
changeproperties.cpp:            mMapDocument->setProperty(mObjects[i], mName, mProperties[i].previousValue);
changeproperties.cpp:            mMapDocument->removeProperty(mObjects[i], mName);
changeproperties.cpp:        mMapDocument->setProperty(obj, mName, mValue);
changeproperties.cpp:        mPreviousValues.append(obj->property(mName));
changeproperties.cpp:        mMapDocument->setProperty(mObjects[i], mName, mPreviousValues[i]);
changeproperties.cpp:        mMapDocument->removeProperty(obj, mName);
changeproperties.cpp:        if (!object->hasProperty(oldName))
changeproperties.cpp:        const QString value = object->property(oldName);
changeimagelayerposition.cpp:    , mUndoPos(imageLayer->position())
changeimagelayerposition.cpp:    mImageLayer->setPosition(mRedoPos);
changeimagelayerposition.cpp:    mMapDocument->emitImageLayerChanged(mImageLayer);
changeimagelayerposition.cpp:    mImageLayer->setPosition(mUndoPos);
changeimagelayerposition.cpp:    mMapDocument->emitImageLayerChanged(mImageLayer);
moc_mapobjectmodel.cpp:        - idx * sizeof(QByteArrayData) \
moc_mapobjectmodel.cpp:        case 0: _t->objectsAdded((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_mapobjectmodel.cpp:        case 1: _t->objectsChanged((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_mapobjectmodel.cpp:        case 2: _t->objectsRemoved((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_mapobjectmodel.cpp:        case 3: _t->layerAdded((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapobjectmodel.cpp:        case 4: _t->layerChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapobjectmodel.cpp:        case 5: _t->layerAboutToBeRemoved((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapobjectmodel.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_mapobjectmodel.cpp:        _id -= 6;
moc_mapobjectmodel.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_mapobjectmodel.cpp:        _id -= 6;
Binary file moc_abstractobjecttool.o matches
offsetmapdialog.ui:<?xml version="1.0" encoding="UTF-8"?>
offsetmapdialog.ui:         <number>-999</number>
offsetmapdialog.ui:         <number>-999</number>
changelayer.cpp: * Copyright 2012-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
changelayer.cpp:    const Layer *layer = mMapDocument->map()->layerAt(mLayerIndex);
changelayer.cpp:    const bool previousVisible = layer->isVisible();
changelayer.cpp:    mMapDocument->layerModel()->setLayerVisible(mLayerIndex, mVisible);
changelayer.cpp:    , mOldOpacity(mMapDocument->map()->layerAt(layerIndex)->opacity())
changelayer.cpp:    if (!(mMapDocument == o->mMapDocument &&
changelayer.cpp:          mLayerIndex == o->mLayerIndex))
changelayer.cpp:    mNewOpacity = o->mNewOpacity;
changelayer.cpp:    mMapDocument->layerModel()->setLayerOpacity(mLayerIndex, opacity);
changelayer.cpp:    , mOldOffset(mMapDocument->map()->layerAt(layerIndex)->offset())
changelayer.cpp:    mMapDocument->layerModel()->setLayerOffset(mLayerIndex, offset);
movelayer.h: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file moc_colorbutton.o matches
movabletabwidget.cpp:    tabBar()->moveTab(from, to);
mapscene.h: * Copyright 2008-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
moc_imagemovementtool.cpp:        - idx * sizeof(QByteArrayData) \
moc_imagemovementtool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_eraser.cpp:        - idx * sizeof(QByteArrayData) \
moc_eraser.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
movelayer.cpp: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
movelayer.cpp:    const int currentIndex = mMapDocument->currentLayerIndex();
movelayer.cpp:    LayerModel *layerModel = mMapDocument->layerModel();
movelayer.cpp:    Layer *layer = layerModel->takeLayerAt(mIndex);
movelayer.cpp:    mIndex = (mDirection == Down) ? mIndex - 1 : mIndex + 1;
movelayer.cpp:    layerModel->insertLayer(mIndex, layer);
movelayer.cpp:    mMapDocument->setCurrentLayerIndex(
Binary file addremovelayer.o matches
Binary file filesystemwatcher.o matches
Binary file moc_mapobjectmodel.o matches
moc_resizehelper.cpp:        - idx * sizeof(QByteArrayData) \
moc_resizehelper.cpp:        case 0: _t->offsetChanged((*reinterpret_cast< const QPoint(*)>(_a[1]))); break;
moc_resizehelper.cpp:        case 1: _t->offsetXChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_resizehelper.cpp:        case 2: _t->offsetYChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_resizehelper.cpp:        case 3: _t->offsetBoundsChanged((*reinterpret_cast< const QRect(*)>(_a[1]))); break;
moc_resizehelper.cpp:        case 4: _t->setOldSize((*reinterpret_cast< const QSize(*)>(_a[1]))); break;
moc_resizehelper.cpp:        case 5: _t->setNewSize((*reinterpret_cast< const QSize(*)>(_a[1]))); break;
moc_resizehelper.cpp:        case 6: _t->setOffset((*reinterpret_cast< const QPoint(*)>(_a[1]))); break;
moc_resizehelper.cpp:        case 7: _t->setOffsetX((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_resizehelper.cpp:        case 8: _t->setOffsetY((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_resizehelper.cpp:        case 9: _t->setNewWidth((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_resizehelper.cpp:        case 10: _t->setNewHeight((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_resizehelper.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_resizehelper.cpp:        _id -= 11;
moc_resizehelper.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_resizehelper.cpp:        _id -= 11;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->rangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->singleStepChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->readOnlyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->setMinimum((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 6: _t->setMaximum((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 7: _t->setRange((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_qtpropertymanager.cpp:        case 8: _t->setSingleStep((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 9: _t->setReadOnly((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 10;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 10;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->textVisibleChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->setTextVisible((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 4;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 4;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->rangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2])),(*reinterpret_cast< double(*)>(_a[3]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->singleStepChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->decimalsChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->readOnlyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 6: _t->setMinimum((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 7: _t->setMaximum((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 8: _t->setRange((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2])),(*reinterpret_cast< double(*)>(_a[3]))); break;
moc_qtpropertymanager.cpp:        case 9: _t->setSingleStep((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 10: _t->setDecimals((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 11: _t->setReadOnly((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 12;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 12;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->regExpChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRegExp(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->echoModeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->readOnlyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->setRegExp((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRegExp(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 6: _t->setEchoMode((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< EchoMode(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 7: _t->setReadOnly((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 8;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 8;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDate(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->rangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDate(*)>(_a[2])),(*reinterpret_cast< const QDate(*)>(_a[3]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDate(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->setMinimum((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDate(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->setMaximum((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDate(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->setRange((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDate(*)>(_a[2])),(*reinterpret_cast< const QDate(*)>(_a[3]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 6;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 6;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QTime(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QTime(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 2;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 2;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDateTime(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QDateTime(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 2;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 2;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QKeySequence(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QKeySequence(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 2;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 2;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QChar(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QChar(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 2;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 2;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QLocale(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QLocale(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->d_func()->slotEnumChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 4;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 4;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QPoint(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QPoint(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->d_func()->slotIntChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 4;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 4;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QPointF(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->decimalsChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QPointF(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->setDecimals((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->d_func()->slotDoubleChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 6;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 6;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSize(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->rangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSize(*)>(_a[2])),(*reinterpret_cast< const QSize(*)>(_a[3]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSize(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->setMinimum((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSize(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->setMaximum((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSize(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->setRange((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSize(*)>(_a[2])),(*reinterpret_cast< const QSize(*)>(_a[3]))); break;
moc_qtpropertymanager.cpp:        case 6: _t->d_func()->slotIntChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 7: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 8;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 8;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSizeF(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->rangeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSizeF(*)>(_a[2])),(*reinterpret_cast< const QSizeF(*)>(_a[3]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->decimalsChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSizeF(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->setMinimum((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSizeF(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->setMaximum((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSizeF(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 6: _t->setRange((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSizeF(*)>(_a[2])),(*reinterpret_cast< const QSizeF(*)>(_a[3]))); break;
moc_qtpropertymanager.cpp:        case 7: _t->setDecimals((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 8: _t->d_func()->slotDoubleChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 9: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 10;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 10;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRect(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->constraintChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRect(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRect(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->setConstraint((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRect(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->d_func()->slotIntChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 6;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 6;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRectF(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->constraintChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRectF(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->decimalsChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRectF(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->setConstraint((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QRectF(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->setDecimals((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 6: _t->d_func()->slotDoubleChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 7: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 8;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 8;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->enumNamesChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QStringList(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->enumIconsChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QMap<int,QIcon>(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->setEnumNames((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QStringList(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->setEnumIcons((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QMap<int,QIcon>(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 6;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 6;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->flagNamesChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QStringList(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->setFlagNames((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QStringList(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->d_func()->slotBoolChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 6;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 6;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSizePolicy(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QSizePolicy(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->d_func()->slotIntChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->d_func()->slotEnumChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 5;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 5;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QFont(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QFont(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->d_func()->slotIntChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->d_func()->slotEnumChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 4: _t->d_func()->slotBoolChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< bool(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 5: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertymanager.cpp:        case 6: _t->d_func()->slotFontDatabaseChanged(); break;
moc_qtpropertymanager.cpp:        case 7: _t->d_func()->slotFontDatabaseDelayedChange(); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 8;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 8;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QColor(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QColor(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 2: _t->d_func()->slotIntChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 3: _t->d_func()->slotPropertyDestroyed((*reinterpret_cast< QtProperty*(*)>(_a[1]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 4;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 4;
moc_qtpropertymanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertymanager.cpp:        case 0: _t->valueChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QCursor(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:        case 1: _t->setValue((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QCursor(*)>(_a[2]))); break;
moc_qtpropertymanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertymanager.cpp:        _id -= 2;
moc_qtpropertymanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertymanager.cpp:        _id -= 2;
Binary file moc_variantpropertymanager.o matches
addremoveterrain.cpp:    mTerrain = mMapDocument->terrainModel()->takeTerrainAt(mTileset, mIndex);
addremoveterrain.cpp:    mMapDocument->terrainModel()->insertTerrain(mTileset, mIndex, mTerrain);
addremoveterrain.cpp:                       terrain->tileset(),
addremoveterrain.cpp:                       terrain->tileset()->terrainCount(),
addremoveterrain.cpp:                       terrain->tileset(),
addremoveterrain.cpp:                       terrain->id(),
Binary file moc_commandbutton.o matches
Binary file moc_eraser.o matches
Binary file mapsdock.o matches
Binary file tileselectionitem.o matches
Binary file moc_createellipseobjecttool.o matches
raiselowerhelper.h:        : mMapDocument(mapScene->mapDocument())
imagemovementtool.cpp:                       QIcon(QLatin1String(":images/24x24/move-image-layer.png")),
imagemovementtool.cpp:    QPointF newPosition = mLayerStart + (pos - mMouseStart);
imagemovementtool.cpp:    SnapHelper(mapDocument()->renderer(), modifiers).snap(newPosition);
imagemovementtool.cpp:    layer->setPosition(newPosition.toPoint());
imagemovementtool.cpp:    mapDocument()->emitImageLayerChanged(layer);
imagemovementtool.cpp:    mMouseStart = event->scenePos();
imagemovementtool.cpp:        mLayerStart = layer->position();
imagemovementtool.cpp:        QPoint layerFinish = layer->position();
imagemovementtool.cpp:        layer->setPosition(mLayerStart);
imagemovementtool.cpp:        mapDocument()->undoStack()->push(
Binary file changemapproperty.o matches
rotatemapobject.cpp:    , mNewRotation(mapObject->rotation())
rotatemapobject.cpp:    mMapDocument->mapObjectModel()->setObjectRotation(mMapObject, mOldRotation);
rotatemapobject.cpp:    mMapDocument->mapObjectModel()->setObjectRotation(mMapObject, mNewRotation);
moc_qtpropertybrowserutils_p.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertybrowserutils_p.cpp:        case 0: _t->toggled((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_qtpropertybrowserutils_p.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertybrowserutils_p.cpp:        _id -= 1;
moc_qtpropertybrowserutils_p.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertybrowserutils_p.cpp:        _id -= 1;
moc_qtpropertybrowserutils_p.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtpropertybrowserutils_p.cpp:        case 0: _t->keySequenceChanged((*reinterpret_cast< const QKeySequence(*)>(_a[1]))); break;
moc_qtpropertybrowserutils_p.cpp:        case 1: _t->setKeySequence((*reinterpret_cast< const QKeySequence(*)>(_a[1]))); break;
moc_qtpropertybrowserutils_p.cpp:        case 2: _t->slotClearShortcut(); break;
moc_qtpropertybrowserutils_p.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtpropertybrowserutils_p.cpp:        _id -= 3;
moc_qtpropertybrowserutils_p.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtpropertybrowserutils_p.cpp:        _id -= 3;
Binary file moc_minimap.o matches
Binary file moc_consoledock.o matches
Binary file documentmanager.o matches
layermodel.cpp: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
layermodel.cpp:    mTileLayerIcon(QLatin1String(":/images/16x16/layer-tile.png")),
layermodel.cpp:    mObjectGroupIcon(QLatin1String(":/images/16x16/layer-object.png")),
layermodel.cpp:    mImageLayerIcon(QLatin1String(":/images/16x16/layer-image.png"))
layermodel.cpp:    return parent.isValid() ? 0 : (mMap ? mMap->layerCount() : 0);
layermodel.cpp:    const Layer *layer = mMap->layerAt(layerIndex);
layermodel.cpp:        return layer->name();
layermodel.cpp:        switch (layer->layerType()) {
layermodel.cpp:        return layer->isVisible() ? Qt::Checked : Qt::Unchecked;
layermodel.cpp:        return layer->opacity();
layermodel.cpp:    Layer *layer = mMap->layerAt(layerIndex);
layermodel.cpp:        if (visible != layer->isVisible()) {
layermodel.cpp:            mMapDocument->undoStack()->push(command);
layermodel.cpp:            if (layer->opacity() != opacity) {
layermodel.cpp:                mMapDocument->undoStack()->push(command);
layermodel.cpp:        if (layer->name() != newName) {
layermodel.cpp:            mMapDocument->undoStack()->push(rename);
layermodel.cpp:        return mMap->layerCount() - index.row() - 1;
layermodel.cpp:        return -1;
layermodel.cpp:    return mMap->layerCount() - layerIndex - 1;
layermodel.cpp:    mMap = mMapDocument->map();
layermodel.cpp:    mMap->insertLayer(index, layer);
layermodel.cpp:    Layer *layer = mMap->takeLayerAt(index);
layermodel.cpp:    Layer *layer = mMap->layerAt(layerIndex);
layermodel.cpp:    if (layer->isVisible() == visible)
layermodel.cpp:    layer->setVisible(visible);
layermodel.cpp:    Layer *layer = mMap->layerAt(layerIndex);
layermodel.cpp:    if (layer->opacity() == opacity)
layermodel.cpp:    layer->setOpacity(opacity);
layermodel.cpp:    Layer *layer = mMap->layerAt(layerIndex);
layermodel.cpp:    if (layer->offset() == offset)
layermodel.cpp:    layer->setOffset(offset);
layermodel.cpp:    Layer *layer = mMap->layerAt(layerIndex);
layermodel.cpp:    if (layer->name() == name)
layermodel.cpp:    layer->setName(name);
layermodel.cpp:    if (mMap->layerCount() <= 1) // No other layers
layermodel.cpp:    for (int i = 0; i < mMap->layerCount(); i++) {
layermodel.cpp:        Layer *layer = mMap->layerAt(i);
layermodel.cpp:        if (layer->isVisible()) {
layermodel.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
layermodel.cpp:        undoStack->beginMacro(tr("Show Other Layers"));
layermodel.cpp:        undoStack->beginMacro(tr("Hide Other Layers"));
layermodel.cpp:    for (int i = 0; i < mMap->layerCount(); i++) {
layermodel.cpp:        if (visibility != mMap->layerAt(i)->isVisible())
layermodel.cpp:            undoStack->push(new SetLayerVisible(mMapDocument, i, visibility));
layermodel.cpp:    undoStack->endMacro();
moc_clipboardmanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_clipboardmanager.cpp:        case 0: _t->hasMapChanged(); break;
moc_clipboardmanager.cpp:        case 1: _t->updateHasMap(); break;
moc_clipboardmanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_clipboardmanager.cpp:        _id -= 2;
moc_clipboardmanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_clipboardmanager.cpp:        _id -= 2;
undodock.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
undodock.cpp:    QIcon cleanIcon(QLatin1String(":images/16x16/drive-harddisk.png"));
undodock.cpp:    mUndoView->setCleanIcon(cleanIcon);
undodock.cpp:    mUndoView->setUniformItemSizes(true);
undodock.cpp:    layout->setMargin(5);
undodock.cpp:    layout->addWidget(mUndoView);
undodock.cpp:    switch (e->type()) {
undodock.cpp:    mUndoView->setEmptyLabel(tr("<empty>"));
Binary file moc_tileanimationeditor.o matches
createobjecttool.cpp: * Copyright 2010-2011, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
createobjecttool.cpp:                         QIcon(QLatin1String(":images/24x24/insert-rectangle.png")),
createobjecttool.cpp:    mObjectGroupItem->setZValue(10000); // same as the BrushItem
createobjecttool.cpp:    scene->addItem(mObjectGroupItem);
createobjecttool.cpp:    scene->removeItem(mObjectGroupItem);
createobjecttool.cpp:    switch (event->key()) {
createobjecttool.cpp:        QPointF offset = mNewMapObjectItem->mapObject()->objectGroup()->offset();
createobjecttool.cpp:        mouseMovedWhileCreatingObject(pos - offset, modifiers);
createobjecttool.cpp:    if (event->button() != Qt::LeftButton) {
createobjecttool.cpp:    if (!objectGroup || !objectGroup->isVisible())
createobjecttool.cpp:    const MapRenderer *renderer = mapDocument()->renderer();
createobjecttool.cpp:    const QPointF offsetPos = event->scenePos() - objectGroup->offset();
createobjecttool.cpp:        const QPointF diff(-mTile->width() / 2, mTile->height() / 2);
createobjecttool.cpp:        pixelCoords = renderer->screenToPixelCoords(offsetPos + diff);
createobjecttool.cpp:        pixelCoords = renderer->screenToPixelCoords(offsetPos);
createobjecttool.cpp:    SnapHelper(renderer, event->modifiers()).snap(pixelCoords);
createobjecttool.cpp:    newMapObject->setPosition(pos);
createobjecttool.cpp:    objectGroup->addObject(newMapObject);
createobjecttool.cpp:    mObjectGroupItem->setObjectGroup(objectGroup);
createobjecttool.cpp:    MapObject *newMapObject = mNewMapObjectItem->mapObject();
createobjecttool.cpp:    ObjectGroup *objectGroup = newMapObject->objectGroup();
createobjecttool.cpp:    objectGroup->removeObject(newMapObject);
createobjecttool.cpp:    MapObject *newMapObject = mNewMapObjectItem->mapObject();
createobjecttool.cpp:    ObjectGroup *objectGroup = newMapObject->objectGroup();
createobjecttool.cpp:    mapDocument()->undoStack()->push(new AddMapObject(mapDocument(),
createobjecttool.cpp:    mapDocument()->setSelectedObjects(QList<MapObject*>() << newMapObject);
tiled.rc:IDI_ICON1               ICON    DISCARDABLE     "images/tiled-icon.ico"
tileanimationdriver.cpp:    setLoopCount(-1); // loop forever
tileanimationdriver.cpp:    int elapsed = currentTime - mLastTime;
Binary file moc_terraindock.o matches
Binary file moc_createmultipointobjecttool.o matches
Binary file terraindock.o matches
moc_editterraindialog.cpp:        - idx * sizeof(QByteArrayData) \
moc_editterraindialog.cpp:        case 0: _t->selectedTerrainChanged((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_editterraindialog.cpp:        case 1: _t->eraseTerrainToggled((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_editterraindialog.cpp:        case 2: _t->addTerrainType((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_editterraindialog.cpp:        case 3: _t->addTerrainType(); break;
moc_editterraindialog.cpp:        case 4: _t->removeTerrainType(); break;
moc_editterraindialog.cpp:        case 5: _t->setTerrainImage((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_editterraindialog.cpp:        case 6: _t->updateUndoButton(); break;
moc_editterraindialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_editterraindialog.cpp:        _id -= 7;
moc_editterraindialog.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_editterraindialog.cpp:        _id -= 7;
languagemanager.cpp:    QString language = Preferences::instance()->language();
languagemanager.cpp:    if (mQtTranslator->load(QLatin1String("qt_") + language,
languagemanager.cpp:    if (mAppTranslator->load(QLatin1String("tiled_") + language,
moc_fileedit.cpp:        - idx * sizeof(QByteArrayData) \
moc_fileedit.cpp:        case 0: _t->filePathChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_fileedit.cpp:        case 1: _t->validate((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_fileedit.cpp:        case 2: _t->buttonClicked(); break;
moc_fileedit.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_fileedit.cpp:        _id -= 3;
moc_fileedit.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_fileedit.cpp:        _id -= 3;
Binary file selectionrectangle.o matches
Binary file moc_createscalableobjecttool.o matches
preferencesdialog.ui:<?xml version="1.0" encoding="UTF-8"?>
tilestampsdock.cpp:    , mTileStampModel(stampManager->tileStampModel())
tilestampsdock.cpp:    mProxyModel->setSortLocaleAware(true);
tilestampsdock.cpp:    mProxyModel->setSortCaseSensitivity(Qt::CaseInsensitive);
tilestampsdock.cpp:    mProxyModel->setFilterCaseSensitivity(Qt::CaseInsensitive);
tilestampsdock.cpp:    mProxyModel->setSourceModel(mTileStampModel);
tilestampsdock.cpp:    mProxyModel->sort(0);
tilestampsdock.cpp:    mTileStampView->setModel(mProxyModel);
tilestampsdock.cpp:    mTileStampView->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
tilestampsdock.cpp:    mTileStampView->header()->setStretchLastSection(false);
tilestampsdock.cpp:    mTileStampView->header()->setSectionResizeMode(0, QHeaderView::Stretch);
tilestampsdock.cpp:    mTileStampView->header()->setSectionResizeMode(1, QHeaderView::ResizeToContents);
tilestampsdock.cpp:    mTileStampView->setContextMenuPolicy(Qt::CustomContextMenu);
tilestampsdock.cpp:    mNewStamp->setIcon(QIcon(QLatin1String(":images/16x16/document-new.png")));
tilestampsdock.cpp:    mAddVariation->setIcon(QIcon(QLatin1String(":/images/16x16/add.png")));
tilestampsdock.cpp:    mDuplicate->setIcon(QIcon(QLatin1String(":/images/16x16/stock-duplicate-16.png")));
tilestampsdock.cpp:    mDelete->setIcon(QIcon(QLatin1String(":images/16x16/edit-delete.png")));
tilestampsdock.cpp:    mChooseFolder->setIcon(QIcon(QLatin1String(":images/16x16/document-open.png")));
tilestampsdock.cpp:    Utils::setThemeIcon(mNewStamp, "document-new");
tilestampsdock.cpp:    Utils::setThemeIcon(mDelete, "edit-delete");
tilestampsdock.cpp:    Utils::setThemeIcon(mChooseFolder, "document-open");
tilestampsdock.cpp:    mFilterEdit->setClearButtonEnabled(true);
tilestampsdock.cpp:    mDuplicate->setEnabled(false);
tilestampsdock.cpp:    mDelete->setEnabled(false);
tilestampsdock.cpp:    mAddVariation->setEnabled(false);
tilestampsdock.cpp:    layout->setMargin(5);
tilestampsdock.cpp:    buttonContainer->setFloatable(false);
tilestampsdock.cpp:    buttonContainer->setMovable(false);
tilestampsdock.cpp:    buttonContainer->setIconSize(QSize(16, 16));
tilestampsdock.cpp:    buttonContainer->addAction(mNewStamp);
tilestampsdock.cpp:    buttonContainer->addAction(mAddVariation);
tilestampsdock.cpp:    buttonContainer->addAction(mDuplicate);
tilestampsdock.cpp:    buttonContainer->addAction(mDelete);
tilestampsdock.cpp:    stretch->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Minimum);
tilestampsdock.cpp:    buttonContainer->addWidget(stretch);
tilestampsdock.cpp:    buttonContainer->addAction(mChooseFolder);
tilestampsdock.cpp:    listAndToolBar->setSpacing(0);
tilestampsdock.cpp:    listAndToolBar->addWidget(mFilterEdit);
tilestampsdock.cpp:    listAndToolBar->addWidget(mTileStampView);
tilestampsdock.cpp:    listAndToolBar->addWidget(buttonContainer);
tilestampsdock.cpp:    layout->addLayout(listAndToolBar);
tilestampsdock.cpp:    QItemSelectionModel *selectionModel = mTileStampView->selectionModel();
tilestampsdock.cpp:    switch (e->type()) {
tilestampsdock.cpp:    switch (event->key()) {
tilestampsdock.cpp:    const QModelIndex sourceIndex = mProxyModel->mapToSource(index);
tilestampsdock.cpp:    const bool isStamp = mTileStampModel->isStamp(sourceIndex);
tilestampsdock.cpp:    mDuplicate->setEnabled(isStamp);
tilestampsdock.cpp:    mDelete->setEnabled(sourceIndex.isValid());
tilestampsdock.cpp:    mAddVariation->setEnabled(isStamp);
tilestampsdock.cpp:        emit setStamp(mTileStampModel->stampAt(sourceIndex));
tilestampsdock.cpp:    } else if (const TileStampVariation *variation = mTileStampModel->variationAt(sourceIndex)) {
tilestampsdock.cpp:        emit setStamp(TileStamp(new Map(*variation->map)));
tilestampsdock.cpp:    const QModelIndex index = mTileStampView->indexAt(pos);
tilestampsdock.cpp:    const QModelIndex sourceIndex = mProxyModel->mapToSource(index);
tilestampsdock.cpp:    if (mTileStampModel->isStamp(sourceIndex)) {
tilestampsdock.cpp:        QAction *addStampVariation = new QAction(mAddVariation->icon(),
tilestampsdock.cpp:                                                 mAddVariation->text(), &menu);
tilestampsdock.cpp:        QAction *deleteStamp = new QAction(mDelete->icon(),
tilestampsdock.cpp:    menu.exec(mTileStampView->viewport()->mapToGlobal(pos));
tilestampsdock.cpp:    TileStamp stamp = mTileStampManager->createStamp();
tilestampsdock.cpp:        QModelIndex stampIndex = mTileStampModel->index(stamp);
tilestampsdock.cpp:            QModelIndex viewIndex = mProxyModel->mapFromSource(stampIndex);
tilestampsdock.cpp:            mTileStampView->setCurrentIndex(viewIndex);
tilestampsdock.cpp:            mTileStampView->edit(viewIndex);
tilestampsdock.cpp:    const QModelIndex index = mTileStampView->currentIndex();
tilestampsdock.cpp:    const QModelIndex sourceIndex = mProxyModel->mapToSource(index);
tilestampsdock.cpp:    mTileStampModel->removeRow(sourceIndex.row(), sourceIndex.parent());
tilestampsdock.cpp:    const QModelIndex index = mTileStampView->currentIndex();
tilestampsdock.cpp:    const QModelIndex sourceIndex = mProxyModel->mapToSource(index);
tilestampsdock.cpp:    if (!mTileStampModel->isStamp(sourceIndex))
tilestampsdock.cpp:    TileStamp stamp = mTileStampModel->stampAt(sourceIndex);
tilestampsdock.cpp:    mTileStampModel->addStamp(stamp.clone());
tilestampsdock.cpp:    const QModelIndex index = mTileStampView->currentIndex();
tilestampsdock.cpp:    const QModelIndex sourceIndex = mProxyModel->mapToSource(index);
tilestampsdock.cpp:    if (!mTileStampModel->isStamp(sourceIndex))
tilestampsdock.cpp:    const TileStamp &stamp = mTileStampModel->stampAt(sourceIndex);
tilestampsdock.cpp:    mTileStampManager->addVariation(stamp);
tilestampsdock.cpp:    QString stampsDirectory = prefs->stampsDirectory();
tilestampsdock.cpp:        prefs->setStampsDirectory(stampsDirectory);
tilestampsdock.cpp:    QModelIndex stampIndex = mTileStampModel->index(stamp);
tilestampsdock.cpp:        mTileStampView->scrollTo(mProxyModel->mapFromSource(stampIndex));
tilestampsdock.cpp:    mNewStamp->setText(tr("Add New Stamp"));
tilestampsdock.cpp:    mAddVariation->setText(tr("Add Variation"));
tilestampsdock.cpp:    mDuplicate->setText(tr("Duplicate Stamp"));
tilestampsdock.cpp:    mDelete->setText(tr("Delete Selected"));
tilestampsdock.cpp:    mChooseFolder->setText(tr("Set Stamps Folder"));
tilestampsdock.cpp:    mFilterEdit->setPlaceholderText(tr("Filter"));
utils.h: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
utils.h:        t->setIcon(themeIcon);
objectgroupitem.cpp:    setOpacity(objectGroup->opacity());
objectgroupitem.cpp:    setPos(objectGroup->offset());
objectgroupitem.cpp:    setOpacity(mObjectGroup->opacity());
objectgroupitem.cpp:    setPos(mObjectGroup->offset());
automapper.h: * Copyright 2010-2012, Stefan Beller, stefanbeller@googlemail.com
automapper.h: * - check the rules map for rules and store them
automapper.h: * - compare TileLayers (i. e. check if/where a certain rule must be applied)
automapper.h: * - copy regions of Maps (multiple Layers, the layerlist is a
automapper.h: *                         lookup-table for matching the Layers)
automapper.h:     * the same as mMapDocument->map()
moc_objectselectiontool.cpp:        - idx * sizeof(QByteArrayData) \
moc_objectselectiontool.cpp:        case 0: _t->updateHandles(); break;
moc_objectselectiontool.cpp:        case 1: _t->updateHandleVisibility(); break;
moc_objectselectiontool.cpp:        case 2: _t->objectsRemoved((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_objectselectiontool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_objectselectiontool.cpp:        _id -= 3;
moc_objectselectiontool.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_objectselectiontool.cpp:        _id -= 3;
Binary file tilestampsdock.o matches
Binary file qtbuttonpropertybrowser.o matches
Binary file minimap.o matches
Binary file moc_command.o matches
Binary file moc_filesystemwatcher.o matches
mapview.cpp: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
mapview.cpp:    setUseOpenGL(prefs->useOpenGL());
mapview.cpp:        v->setAttribute(Qt::WA_StaticContents);
mapview.cpp:    v->setMouseTracking(true);
mapview.cpp:                  mZoomable->smoothTransform());
mapview.cpp:            format.setSampleBuffers(true); // Enable anti-aliasing
mapview.cpp:        v->setAttribute(Qt::WA_StaticContents);
mapview.cpp:    v->setMouseTracking(true);
mapview.cpp:        viewport()->grabMouse();
mapview.cpp:        viewport()->releaseMouse();
mapview.cpp:    if (e->type() == QEvent::KeyPress || e->type() == QEvent::KeyRelease) {
mapview.cpp:        if (static_cast<QKeyEvent*>(e)->key() == Qt::Key_Space) {
mapview.cpp:            e->ignore();
mapview.cpp:    } else if (e->type() == QEvent::Gesture) {
mapview.cpp:        if (QGesture *gesture = gestureEvent->gesture(Qt::PinchGesture)) {
mapview.cpp:            if (pinch->changeFlags() & QPinchGesture::ScaleFactorChanged)
mapview.cpp:    if (event->modifiers() & Qt::ControlModifier
mapview.cpp:        && event->orientation() == Qt::Vertical)
mapview.cpp:        mZoomable->handleWheelDelta(event->delta());
mapview.cpp:    mLastMouseScenePos = mapToScene(viewport()->mapFromGlobal(mLastMousePos));
mapview.cpp:    if (event->button() == Qt::MidButton) {
mapview.cpp:    if (event->button() == Qt::MidButton) {
mapview.cpp:        const QPoint d = event->globalPos() - mLastMousePos;
mapview.cpp:        hBar->setValue(hBar->value() + (isRightToLeft() ? d.x() : -d.x()));
mapview.cpp:        vBar->setValue(vBar->value() - d.y());
mapview.cpp:        mLastMousePos = event->globalPos();
mapview.cpp:    mLastMousePos = event->globalPos();
mapview.cpp:    mLastMouseScenePos = mapToScene(viewport()->mapFromGlobal(mLastMousePos));
mapview.cpp:    mZoomable->handlePinchGesture(pinch);
mapview.cpp:    QPoint centerPoint = pinch->hotSpot().toPoint();
mapview.cpp:    QPointF viewCenterScenePos = mapToScene(view->rect().center());
mapview.cpp:    QPointF mouseScenePos = mapToScene(view->mapFromGlobal(mousePos));
mapview.cpp:    QPointF diff = viewCenterScenePos - mouseScenePos;
Binary file objectsdock.o matches
Binary file main.o matches
Binary file moc_tiledapplication.o matches
Binary file snaphelper.o matches
moc_createpolygonobjecttool.cpp:        - idx * sizeof(QByteArrayData) \
moc_createpolygonobjecttool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
Binary file createrectangleobjecttool.o matches
ui_mainwindow.h:        if (MainWindow->objectName().isEmpty())
ui_mainwindow.h:            MainWindow->setObjectName(QStringLiteral("MainWindow"));
ui_mainwindow.h:        MainWindow->resize(553, 367);
ui_mainwindow.h:        MainWindow->setAcceptDrops(true);
ui_mainwindow.h:        MainWindow->setUnifiedTitleAndToolBarOnMac(true);
ui_mainwindow.h:        actionOpen->setObjectName(QStringLiteral("actionOpen"));
ui_mainwindow.h:        icon.addFile(QStringLiteral(":/images/16x16/document-open.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionOpen->setIcon(icon);
ui_mainwindow.h:        actionSave->setObjectName(QStringLiteral("actionSave"));
ui_mainwindow.h:        icon1.addFile(QStringLiteral(":/images/16x16/document-save.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionSave->setIcon(icon1);
ui_mainwindow.h:        actionQuit->setObjectName(QStringLiteral("actionQuit"));
ui_mainwindow.h:        icon2.addFile(QStringLiteral(":/images/16x16/application-exit.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionQuit->setIcon(icon2);
ui_mainwindow.h:        actionQuit->setMenuRole(QAction::QuitRole);
ui_mainwindow.h:        actionCopy->setObjectName(QStringLiteral("actionCopy"));
ui_mainwindow.h:        actionCopy->setEnabled(false);
ui_mainwindow.h:        icon3.addFile(QStringLiteral(":/images/16x16/edit-copy.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionCopy->setIcon(icon3);
ui_mainwindow.h:        actionPaste->setObjectName(QStringLiteral("actionPaste"));
ui_mainwindow.h:        actionPaste->setEnabled(false);
ui_mainwindow.h:        icon4.addFile(QStringLiteral(":/images/16x16/edit-paste.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionPaste->setIcon(icon4);
ui_mainwindow.h:        actionAbout->setObjectName(QStringLiteral("actionAbout"));
ui_mainwindow.h:        icon5.addFile(QStringLiteral(":/images/16x16/help-about.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionAbout->setIcon(icon5);
ui_mainwindow.h:        actionAbout->setMenuRole(QAction::AboutRole);
ui_mainwindow.h:        actionAboutQt->setObjectName(QStringLiteral("actionAboutQt"));
ui_mainwindow.h:        actionAboutQt->setMenuRole(QAction::AboutQtRole);
ui_mainwindow.h:        actionResizeMap->setObjectName(QStringLiteral("actionResizeMap"));
ui_mainwindow.h:        icon6.addFile(QStringLiteral(":/images/16x16/document-page-setup.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionResizeMap->setIcon(icon6);
ui_mainwindow.h:        actionMapProperties->setObjectName(QStringLiteral("actionMapProperties"));
ui_mainwindow.h:        icon7.addFile(QStringLiteral(":/images/16x16/document-properties.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionMapProperties->setIcon(icon7);
ui_mainwindow.h:        actionAutoMap->setObjectName(QStringLiteral("actionAutoMap"));
ui_mainwindow.h:        actionShowGrid->setObjectName(QStringLiteral("actionShowGrid"));
ui_mainwindow.h:        actionShowGrid->setCheckable(true);
ui_mainwindow.h:        actionSaveAs->setObjectName(QStringLiteral("actionSaveAs"));
ui_mainwindow.h:        icon8.addFile(QStringLiteral(":/images/16x16/document-save-as.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionSaveAs->setIcon(icon8);
ui_mainwindow.h:        actionNew->setObjectName(QStringLiteral("actionNew"));
ui_mainwindow.h:        icon9.addFile(QStringLiteral(":/images/16x16/document-new.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionNew->setIcon(icon9);
ui_mainwindow.h:        actionNewTileset->setObjectName(QStringLiteral("actionNewTileset"));
ui_mainwindow.h:        actionNewTileset->setIcon(icon9);
ui_mainwindow.h:	actionNewTileset->setObjectName(QStringLiteral("actionNewTileset"));
ui_mainwindow.h:	actionNewTileset->setIcon(icon9);
ui_mainwindow.h:        actionClose->setObjectName(QStringLiteral("actionClose"));
ui_mainwindow.h:        icon10.addFile(QStringLiteral(":/images/16x16/window-close.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionClose->setIcon(icon10);
ui_mainwindow.h:        actionZoomIn->setObjectName(QStringLiteral("actionZoomIn"));
ui_mainwindow.h:        icon11.addFile(QStringLiteral(":/images/16x16/zoom-in.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionZoomIn->setIcon(icon11);
ui_mainwindow.h:        actionZoomOut->setObjectName(QStringLiteral("actionZoomOut"));
ui_mainwindow.h:        icon12.addFile(QStringLiteral(":/images/16x16/zoom-out.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionZoomOut->setIcon(icon12);
ui_mainwindow.h:        actionZoomNormal->setObjectName(QStringLiteral("actionZoomNormal"));
ui_mainwindow.h:        actionZoomNormal->setEnabled(false);
ui_mainwindow.h:        icon13.addFile(QStringLiteral(":/images/16x16/zoom-original.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionZoomNormal->setIcon(icon13);
ui_mainwindow.h:        actionExportAsImage->setObjectName(QStringLiteral("actionExportAsImage"));
ui_mainwindow.h:        actionCut->setObjectName(QStringLiteral("actionCut"));
ui_mainwindow.h:        actionCut->setEnabled(false);
ui_mainwindow.h:        icon14.addFile(QStringLiteral(":/images/16x16/edit-cut.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionCut->setIcon(icon14);
ui_mainwindow.h:        actionOffsetMap->setObjectName(QStringLiteral("actionOffsetMap"));
ui_mainwindow.h:        actionPreferences->setObjectName(QStringLiteral("actionPreferences"));
ui_mainwindow.h:        actionPreferences->setMenuRole(QAction::PreferencesRole);
ui_mainwindow.h:        actionClearRecentFiles->setObjectName(QStringLiteral("actionClearRecentFiles"));
ui_mainwindow.h:        icon15.addFile(QStringLiteral(":/images/16x16/edit-clear.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionClearRecentFiles->setIcon(icon15);
ui_mainwindow.h:        actionExportAs->setObjectName(QStringLiteral("actionExportAs"));
ui_mainwindow.h:        actionAddExternalTileset->setObjectName(QStringLiteral("actionAddExternalTileset"));
ui_mainwindow.h:        actionSnapToGrid->setObjectName(QStringLiteral("actionSnapToGrid"));
ui_mainwindow.h:        actionSnapToGrid->setCheckable(true);
ui_mainwindow.h:        actionCloseAll->setObjectName(QStringLiteral("actionCloseAll"));
ui_mainwindow.h:        actionDelete->setObjectName(QStringLiteral("actionDelete"));
ui_mainwindow.h:        actionDelete->setEnabled(false);
ui_mainwindow.h:        icon16.addFile(QStringLiteral(":/images/16x16/edit-delete.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        actionDelete->setIcon(icon16);
ui_mainwindow.h:        actionHighlightCurrentLayer->setObjectName(QStringLiteral("actionHighlightCurrentLayer"));
ui_mainwindow.h:        actionHighlightCurrentLayer->setCheckable(true);
ui_mainwindow.h:        actionShowTileObjectOutlines->setObjectName(QStringLiteral("actionShowTileObjectOutlines"));
ui_mainwindow.h:        actionShowTileObjectOutlines->setCheckable(true);
ui_mainwindow.h:        actionSnapToFineGrid->setObjectName(QStringLiteral("actionSnapToFineGrid"));
ui_mainwindow.h:        actionSnapToFineGrid->setCheckable(true);
ui_mainwindow.h:        actionShowTileAnimations->setObjectName(QStringLiteral("actionShowTileAnimations"));
ui_mainwindow.h:        actionShowTileAnimations->setCheckable(true);
ui_mainwindow.h:        actionReload->setObjectName(QStringLiteral("actionReload"));
ui_mainwindow.h:        actionExport->setObjectName(QStringLiteral("actionExport"));
ui_mainwindow.h:        actionBecomePatron->setObjectName(QStringLiteral("actionBecomePatron"));
ui_mainwindow.h:        actionSaveAll->setObjectName(QStringLiteral("actionSaveAll"));
ui_mainwindow.h:        actionDocumentation->setObjectName(QStringLiteral("actionDocumentation"));
ui_mainwindow.h:        actionNoLabels->setObjectName(QStringLiteral("actionNoLabels"));
ui_mainwindow.h:        actionNoLabels->setCheckable(true);
ui_mainwindow.h:        actionLabelsForSelectedObjects->setObjectName(QStringLiteral("actionLabelsForSelectedObjects"));
ui_mainwindow.h:        actionLabelsForSelectedObjects->setCheckable(true);
ui_mainwindow.h:        actionLabelsForSelectedObjects->setChecked(true);
ui_mainwindow.h:        actionLabelsForAllObjects->setObjectName(QStringLiteral("actionLabelsForAllObjects"));
ui_mainwindow.h:        actionLabelsForAllObjects->setCheckable(true);
ui_mainwindow.h:        centralWidget->setObjectName(QStringLiteral("centralWidget"));
ui_mainwindow.h:        verticalLayout->setSpacing(6);
ui_mainwindow.h:        verticalLayout->setContentsMargins(11, 11, 11, 11);
ui_mainwindow.h:        verticalLayout->setObjectName(QStringLiteral("verticalLayout"));
ui_mainwindow.h:        verticalLayout->setContentsMargins(0, 0, 0, 0);
ui_mainwindow.h:        MainWindow->setCentralWidget(centralWidget);
ui_mainwindow.h:        menuBar->setObjectName(QStringLiteral("menuBar"));
ui_mainwindow.h:        menuBar->setGeometry(QRect(0, 0, 553, 23));
ui_mainwindow.h:        menuFile->setObjectName(QStringLiteral("menuFile"));
ui_mainwindow.h:        menuRecentFiles->setObjectName(QStringLiteral("menuRecentFiles"));
ui_mainwindow.h:        icon17.addFile(QStringLiteral(":/images/16x16/document-open-recent.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_mainwindow.h:        menuRecentFiles->setIcon(icon17);
ui_mainwindow.h:        menuEdit->setObjectName(QStringLiteral("menuEdit"));
ui_mainwindow.h:        menuHelp->setObjectName(QStringLiteral("menuHelp"));
ui_mainwindow.h:        menuMap->setObjectName(QStringLiteral("menuMap"));
ui_mainwindow.h:        menuView->setObjectName(QStringLiteral("menuView"));
ui_mainwindow.h:        menuShowObjectNames->setObjectName(QStringLiteral("menuShowObjectNames"));
ui_mainwindow.h:        MainWindow->setMenuBar(menuBar);
ui_mainwindow.h:        mainToolBar->setObjectName(QStringLiteral("mainToolBar"));
ui_mainwindow.h:        MainWindow->addToolBar(Qt::TopToolBarArea, mainToolBar);
ui_mainwindow.h:        statusBar->setObjectName(QStringLiteral("statusBar"));
ui_mainwindow.h:        MainWindow->setStatusBar(statusBar);
ui_mainwindow.h:        toolsToolBar->setObjectName(QStringLiteral("toolsToolBar"));
ui_mainwindow.h:        MainWindow->addToolBar(Qt::TopToolBarArea, toolsToolBar);
ui_mainwindow.h:        menuBar->addAction(menuFile->menuAction());
ui_mainwindow.h:        menuBar->addAction(menuEdit->menuAction());
ui_mainwindow.h:        menuBar->addAction(menuView->menuAction());
ui_mainwindow.h:        menuBar->addAction(menuMap->menuAction());
ui_mainwindow.h:        menuBar->addAction(menuHelp->menuAction());
ui_mainwindow.h:        menuFile->addAction(actionNew);
ui_mainwindow.h:        menuFile->addAction(actionOpen);
ui_mainwindow.h:        menuFile->addAction(menuRecentFiles->menuAction());
ui_mainwindow.h:        menuFile->addSeparator();
ui_mainwindow.h:        menuFile->addAction(actionSave);
ui_mainwindow.h:        menuFile->addAction(actionSaveAs);
ui_mainwindow.h:        menuFile->addAction(actionSaveAll);
ui_mainwindow.h:        menuFile->addAction(actionExport);
ui_mainwindow.h:        menuFile->addAction(actionExportAs);
ui_mainwindow.h:        menuFile->addAction(actionExportAsImage);
ui_mainwindow.h:        menuFile->addAction(actionReload);
ui_mainwindow.h:        menuFile->addSeparator();
ui_mainwindow.h:        menuFile->addAction(actionClose);
ui_mainwindow.h:        menuFile->addAction(actionCloseAll);
ui_mainwindow.h:        menuFile->addAction(actionQuit);
ui_mainwindow.h:        menuRecentFiles->addAction(actionClearRecentFiles);
ui_mainwindow.h:        menuEdit->addAction(actionCut);
ui_mainwindow.h:        menuEdit->addAction(actionCopy);
ui_mainwindow.h:        menuEdit->addAction(actionPaste);
ui_mainwindow.h:        menuEdit->addAction(actionDelete);
ui_mainwindow.h:        menuEdit->addSeparator();
ui_mainwindow.h:        menuEdit->addAction(actionPreferences);
ui_mainwindow.h:        menuHelp->addAction(actionDocumentation);
ui_mainwindow.h:        menuHelp->addSeparator();
ui_mainwindow.h:        menuHelp->addAction(actionBecomePatron);
ui_mainwindow.h:        menuHelp->addAction(actionAbout);
ui_mainwindow.h:        menuMap->addAction(actionNewTileset);
ui_mainwindow.h:	menuMap->addAction(actionSelectAllTiles);
ui_mainwindow.h:        menuMap->addAction(actionAddExternalTileset);
ui_mainwindow.h:        menuMap->addSeparator();
ui_mainwindow.h:        menuMap->addAction(actionResizeMap);
ui_mainwindow.h:        menuMap->addAction(actionOffsetMap);
ui_mainwindow.h:        menuMap->addSeparator();
ui_mainwindow.h:        menuMap->addAction(actionMapProperties);
ui_mainwindow.h:        menuMap->addAction(actionAutoMap);
ui_mainwindow.h:        menuView->addAction(actionShowGrid);
ui_mainwindow.h:        menuView->addAction(actionShowTileObjectOutlines);
ui_mainwindow.h:        menuView->addAction(menuShowObjectNames->menuAction());
ui_mainwindow.h:        menuView->addAction(actionShowTileAnimations);
ui_mainwindow.h:        menuView->addAction(actionHighlightCurrentLayer);
ui_mainwindow.h:        menuView->addSeparator();
ui_mainwindow.h:        menuView->addAction(actionSnapToGrid);
ui_mainwindow.h:        menuView->addAction(actionSnapToFineGrid);
ui_mainwindow.h:        menuView->addSeparator();
ui_mainwindow.h:        menuView->addAction(actionZoomIn);
ui_mainwindow.h:        menuView->addAction(actionZoomOut);
ui_mainwindow.h:        menuView->addAction(actionZoomNormal);
ui_mainwindow.h:        menuShowObjectNames->addAction(actionNoLabels);
ui_mainwindow.h:        menuShowObjectNames->addAction(actionLabelsForSelectedObjects);
ui_mainwindow.h:        menuShowObjectNames->addAction(actionLabelsForAllObjects);
ui_mainwindow.h:        mainToolBar->addAction(actionNew);
ui_mainwindow.h:        mainToolBar->addAction(actionOpen);
ui_mainwindow.h:        mainToolBar->addAction(actionSave);
ui_mainwindow.h:        mainToolBar->addSeparator();
ui_mainwindow.h:        actionOpen->setText(QApplication::translate("MainWindow", "&Open...", 0));
ui_mainwindow.h:        actionSave->setText(QApplication::translate("MainWindow", "&Save", 0));
ui_mainwindow.h:        actionQuit->setText(QApplication::translate("MainWindow", "&Quit", 0));
ui_mainwindow.h:        actionCopy->setText(QApplication::translate("MainWindow", "&Copy", 0));
ui_mainwindow.h:        actionPaste->setText(QApplication::translate("MainWindow", "&Paste", 0));
ui_mainwindow.h:        actionAbout->setText(QApplication::translate("MainWindow", "&About Tiled", 0));
ui_mainwindow.h:        actionAboutQt->setText(QApplication::translate("MainWindow", "About Qt", 0));
ui_mainwindow.h:        actionResizeMap->setText(QApplication::translate("MainWindow", "&Resize Map...", 0));
ui_mainwindow.h:        actionMapProperties->setText(QApplication::translate("MainWindow", "Map &Properties", 0));
ui_mainwindow.h:        actionAutoMap->setText(QApplication::translate("MainWindow", "AutoMap", 0));
ui_mainwindow.h:        actionAutoMap->setShortcut(QApplication::translate("MainWindow", "A", 0));
ui_mainwindow.h:        actionShowGrid->setText(QApplication::translate("MainWindow", "Show &Grid", 0));
ui_mainwindow.h:        actionShowGrid->setShortcut(QApplication::translate("MainWindow", "Ctrl+G", 0));
ui_mainwindow.h:        actionSaveAs->setText(QApplication::translate("MainWindow", "Save &As...", 0));
ui_mainwindow.h:        actionNew->setText(QApplication::translate("MainWindow", "&New...", 0));
ui_mainwindow.h:        actionNewTileset->setText(QApplication::translate("MainWindow", "New &Tileset...", 0));
ui_mainwindow.h:	actionSelectAllTiles->setText(QApplication::translate("MainWindow", "New &Tileset...", 0));
ui_mainwindow.h:        actionClose->setText(QApplication::translate("MainWindow", "&Close", 0));
ui_mainwindow.h:        actionZoomIn->setText(QApplication::translate("MainWindow", "Zoom In", 0));
ui_mainwindow.h:        actionZoomOut->setText(QApplication::translate("MainWindow", "Zoom Out", 0));
ui_mainwindow.h:        actionZoomNormal->setText(QApplication::translate("MainWindow", "Normal Size", 0));
ui_mainwindow.h:        actionZoomNormal->setShortcut(QApplication::translate("MainWindow", "Ctrl+0", 0));
ui_mainwindow.h:        actionExportAsImage->setText(QApplication::translate("MainWindow", "Export As &Image...", 0));
ui_mainwindow.h:        actionCut->setText(QApplication::translate("MainWindow", "Cu&t", 0));
ui_mainwindow.h:        actionOffsetMap->setText(QApplication::translate("MainWindow", "&Offset Map...", 0));
ui_mainwindow.h:        actionOffsetMap->setToolTip(QApplication::translate("MainWindow", "Offsets everything in a layer", 0));
ui_mainwindow.h:        actionPreferences->setText(QApplication::translate("MainWindow", "Pre&ferences...", 0));
ui_mainwindow.h:        actionClearRecentFiles->setText(QApplication::translate("MainWindow", "Clear Recent Files", 0));
ui_mainwindow.h:        actionExportAs->setText(QApplication::translate("MainWindow", "E&xport As...", 0));
ui_mainwindow.h:        actionExportAs->setShortcut(QApplication::translate("MainWindow", "Ctrl+Shift+E", 0));
ui_mainwindow.h:        actionAddExternalTileset->setText(QApplication::translate("MainWindow", "&Add External Tileset...", 0));
ui_mainwindow.h:        actionSnapToGrid->setText(QApplication::translate("MainWindow", "&Snap to Grid", 0));
ui_mainwindow.h:        actionCloseAll->setText(QApplication::translate("MainWindow", "C&lose All", 0));
ui_mainwindow.h:        actionCloseAll->setShortcut(QApplication::translate("MainWindow", "Ctrl+Shift+W", 0));
ui_mainwindow.h:        actionDelete->setText(QApplication::translate("MainWindow", "&Delete", 0));
ui_mainwindow.h:        actionDelete->setIconText(QApplication::translate("MainWindow", "Delete", 0));
ui_mainwindow.h:        actionHighlightCurrentLayer->setText(QApplication::translate("MainWindow", "&Highlight Current Layer", 0));
ui_mainwindow.h:        actionHighlightCurrentLayer->setShortcut(QApplication::translate("MainWindow", "H", 0));
ui_mainwindow.h:        actionShowTileObjectOutlines->setText(QApplication::translate("MainWindow", "Show Tile Object &Outlines", 0));
ui_mainwindow.h:        actionSnapToFineGrid->setText(QApplication::translate("MainWindow", "Snap to &Fine Grid", 0));
ui_mainwindow.h:        actionShowTileAnimations->setText(QApplication::translate("MainWindow", "Show Tile Animations", 0));
ui_mainwindow.h:        actionReload->setText(QApplication::translate("MainWindow", "Reload", 0));
ui_mainwindow.h:        actionReload->setShortcut(QApplication::translate("MainWindow", "Ctrl+R", 0));
ui_mainwindow.h:        actionExport->setText(QApplication::translate("MainWindow", "&Export", 0));
ui_mainwindow.h:        actionExport->setShortcut(QApplication::translate("MainWindow", "Ctrl+E", 0));
ui_mainwindow.h:        actionBecomePatron->setText(QApplication::translate("MainWindow", "Become a Patron", 0));
ui_mainwindow.h:        actionSaveAll->setText(QApplication::translate("MainWindow", "Save All", 0));
ui_mainwindow.h:        actionDocumentation->setText(QApplication::translate("MainWindow", "Documentation", 0));
ui_mainwindow.h:        actionNoLabels->setText(QApplication::translate("MainWindow", "&Never", 0));
ui_mainwindow.h:        actionLabelsForSelectedObjects->setText(QApplication::translate("MainWindow", "For &Selected Objects", 0));
ui_mainwindow.h:        actionLabelsForAllObjects->setText(QApplication::translate("MainWindow", "For &All Objects", 0));
ui_mainwindow.h:        menuFile->setTitle(QApplication::translate("MainWindow", "&File", 0));
ui_mainwindow.h:        menuRecentFiles->setTitle(QApplication::translate("MainWindow", "&Recent Files", 0));
ui_mainwindow.h:        menuEdit->setTitle(QApplication::translate("MainWindow", "&Edit", 0));
ui_mainwindow.h:        menuHelp->setTitle(QApplication::translate("MainWindow", "&Help", 0));
ui_mainwindow.h:        menuMap->setTitle(QApplication::translate("MainWindow", "&Map", 0));
ui_mainwindow.h:        menuView->setTitle(QApplication::translate("MainWindow", "&View", 0));
ui_mainwindow.h:        menuShowObjectNames->setTitle(QApplication::translate("MainWindow", "Show Object &Names", 0));
ui_mainwindow.h:        mainToolBar->setWindowTitle(QApplication::translate("MainWindow", "Main Toolbar", 0));
ui_mainwindow.h:        toolsToolBar->setWindowTitle(QApplication::translate("MainWindow", "Tools", 0));
tilelayeritem.h: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file bucketfilltool.o matches
Binary file moc_objectselectionitem.o matches
Binary file moc_createrectangleobjecttool.o matches
tiled.pro:    LIBS += -framework Foundation
tiled.pro:    LIBS += -L$$OUT_PWD/../../lib
tiled.pro:    QMAKE_LFLAGS += -Wl,-z,origin \'-Wl,-rpath,$$join(QMAKE_RPATHDIR, ":")\'
tiled.pro:mimeicon16.files += images/16x16/application-x-tiled.png
tiled.pro:mimeicon32.files += images/32x32/application-x-tiled.png
tiled.pro:mimeiconscalable.files += images/scalable/application-x-tiled.svg
tiled.pro:    ICON = images/tiled-icon-mac.icns
Binary file automappingutils.o matches
raiselowerhelper.cpp:        --it;
raiselowerhelper.cpp:        if (it.last() == mRelatedObjects.size() - 1)
raiselowerhelper.cpp:        const int from = static_cast<int>(movingItem->zValue());
raiselowerhelper.cpp:        const int to = static_cast<int>(targetItem->zValue()) + 1;
raiselowerhelper.cpp:        MapObjectItem *targetItem = mRelatedObjects.at(it.first() - 1);
raiselowerhelper.cpp:        const int from = static_cast<int>(movingItem->zValue());
raiselowerhelper.cpp:        const int to = static_cast<int>(targetItem->zValue());
raiselowerhelper.cpp:    const QSet<MapObjectItem*> &selectedItems = mMapScene->selectedObjectItems();
raiselowerhelper.cpp:    if (objectGroup->drawOrder() != ObjectGroup::IndexOrder)
raiselowerhelper.cpp:        ranges.insert(static_cast<int>(item->zValue()));
raiselowerhelper.cpp:    int to = objectGroup->objectCount();
raiselowerhelper.cpp:        --it;
raiselowerhelper.cpp:            to -= count;
raiselowerhelper.cpp:        to -= count;
raiselowerhelper.cpp:    const QSet<MapObjectItem*> &selectedItems = mMapScene->selectedObjectItems();
raiselowerhelper.cpp:    if (objectGroup->drawOrder() != ObjectGroup::IndexOrder)
raiselowerhelper.cpp:        ranges.insert(static_cast<int>(item->zValue()));
raiselowerhelper.cpp:    ObjectGroup *group = (*items.begin())->mapObject()->objectGroup();
raiselowerhelper.cpp:        if (item->mapObject()->objectGroup() != group)
raiselowerhelper.cpp: * used for single-step raising and lowering, since the context is not relevant
raiselowerhelper.cpp:    const QSet<MapObjectItem*> &selectedItems = mMapScene->selectedObjectItems();
raiselowerhelper.cpp:    mObjectGroup = (*selectedItems.begin())->mapObject()->objectGroup();
raiselowerhelper.cpp:    if (mObjectGroup->drawOrder() != ObjectGroup::IndexOrder)
raiselowerhelper.cpp:        if (item->mapObject()->objectGroup() != mObjectGroup)
raiselowerhelper.cpp:        shape |= item->mapToScene(item->shape());
raiselowerhelper.cpp:    QList<QGraphicsItem*> items = mMapScene->items(shape,
raiselowerhelper.cpp:            if (mapObjectItem->mapObject()->objectGroup() == mObjectGroup)
raiselowerhelper.cpp:        Q_ASSERT(index != -1);
raiselowerhelper.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
raiselowerhelper.cpp:    undoStack->beginMacro(text);
raiselowerhelper.cpp:        undoStack->push(command);
raiselowerhelper.cpp:    undoStack->endMacro();
containerhelpers.h:    return it == container.end() ? -1 : std::distance(container.begin(), it);
tilestampmanager.cpp: * Copyright 2010-2011, Stefan Beller <stefanbeller@googlemail.com>
tilestampmanager.cpp: * Copyright 2014-2015, Thorbj√∏rn Lindeijer <bjorn@lindeijer.nl>
tilestampmanager.cpp:    const QDir stampsDir(prefs->stampsDirectory());
tilestampmanager.cpp:    const QRegularExpression invalidChars(QLatin1String("[^\\w -]+"));
tilestampmanager.cpp:    const QDir stampsDir(prefs->stampsDirectory());
tilestampmanager.cpp:        stamp = stampBrush->stamp();
tilestampmanager.cpp:        stamp = fillTool->stamp();
tilestampmanager.cpp:    } else if (MapDocument *mapDocument = DocumentManager::instance()->currentDocument()) {
tilestampmanager.cpp:                dynamic_cast<TileLayer*>(mapDocument->currentLayer());
tilestampmanager.cpp:        QRegion selection = mapDocument->selectedArea();
tilestampmanager.cpp:        selection.translate(-tileLayer->position());
tilestampmanager.cpp:        QScopedPointer<TileLayer> copy(tileLayer->copy(selection));
tilestampmanager.cpp:        if (copy->size().isEmpty())
tilestampmanager.cpp:        const Map *map = mapDocument->map();
tilestampmanager.cpp:        Map *copyMap = new Map(map->orientation(),
tilestampmanager.cpp:                               copy->width(), copy->height(),
tilestampmanager.cpp:                               map->tileWidth(), map->tileHeight());
tilestampmanager.cpp:        foreach (const SharedTileset &tileset, copy->usedTilesets())
tilestampmanager.cpp:            copyMap->addTileset(tileset);
tilestampmanager.cpp:        copyMap->setRenderOrder(map->renderOrder());
tilestampmanager.cpp:        copyMap->addLayer(copy.take());
tilestampmanager.cpp:        mTileStampModel->addStamp(stamp);
tilestampmanager.cpp:        mTileStampModel->addVariation(targetStamp, variation);
tilestampmanager.cpp:    mTileStampModel->clear();
tilestampmanager.cpp:            mTileStampModel->removeStamp(stamp);
tilestampmanager.cpp:    mTileStampModel->addStamp(stamp);
tilestampmanager.cpp:    const QString stampsDirectory = prefs->stampsDirectory();
tilestampmanager.cpp:        mTileStampModel->addStamp(stamp);
tilestampmanager.cpp:        int index = mTileStampModel->stamps().size();
tilestampmanager.cpp:    const QString stampsDirectory(prefs->stampsDirectory());
newtilesetdialog.ui:<?xml version="1.0" encoding="UTF-8"?>
Binary file offsetmapdialog.o matches
Binary file createobjecttool.o matches
moc_mapdocument.cpp:        - idx * sizeof(QByteArrayData) \
moc_mapdocument.cpp:        case 0: _t->fileNameChanged((*reinterpret_cast< const QString(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_mapdocument.cpp:        case 1: _t->modifiedChanged(); break;
moc_mapdocument.cpp:        case 2: _t->saved(); break;
moc_mapdocument.cpp:        case 3: _t->selectedAreaChanged((*reinterpret_cast< const QRegion(*)>(_a[1])),(*reinterpret_cast< const QRegion(*)>(_a[2]))); break;
moc_mapdocument.cpp:        case 4: _t->selectedObjectsChanged(); break;
moc_mapdocument.cpp:        case 5: _t->selectedTilesChanged(); break;
moc_mapdocument.cpp:        case 6: _t->currentObjectChanged((*reinterpret_cast< Object*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 7: _t->mapChanged(); break;
moc_mapdocument.cpp:        case 8: _t->layerAdded((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 9: _t->layerAboutToBeRemoved((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 10: _t->layerRenamed((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 11: _t->layerRemoved((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 12: _t->layerChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 13: _t->editLayerNameRequested(); break;
moc_mapdocument.cpp:        case 14: _t->editCurrentObject(); break;
moc_mapdocument.cpp:        case 15: _t->currentLayerIndexChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 16: _t->regionChanged((*reinterpret_cast< const QRegion(*)>(_a[1])),(*reinterpret_cast< Layer*(*)>(_a[2]))); break;
moc_mapdocument.cpp:        case 17: _t->regionEdited((*reinterpret_cast< const QRegion(*)>(_a[1])),(*reinterpret_cast< Layer*(*)>(_a[2]))); break;
moc_mapdocument.cpp:        case 18: _t->tileLayerDrawMarginsChanged((*reinterpret_cast< TileLayer*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 19: _t->tileTerrainChanged((*reinterpret_cast< const QList<Tile*>(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 20: _t->tileProbabilityChanged((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 21: _t->tileObjectGroupChanged((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 22: _t->tileAnimationChanged((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 23: _t->objectGroupChanged((*reinterpret_cast< ObjectGroup*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 24: _t->imageLayerChanged((*reinterpret_cast< ImageLayer*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 25: _t->tilesetAboutToBeAdded((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 26: _t->tilesetAdded((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< Tileset*(*)>(_a[2]))); break;
moc_mapdocument.cpp:        case 27: _t->tilesetAboutToBeRemoved((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 28: _t->tilesetRemoved((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 29: _t->tilesetMoved((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_mapdocument.cpp:        case 30: _t->tilesetFileNameChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 31: _t->tilesetNameChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 32: _t->tilesetTileOffsetChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 33: _t->tilesetChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 34: _t->objectsAdded((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 35: _t->objectsInserted((*reinterpret_cast< ObjectGroup*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_mapdocument.cpp:        case 36: _t->objectsRemoved((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 37: _t->objectsChanged((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 38: _t->objectsIndexChanged((*reinterpret_cast< ObjectGroup*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_mapdocument.cpp:        case 39: _t->propertyAdded((*reinterpret_cast< Object*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_mapdocument.cpp:        case 40: _t->propertyRemoved((*reinterpret_cast< Object*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_mapdocument.cpp:        case 41: _t->propertyChanged((*reinterpret_cast< Object*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_mapdocument.cpp:        case 42: _t->propertiesChanged((*reinterpret_cast< Object*(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 43: _t->onObjectsRemoved((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 44: _t->onMapObjectModelRowsInserted((*reinterpret_cast< const QModelIndex(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_mapdocument.cpp:        case 45: _t->onMapObjectModelRowsInsertedOrRemoved((*reinterpret_cast< const QModelIndex(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_mapdocument.cpp:        case 46: _t->onObjectsMoved((*reinterpret_cast< const QModelIndex(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3])),(*reinterpret_cast< const QModelIndex(*)>(_a[4])),(*reinterpret_cast< int(*)>(_a[5]))); break;
moc_mapdocument.cpp:        case 47: _t->onLayerAdded((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 48: _t->onLayerAboutToBeRemoved((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 49: _t->onLayerRemoved((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapdocument.cpp:        case 50: _t->onTerrainRemoved((*reinterpret_cast< Terrain*(*)>(_a[1]))); break;
moc_mapdocument.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_mapdocument.cpp:        _id -= 51;
moc_mapdocument.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_mapdocument.cpp:        _id -= 51;
Binary file moc_mapview.o matches
moc_tiledapplication.cpp:        - idx * sizeof(QByteArrayData) \
moc_tiledapplication.cpp:        case 0: _t->fileOpenRequest((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_tiledapplication.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tiledapplication.cpp:        _id -= 1;
moc_tiledapplication.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tiledapplication.cpp:        _id -= 1;
moc_automappingmanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_automappingmanager.cpp:        case 0: _t->errorsOccurred((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_automappingmanager.cpp:        case 1: _t->warningsOccurred((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_automappingmanager.cpp:        case 2: _t->autoMap(); break;
moc_automappingmanager.cpp:        case 3: _t->autoMap((*reinterpret_cast< const QRegion(*)>(_a[1])),(*reinterpret_cast< Layer*(*)>(_a[2]))); break;
moc_automappingmanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_automappingmanager.cpp:        _id -= 4;
moc_automappingmanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_automappingmanager.cpp:        _id -= 4;
editterraindialog.cpp:        , mTerrainModel(mapDocument->terrainModel())
editterraindialog.cpp:        , mOldImageTileId(tileset->terrain(terrainId)->imageTileId())
editterraindialog.cpp:    { mTerrainModel->setTerrainImage(mTileset, mTerrainId, mOldImageTileId); }
editterraindialog.cpp:    { mTerrainModel->setTerrainImage(mTileset, mTerrainId, mNewImageTileId); }
editterraindialog.cpp:    , mInitialUndoStackIndex(mMapDocument->undoStack()->index())
editterraindialog.cpp:    mUi->setupUi(this);
editterraindialog.cpp:    Utils::setThemeIcon(mUi->redo, "edit-redo");
editterraindialog.cpp:    Utils::setThemeIcon(mUi->undo, "edit-undo");
editterraindialog.cpp:    zoomable->connectToComboBox(mUi->zoomComboBox);
editterraindialog.cpp:    TilesetModel *tilesetModel = new TilesetModel(mTileset, mUi->tilesetView);
editterraindialog.cpp:    mUi->tilesetView->setEditTerrain(true);
editterraindialog.cpp:    mUi->tilesetView->setMapDocument(mapDocument);
editterraindialog.cpp:    mUi->tilesetView->setZoomable(zoomable);
editterraindialog.cpp:    mUi->tilesetView->setModel(tilesetModel);
editterraindialog.cpp:    mTerrainModel = mapDocument->terrainModel();
editterraindialog.cpp:    const QModelIndex rootIndex = mTerrainModel->index(tileset);
editterraindialog.cpp:    mUi->terrainList->setMapDocument(mapDocument);
editterraindialog.cpp:    mUi->terrainList->setModel(mTerrainModel);
editterraindialog.cpp:    mUi->terrainList->setRootIndex(rootIndex);
editterraindialog.cpp:    QHeaderView *terrainListHeader = mUi->terrainList->header();
editterraindialog.cpp:    terrainListHeader->setSectionResizeMode(0, QHeaderView::ResizeToContents);
editterraindialog.cpp:    QItemSelectionModel *selectionModel = mUi->terrainList->selectionModel();
editterraindialog.cpp:    if (mTerrainModel->rowCount(rootIndex) > 0) {
editterraindialog.cpp:        selectionModel->setCurrentIndex(mTerrainModel->index(0, 0, rootIndex),
editterraindialog.cpp:        mUi->terrainList->setFocus();
editterraindialog.cpp:    connect(mUi->eraseTerrain, SIGNAL(toggled(bool)),
editterraindialog.cpp:    connect(mUi->addTerrainTypeButton, SIGNAL(clicked()),
editterraindialog.cpp:    connect(mUi->removeTerrainTypeButton, SIGNAL(clicked()),
editterraindialog.cpp:    connect(mUi->tilesetView, SIGNAL(createNewTerrain(Tile*)),
editterraindialog.cpp:    connect(mUi->tilesetView, SIGNAL(terrainImageSelected(Tile*)),
editterraindialog.cpp:    QUndoStack *undoStack = mapDocument->undoStack();
editterraindialog.cpp:            mUi->redo, SLOT(setEnabled(bool)));
editterraindialog.cpp:    connect(mUi->undo, SIGNAL(clicked()), undoStack, SLOT(undo()));
editterraindialog.cpp:    connect(mUi->redo, SIGNAL(clicked()), undoStack, SLOT(redo()));
editterraindialog.cpp:            mUi->eraseTerrain, SLOT(toggle()));
editterraindialog.cpp:    int terrainId = -1;
editterraindialog.cpp:    if (Terrain *terrain = mTerrainModel->terrainAt(index))
editterraindialog.cpp:        terrainId = terrain->id();
editterraindialog.cpp:    mUi->tilesetView->setTerrainId(terrainId);
editterraindialog.cpp:    mUi->removeTerrainTypeButton->setEnabled(terrainId != -1);
editterraindialog.cpp:    mUi->tilesetView->setEraseTerrain(checked);
editterraindialog.cpp:    Terrain *terrain = new Terrain(mTileset->terrainCount(),
editterraindialog.cpp:                                   QString(), tile ? tile->id() : -1);
editterraindialog.cpp:    terrain->setName(tr("New Terrain"));
editterraindialog.cpp:    mMapDocument->undoStack()->push(new AddTerrain(mMapDocument, terrain));
editterraindialog.cpp:    const QModelIndex index = mTerrainModel->index(terrain);
editterraindialog.cpp:    QItemSelectionModel *selectionModel = mUi->terrainList->selectionModel();
editterraindialog.cpp:    selectionModel->setCurrentIndex(index,
editterraindialog.cpp:    mUi->terrainList->edit(index);
editterraindialog.cpp:    const QModelIndex currentIndex = mUi->terrainList->currentIndex();
editterraindialog.cpp:    Terrain *terrain = mTerrainModel->terrainAt(currentIndex);
editterraindialog.cpp:    foreach (Tile *tile, terrain->tileset()->tiles()) {
editterraindialog.cpp:        unsigned tileTerrain = tile->terrain();
editterraindialog.cpp:            if (tile->cornerTerrainId(corner) == terrain->id())
editterraindialog.cpp:        if (tileTerrain != tile->terrain()) {
editterraindialog.cpp:            changes.insert(tile, ChangeTileTerrain::Change(tile->terrain(),
editterraindialog.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
editterraindialog.cpp:        undoStack->beginMacro(removeTerrain->text());
editterraindialog.cpp:        undoStack->push(new ChangeTileTerrain(mMapDocument, changes));
editterraindialog.cpp:    mMapDocument->undoStack()->push(removeTerrain);
editterraindialog.cpp:        undoStack->endMacro();
editterraindialog.cpp:    selectedTerrainChanged(mUi->terrainList->currentIndex());
editterraindialog.cpp:    const QModelIndex currentIndex = mUi->terrainList->currentIndex();
editterraindialog.cpp:    Terrain *terrain = mTerrainModel->terrainAt(currentIndex);
editterraindialog.cpp:    mMapDocument->undoStack()->push(new SetTerrainImage(mMapDocument,
editterraindialog.cpp:                                                        terrain->tileset(),
editterraindialog.cpp:                                                        terrain->id(),
editterraindialog.cpp:                                                        tile->id()));
editterraindialog.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
editterraindialog.cpp:    const bool canUndo = undoStack->index() > mInitialUndoStackIndex;
editterraindialog.cpp:    const bool canRedo = undoStack->canRedo();
editterraindialog.cpp:    mUi->undo->setEnabled(canUndo);
editterraindialog.cpp:    mUi->redo->setEnabled(canRedo);
editterraindialog.cpp:    mUndoShortcut->setEnabled(canUndo);
editterraindialog.cpp:    mRedoShortcut->setEnabled(canRedo);
ui_offsetmapdialog.h:        if (OffsetMapDialog->objectName().isEmpty())
ui_offsetmapdialog.h:            OffsetMapDialog->setObjectName(QStringLiteral("OffsetMapDialog"));
ui_offsetmapdialog.h:        OffsetMapDialog->setEnabled(true);
ui_offsetmapdialog.h:        OffsetMapDialog->resize(238, 212);
ui_offsetmapdialog.h:        OffsetMapDialog->setAutoFillBackground(false);
ui_offsetmapdialog.h:        verticalLayout_5->setObjectName(QStringLiteral("verticalLayout_5"));
ui_offsetmapdialog.h:        verticalLayout_5->setSizeConstraint(QLayout::SetFixedSize);
ui_offsetmapdialog.h:        offsetGroup->setObjectName(QStringLiteral("offsetGroup"));
ui_offsetmapdialog.h:        gridLayout->setObjectName(QStringLiteral("gridLayout"));
ui_offsetmapdialog.h:        labelX->setObjectName(QStringLiteral("labelX"));
ui_offsetmapdialog.h:        gridLayout->addWidget(labelX, 2, 0, 1, 1);
ui_offsetmapdialog.h:        xOffset->setObjectName(QStringLiteral("xOffset"));
ui_offsetmapdialog.h:        xOffset->setEnabled(true);
ui_offsetmapdialog.h:        xOffset->setMinimum(-999);
ui_offsetmapdialog.h:        xOffset->setMaximum(999);
ui_offsetmapdialog.h:        xOffset->setValue(0);
ui_offsetmapdialog.h:        gridLayout->addWidget(xOffset, 2, 2, 1, 1);
ui_offsetmapdialog.h:        wrapX->setObjectName(QStringLiteral("wrapX"));
ui_offsetmapdialog.h:        gridLayout->addWidget(wrapX, 2, 3, 1, 1);
ui_offsetmapdialog.h:        labelY->setObjectName(QStringLiteral("labelY"));
ui_offsetmapdialog.h:        gridLayout->addWidget(labelY, 4, 0, 1, 1);
ui_offsetmapdialog.h:        gridLayout->addItem(horizontalSpacer, 4, 1, 1, 1);
ui_offsetmapdialog.h:        yOffset->setObjectName(QStringLiteral("yOffset"));
ui_offsetmapdialog.h:        yOffset->setMinimum(-999);
ui_offsetmapdialog.h:        yOffset->setMaximum(999);
ui_offsetmapdialog.h:        yOffset->setValue(0);
ui_offsetmapdialog.h:        gridLayout->addWidget(yOffset, 4, 2, 1, 1);
ui_offsetmapdialog.h:        wrapY->setObjectName(QStringLiteral("wrapY"));
ui_offsetmapdialog.h:        gridLayout->addWidget(wrapY, 4, 3, 1, 1);
ui_offsetmapdialog.h:        labelLayers->setObjectName(QStringLiteral("labelLayers"));
ui_offsetmapdialog.h:        gridLayout->addWidget(labelLayers, 5, 0, 1, 1);
ui_offsetmapdialog.h:        layerSelection->setObjectName(QStringLiteral("layerSelection"));
ui_offsetmapdialog.h:        gridLayout->addWidget(layerSelection, 5, 2, 1, 2);
ui_offsetmapdialog.h:        labelBounds->setObjectName(QStringLiteral("labelBounds"));
ui_offsetmapdialog.h:        gridLayout->addWidget(labelBounds, 6, 0, 1, 1);
ui_offsetmapdialog.h:        boundsSelection->setObjectName(QStringLiteral("boundsSelection"));
ui_offsetmapdialog.h:        gridLayout->addWidget(boundsSelection, 6, 2, 1, 2);
ui_offsetmapdialog.h:        verticalLayout_5->addWidget(offsetGroup);
ui_offsetmapdialog.h:        verticalLayout_5->addItem(verticalSpacer);
ui_offsetmapdialog.h:        buttonBox->setObjectName(QStringLiteral("buttonBox"));
ui_offsetmapdialog.h:        buttonBox->setOrientation(Qt::Horizontal);
ui_offsetmapdialog.h:        buttonBox->setStandardButtons(QDialogButtonBox::Cancel|QDialogButtonBox::Ok);
ui_offsetmapdialog.h:        verticalLayout_5->addWidget(buttonBox);
ui_offsetmapdialog.h:        OffsetMapDialog->setWindowTitle(QApplication::translate("OffsetMapDialog", "Offset Map", 0));
ui_offsetmapdialog.h:        offsetGroup->setTitle(QApplication::translate("OffsetMapDialog", "Offset Contents of Map", 0));
ui_offsetmapdialog.h:        labelX->setText(QApplication::translate("OffsetMapDialog", "X:", 0));
ui_offsetmapdialog.h:        wrapX->setText(QApplication::translate("OffsetMapDialog", "Wrap", 0));
ui_offsetmapdialog.h:        labelY->setText(QApplication::translate("OffsetMapDialog", "Y:", 0));
ui_offsetmapdialog.h:        wrapY->setText(QApplication::translate("OffsetMapDialog", "Wrap", 0));
ui_offsetmapdialog.h:        labelLayers->setText(QApplication::translate("OffsetMapDialog", "Layers:", 0));
ui_offsetmapdialog.h:        layerSelection->clear();
ui_offsetmapdialog.h:        layerSelection->insertItems(0, QStringList()
ui_offsetmapdialog.h:        labelBounds->setText(QApplication::translate("OffsetMapDialog", "Bounds:", 0));
ui_offsetmapdialog.h:        boundsSelection->clear();
ui_offsetmapdialog.h:        boundsSelection->insertItems(0, QStringList()
Binary file moc_resizehelper.o matches
Binary file tilestampmodel.o matches
Binary file moc_newmapdialog.o matches
changeproperties.h: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file editpolygontool.o matches
Binary file moc_layermodel.o matches
moc_resizedialog.cpp:        - idx * sizeof(QByteArrayData) \
moc_resizedialog.cpp:        case 0: _t->updateOffsetBounds((*reinterpret_cast< const QRect(*)>(_a[1]))); break;
moc_resizedialog.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_resizedialog.cpp:        _id -= 1;
moc_resizedialog.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_resizedialog.cpp:        _id -= 1;
erasetiles.cpp:    const QRegion r = mRegion.translated(-mTileLayer->x(), -mTileLayer->y());
erasetiles.cpp:    mErasedCells = mTileLayer->copy(r);
erasetiles.cpp:    if (!(mMapDocument == o->mMapDocument &&
erasetiles.cpp:          mTileLayer == o->mTileLayer &&
erasetiles.cpp:          o->mMergeable))
erasetiles.cpp:    const QRegion combinedRegion = mRegion.united(o->mRegion);
erasetiles.cpp:            const QPoint shift = bounds.topLeft() - combinedBounds.topLeft();
erasetiles.cpp:            mErasedCells->resize(combinedBounds.size(), shift);
erasetiles.cpp:        const QRect otherBounds = o->mRegion.boundingRect();
erasetiles.cpp:        const QPoint pos = otherBounds.topLeft() - combinedBounds.topLeft();
erasetiles.cpp:        mErasedCells->merge(pos, o->mErasedCells);
moc_tileselectionitem.cpp:        - idx * sizeof(QByteArrayData) \
moc_tileselectionitem.cpp:        case 0: _t->selectionChanged((*reinterpret_cast< const QRegion(*)>(_a[1])),(*reinterpret_cast< const QRegion(*)>(_a[2]))); break;
moc_tileselectionitem.cpp:        case 1: _t->currentLayerIndexChanged(); break;
moc_tileselectionitem.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tileselectionitem.cpp:        _id -= 2;
moc_tileselectionitem.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tileselectionitem.cpp:        _id -= 2;
Makefile:# Command: /usr/lib/i386-linux-gnu/qt5/bin/qmake -o Makefile tiled.pro
Makefile:DEFINES       = -DQT_NO_CAST_FROM_ASCII -DQT_NO_CAST_TO_ASCII -DQT_NO_DEBUG -DQT_OPENGL_LIB -DQT_WIDGETS_LIB -DQT_GUI_LIB -DQT_CORE_LIB
Makefile:CFLAGS        = -pipe -O2 -Wall -W -D_REENTRANT -fPIE $(DEFINES)
Makefile:CXXFLAGS      = -pipe -O2 -std=c++0x -Wall -W -D_REENTRANT -fPIE $(DEFINES)
Makefile:INCPATH       = -I/usr/lib/i386-linux-gnu/qt5/mkspecs/linux-g++ -I. -I../libtiled -I../qtpropertybrowser/src -I/usr/include/qt5 -I/usr/include/qt5/QtOpenGL -I/usr/include/qt5/QtWidgets -I/usr/include/qt5/QtGui -I/usr/include/qt5/QtCore -I. -I.
Makefile:LFLAGS        = -Wl,-z,origin '-Wl,-rpath,$$ORIGIN/../lib' -Wl,-O1
Makefile:LIBS          = $(SUBLIBS) -L/home/student/tiled/src/tiled/../../lib -ltiled -lQt5OpenGL -L/usr/lib/i386-linux-gnu -lQt5Widgets -lQt5Gui -lQt5Core -lGL -lpthread 
Makefile:QMAKE         = /usr/lib/i386-linux-gnu/qt5/bin/qmake
Makefile:TAR           = tar -cf
Makefile:COMPRESS      = gzip -9f
Makefile:COPY          = cp -f
Makefile:COPY_FILE     = cp -f
Makefile:COPY_DIR      = cp -f -R
Makefile:INSTALL_FILE  = install -m 644 -p
Makefile:INSTALL_PROGRAM = install -m 755 -p
Makefile:DEL_FILE      = rm -f
Makefile:SYMLINK       = ln -f -s
Makefile:MOVE          = mv -f
Makefile:CHK_DIR_EXISTS= test -d
Makefile:MKDIR         = mkdir -p
Makefile:DIST          = /usr/lib/i386-linux-gnu/qt5/mkspecs/features/spec_pre.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/shell-unix.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/unix.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/linux.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/gcc-base.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/g++-base.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/g++-unix.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/qconfig.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_platformsupport_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/qt_functions.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/qt_config.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/spec_post.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/default_pre.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/resolve_config.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/default_post.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/c++11.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/unix/gdb_dwarf_index.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/warn_on.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/qt.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/resources.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/moc.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/unix/opengl.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/uic.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/unix/thread.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/testcase_targets.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/exceptions.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/yacc.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/lex.prf \
Makefile:DESTDIR       = ../../bin/#avoid trailing-slash linebreak
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o "$@" "$<"
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o "$@" "$<"
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o "$@" "$<"
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o "$@" "$<"
Makefile:	$(CC) -c $(CFLAGS) $(INCPATH) -o "$@" "$<"
Makefile:	@test -d ../../bin/ || mkdir -p ../../bin/
Makefile:	$(LINK) $(LFLAGS) -o $(TARGET) $(OBJECTS) $(OBJCOMP) $(LIBS)
Makefile:Makefile: tiled.pro /usr/lib/i386-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf /usr/lib/i386-linux-gnu/qt5/mkspecs/features/spec_pre.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/shell-unix.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/unix.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/linux.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/gcc-base.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/g++-base.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/common/g++-unix.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/qconfig.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_platformsupport_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/qt_functions.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/qt_config.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/spec_post.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/default_pre.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/resolve_config.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/default_post.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/c++11.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/unix/gdb_dwarf_index.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/warn_on.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/qt.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/resources.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/moc.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/unix/opengl.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/uic.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/unix/thread.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/testcase_targets.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/exceptions.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/yacc.prf \
Makefile:		/usr/lib/i386-linux-gnu/qt5/mkspecs/features/lex.prf \
Makefile:		/usr/lib/i386-linux-gnu/libQt5OpenGL.prl \
Makefile:		/usr/lib/i386-linux-gnu/libQt5Widgets.prl \
Makefile:		/usr/lib/i386-linux-gnu/libQt5Gui.prl \
Makefile:		/usr/lib/i386-linux-gnu/libQt5Core.prl
Makefile:	$(QMAKE) -o Makefile tiled.pro
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/spec_pre.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/common/shell-unix.conf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/common/unix.conf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/common/linux.conf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/common/gcc-base.conf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/common/gcc-base-unix.conf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/common/g++-base.conf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/common/g++-unix.conf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/qconfig.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_bootstrap_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_concurrent_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_core.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_core_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_dbus_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_gui.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_gui_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_network.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_network_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_opengl_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_openglextensions_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_platformsupport_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_printsupport_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_sql.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_sql_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_testlib_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_widgets_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_xml.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/modules/qt_lib_xml_private.pri:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/qt_functions.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/qt_config.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/linux-g++/qmake.conf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/spec_post.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/exclusive_builds.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/default_pre.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/resolve_config.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/default_post.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/c++11.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/unix/gdb_dwarf_index.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/warn_on.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/qt.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/resources.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/moc.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/unix/opengl.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/uic.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/unix/thread.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/testcase_targets.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/exceptions.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/yacc.prf:
Makefile:/usr/lib/i386-linux-gnu/qt5/mkspecs/features/lex.prf:
Makefile:/usr/lib/i386-linux-gnu/libQt5OpenGL.prl:
Makefile:/usr/lib/i386-linux-gnu/libQt5Widgets.prl:
Makefile:/usr/lib/i386-linux-gnu/libQt5Gui.prl:
Makefile:/usr/lib/i386-linux-gnu/libQt5Core.prl:
Makefile:	@$(QMAKE) -o Makefile tiled.pro
Makefile:	@test -d .tmp/tiled1.0.0 || mkdir -p .tmp/tiled1.0.0
Makefile:	$(COPY_FILE) --parents $(SOURCES) $(DIST) .tmp/tiled1.0.0/ && $(COPY_FILE) --parents ../qtpropertybrowser/src/qtpropertybrowser.qrc tiled.qrc .tmp/tiled1.0.0/ && $(COPY_FILE) --parents ../qtpropertybrowser/src/qtpropertybrowser.h ../qtpropertybrowser/src/qtpropertymanager.h ../qtpropertybrowser/src/qteditorfactory.h ../qtpropertybrowser/src/qtvariantproperty.h ../qtpropertybrowser/src/qttreepropertybrowser.h ../qtpropertybrowser/src/qtbuttonpropertybrowser.h ../qtpropertybrowser/src/qtgroupboxpropertybrowser.h ../qtpropertybrowser/src/qtpropertybrowserutils_p.h aboutdialog.h abstractimagetool.h abstractobjecttool.h abstracttiletool.h abstracttool.h addremovelayer.h addremovemapobject.h addremoveterrain.h addremovetiles.h addremovetileset.h automapper.h automapperwrapper.h automappingmanager.h automappingutils.h brushitem.h bucketfilltool.h changeimagelayerposition.h changeimagelayerproperties.h changelayer.h changemapobject.h changemapobjectsorder.h changemapproperty.h changeobjectgroupproperties.h changepolygon.h changeproperties.h changetileanimation.h changetileobjectgroup.h changetileprobability.h changeselectedarea.h changetileterrain.h clipboardmanager.h colorbutton.h containerhelpers.h commandbutton.h commanddatamodel.h commanddialog.h command.h commandlineparser.h consoledock.h createellipseobjecttool.h createmultipointobjecttool.h createobjecttool.h createpolygonobjecttool.h createpolylineobjecttool.h createrectangleobjecttool.h createscalableobjecttool.h createtileobjecttool.h documentmanager.h editpolygontool.h editterraindialog.h eraser.h erasetiles.h exportasimagedialog.h fileedit.h filesystemwatcher.h filltiles.h flipmapobjects.h geometry.h imagelayeritem.h imagemovementtool.h languagemanager.h layerdock.h layermodel.h macsupport.h mainwindow.h mapdocumentactionhandler.h mapdocument.h mapobjectitem.h mapobjectmodel.h mapscene.h mapsdock.h mapview.h minimap.h minimapdock.h movabletabwidget.h movelayer.h movemapobject.h movemapobjecttogroup.h movetileset.h newmapdialog.h newtilesetdialog.h objectgroupitem.h objectsdock.h objectselectionitem.h objectselectiontool.h objecttypes.h objecttypesmodel.h offsetlayer.h offsetmapdialog.h painttilelayer.h patreondialog.h preferencesdialog.h preferences.h propertiesdock.h propertybrowser.h raiselowerhelper.h randompicker.h rangeset.h renamelayer.h renameterrain.h resizedialog.h resizehelper.h resizemap.h resizemapobject.h resizetilelayer.h rotatemapobject.h selectionrectangle.h selectsametiletool.h snaphelper.h stampbrush.h terrainbrush.h terraindock.h terrainmodel.h terrainview.h thumbnailrenderer.h tileanimationdriver.h tileanimationeditor.h tilecollisioneditor.h tiledapplication.h tilelayeritem.h tilepainter.h tileselectionitem.h tileselectiontool.h tilesetchanges.h tilesetdock.h tilesetmanager.h tilesetmodel.h tilesetview.h tilestamp.h tilestampmanager.h tilestampmodel.h tilestampsdock.h tmxmapformat.h toolmanager.h undocommands.h undodock.h utils.h varianteditorfactory.h variantpropertymanager.h zoomable.h magicwandtool.h .tmp/tiled1.0.0/ && $(COPY_FILE) --parents ../qtpropertybrowser/src/qtpropertybrowser.cpp ../qtpropertybrowser/src/qtpropertymanager.cpp ../qtpropertybrowser/src/qteditorfactory.cpp ../qtpropertybrowser/src/qtvariantproperty.cpp ../qtpropertybrowser/src/qttreepropertybrowser.cpp ../qtpropertybrowser/src/qtbuttonpropertybrowser.cpp ../qtpropertybrowser/src/qtgroupboxpropertybrowser.cpp ../qtpropertybrowser/src/qtpropertybrowserutils.cpp aboutdialog.cpp abstractimagetool.cpp abstractobjecttool.cpp abstracttiletool.cpp abstracttool.cpp addremovelayer.cpp addremovemapobject.cpp addremoveterrain.cpp addremovetiles.cpp addremovetileset.cpp automapper.cpp automapperwrapper.cpp automappingmanager.cpp automappingutils.cpp brushitem.cpp bucketfilltool.cpp changeimagelayerposition.cpp changeimagelayerproperties.cpp changelayer.cpp changemapobject.cpp changemapobjectsorder.cpp changemapproperty.cpp changeobjectgroupproperties.cpp changepolygon.cpp changeproperties.cpp changetileanimation.cpp changetileobjectgroup.cpp changetileprobability.cpp changeselectedarea.cpp changetileterrain.cpp clipboardmanager.cpp colorbutton.cpp commandbutton.cpp command.cpp commanddatamodel.cpp commanddialog.cpp commandlineparser.cpp consoledock.cpp createellipseobjecttool.cpp createmultipointobjecttool.cpp createobjecttool.cpp createpolygonobjecttool.cpp createpolylineobjecttool.cpp createrectangleobjecttool.cpp createscalableobjecttool.cpp createtileobjecttool.cpp documentmanager.cpp editpolygontool.cpp editterraindialog.cpp eraser.cpp erasetiles.cpp exportasimagedialog.cpp fileedit.cpp filesystemwatcher.cpp filltiles.cpp flipmapobjects.cpp geometry.cpp imagelayeritem.cpp imagemovementtool.cpp languagemanager.cpp layerdock.cpp layermodel.cpp main.cpp mainwindow.cpp mapdocumentactionhandler.cpp mapdocument.cpp mapobjectitem.cpp mapobjectmodel.cpp mapscene.cpp mapsdock.cpp mapview.cpp minimap.cpp minimapdock.cpp movabletabwidget.cpp movelayer.cpp movemapobject.cpp movemapobjecttogroup.cpp movetileset.cpp newmapdialog.cpp newtilesetdialog.cpp objectgroupitem.cpp objectsdock.cpp objectselectionitem.cpp objectselectiontool.cpp objecttypes.cpp objecttypesmodel.cpp offsetlayer.cpp offsetmapdialog.cpp painttilelayer.cpp patreondialog.cpp preferences.cpp preferencesdialog.cpp propertiesdock.cpp propertybrowser.cpp raiselowerhelper.cpp renamelayer.cpp renameterrain.cpp resizedialog.cpp resizehelper.cpp resizemap.cpp resizemapobject.cpp resizetilelayer.cpp rotatemapobject.cpp selectionrectangle.cpp selectsametiletool.cpp snaphelper.cpp stampbrush.cpp terrainbrush.cpp terraindock.cpp terrainmodel.cpp terrainview.cpp thumbnailrenderer.cpp tileanimationdriver.cpp tileanimationeditor.cpp tilecollisioneditor.cpp tiledapplication.cpp tilelayeritem.cpp tilepainter.cpp tileselectionitem.cpp tileselectiontool.cpp tilesetchanges.cpp tilesetdock.cpp tilesetmanager.cpp tilesetmodel.cpp tilesetview.cpp tilestamp.cpp tilestampmanager.cpp tilestampmodel.cpp tilestampsdock.cpp tmxmapformat.cpp toolmanager.cpp undodock.cpp utils.cpp varianteditorfactory.cpp variantpropertymanager.cpp zoomable.cpp magicwandtool.cpp .tmp/tiled1.0.0/ && $(COPY_FILE) --parents aboutdialog.ui commanddialog.ui editterraindialog.ui exportasimagedialog.ui mainwindow.ui newmapdialog.ui newtilesetdialog.ui offsetmapdialog.ui patreondialog.ui preferencesdialog.ui resizedialog.ui tileanimationeditor.ui .tmp/tiled1.0.0/ && (cd `dirname .tmp/tiled1.0.0` && $(TAR) tiled1.0.0.tar tiled1.0.0 && $(COMPRESS) tiled1.0.0.tar) && $(MOVE) `dirname .tmp/tiled1.0.0`/tiled1.0.0.tar.gz . && $(DEL_FILE) -r .tmp/tiled1.0.0
Makefile:	-$(DEL_FILE) $(OBJECTS)
Makefile:	-$(DEL_FILE) *~ core *.core
Makefile:####### Sub-libraries
Makefile:	-$(DEL_FILE) ../../bin/$(TARGET) 
Makefile:	-$(DEL_FILE) Makefile
Makefile:	-$(DEL_FILE) qrc_qtpropertybrowser.cpp qrc_tiled.cpp
Makefile:		../qtpropertybrowser/src/images/cursor-sizev.png \
Makefile:		../qtpropertybrowser/src/images/cursor-wait.png \
Makefile:		../qtpropertybrowser/src/images/cursor-forbidden.png \
Makefile:		../qtpropertybrowser/src/images/cursor-vsplit.png \
Makefile:		../qtpropertybrowser/src/images/cursor-arrow.png \
Makefile:		../qtpropertybrowser/src/images/cursor-busy.png \
Makefile:		../qtpropertybrowser/src/images/cursor-hsplit.png \
Makefile:		../qtpropertybrowser/src/images/cursor-sizeb.png \
Makefile:		../qtpropertybrowser/src/images/cursor-sizeall.png \
Makefile:		../qtpropertybrowser/src/images/cursor-hand.png \
Makefile:		../qtpropertybrowser/src/images/cursor-ibeam.png \
Makefile:		../qtpropertybrowser/src/images/cursor-sizef.png \
Makefile:		../qtpropertybrowser/src/images/cursor-cross.png \
Makefile:		../qtpropertybrowser/src/images/cursor-sizeh.png \
Makefile:		../qtpropertybrowser/src/images/cursor-openhand.png \
Makefile:		../qtpropertybrowser/src/images/cursor-whatsthis.png \
Makefile:		../qtpropertybrowser/src/images/cursor-closedhand.png \
Makefile:		../qtpropertybrowser/src/images/cursor-uparrow.png
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/rcc -name qtpropertybrowser ../qtpropertybrowser/src/qtpropertybrowser.qrc -o qrc_qtpropertybrowser.cpp
Makefile:		images/about-tiled-logo.png \
Makefile:		images/16x16/zoom-out.png \
Makefile:		images/16x16/edit-delete.png \
Makefile:		images/16x16/edit-undo.png \
Makefile:		images/16x16/layer-image.png \
Makefile:		images/16x16/document-new.png \
Makefile:		images/16x16/document-open-recent.png \
Makefile:		images/16x16/help-about.png \
Makefile:		images/16x16/document-page-setup.png \
Makefile:		images/16x16/layer-object.png \
Makefile:		images/16x16/zoom-original.png \
Makefile:		images/16x16/edit-copy.png \
Makefile:		images/16x16/document-save.png \
Makefile:		images/16x16/go-down.png \
Makefile:		images/16x16/application-exit.png \
Makefile:		images/16x16/drive-harddisk.png \
Makefile:		images/16x16/edit-cut.png \
Makefile:		images/16x16/layer-tile.png \
Makefile:		images/16x16/stock-duplicate-16.png \
Makefile:		images/16x16/edit-redo.png \
Makefile:		images/16x16/window-close.png \
Makefile:		images/16x16/document-export.png \
Makefile:		images/16x16/document-open.png \
Makefile:		images/16x16/go-up.png \
Makefile:		images/16x16/document-import.png \
Makefile:		images/16x16/edit-paste.png \
Makefile:		images/16x16/terminal-green.png \
Makefile:		images/16x16/document-save-as.png \
Makefile:		images/16x16/terminal-red.png \
Makefile:		images/16x16/document-properties.png \
Makefile:		images/16x16/zoom-in.png \
Makefile:		images/16x16/edit-clear.png \
Makefile:		images/22x22/stock-tool-by-color-select.png \
Makefile:		images/22x22/stock-tool-rect-select.png \
Makefile:		images/22x22/stock-tool-eraser.png \
Makefile:		images/22x22/stock-tool-clone.png \
Makefile:		images/22x22/tool-select-objects.png \
Makefile:		images/22x22/stock-tool-bucket-fill.png \
Makefile:		images/22x22/stock-tool-fuzzy-select-22.png \
Makefile:		images/24x24/go-up.png \
Makefile:		images/24x24/insert-polygon.png \
Makefile:		images/24x24/document-open.png \
Makefile:		images/24x24/edit-redo.png \
Makefile:		images/24x24/insert-image.png \
Makefile:		images/24x24/zoom-out.png \
Makefile:		images/24x24/edit-clear.png \
Makefile:		images/24x24/terrain-edit.png \
Makefile:		images/24x24/insert-ellipse.png \
Makefile:		images/24x24/edit-paste.png \
Makefile:		images/24x24/drive-harddisk.png \
Makefile:		images/24x24/go-down.png \
Makefile:		images/24x24/edit-undo.png \
Makefile:		images/24x24/zoom-in.png \
Makefile:		images/24x24/insert-rectangle.png \
Makefile:		images/24x24/insert-polyline.png \
Makefile:		images/24x24/move-image-layer.png \
Makefile:		images/24x24/document-save-as.png \
Makefile:		images/24x24/edit-copy.png \
Makefile:		images/24x24/zoom-original.png \
Makefile:		images/24x24/document-new.png \
Makefile:		images/24x24/document-open-recent.png \
Makefile:		images/24x24/tool-edit-polygons.png \
Makefile:		images/24x24/help-about.png \
Makefile:		images/24x24/document-page-setup.png \
Makefile:		images/24x24/document-save.png \
Makefile:		images/24x24/insert-object.png \
Makefile:		images/24x24/document-properties.png \
Makefile:		images/24x24/system-run.png \
Makefile:		images/24x24/edit-cut.png
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/rcc -name tiled tiled.qrc -o qrc_tiled.cpp
Makefile:	-$(DEL_FILE) moc_qtpropertybrowser.cpp moc_qtpropertymanager.cpp moc_qteditorfactory.cpp moc_qtvariantproperty.cpp moc_qttreepropertybrowser.cpp moc_qtbuttonpropertybrowser.cpp moc_qtgroupboxpropertybrowser.cpp moc_qtpropertybrowserutils_p.cpp moc_aboutdialog.cpp moc_abstractimagetool.cpp moc_abstractobjecttool.cpp moc_abstracttiletool.cpp moc_abstracttool.cpp moc_automapper.cpp moc_automappingmanager.cpp moc_bucketfilltool.cpp moc_clipboardmanager.cpp moc_colorbutton.cpp moc_commandbutton.cpp moc_commanddatamodel.cpp moc_commanddialog.cpp moc_command.cpp moc_consoledock.cpp moc_createellipseobjecttool.cpp moc_createmultipointobjecttool.cpp moc_createobjecttool.cpp moc_createpolygonobjecttool.cpp moc_createpolylineobjecttool.cpp moc_createrectangleobjecttool.cpp moc_createscalableobjecttool.cpp moc_createtileobjecttool.cpp moc_documentmanager.cpp moc_editpolygontool.cpp moc_editterraindialog.cpp moc_eraser.cpp moc_exportasimagedialog.cpp moc_fileedit.cpp moc_filesystemwatcher.cpp moc_imagemovementtool.cpp moc_layerdock.cpp moc_layermodel.cpp moc_mainwindow.cpp moc_mapdocumentactionhandler.cpp moc_mapdocument.cpp moc_mapobjectmodel.cpp moc_mapscene.cpp moc_mapsdock.cpp moc_mapview.cpp moc_minimap.cpp moc_minimapdock.cpp moc_movabletabwidget.cpp moc_newmapdialog.cpp moc_newtilesetdialog.cpp moc_objectsdock.cpp moc_objectselectionitem.cpp moc_objectselectiontool.cpp moc_objecttypesmodel.cpp moc_offsetmapdialog.cpp moc_patreondialog.cpp moc_preferencesdialog.cpp moc_preferences.cpp moc_propertiesdock.cpp moc_propertybrowser.cpp moc_resizedialog.cpp moc_resizehelper.cpp moc_selectsametiletool.cpp moc_stampbrush.cpp moc_terrainbrush.cpp moc_terraindock.cpp moc_terrainmodel.cpp moc_terrainview.cpp moc_tileanimationdriver.cpp moc_tileanimationeditor.cpp moc_tilecollisioneditor.cpp moc_tiledapplication.cpp moc_tileselectionitem.cpp moc_tileselectiontool.cpp moc_tilesetdock.cpp moc_tilesetmanager.cpp moc_tilesetmodel.cpp moc_tilesetview.cpp moc_tilestampmanager.cpp moc_tilestampmodel.cpp moc_tilestampsdock.cpp
Makefile:	-$(DEL_FILE) moc_tmxmapformat.cpp moc_toolmanager.cpp moc_undodock.cpp moc_varianteditorfactory.cpp moc_variantpropertymanager.cpp moc_zoomable.cpp moc_magicwandtool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include ../qtpropertybrowser/src/qtpropertybrowser.h -o moc_qtpropertybrowser.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include ../qtpropertybrowser/src/qtpropertymanager.h -o moc_qtpropertymanager.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include ../qtpropertybrowser/src/qteditorfactory.h -o moc_qteditorfactory.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include ../qtpropertybrowser/src/qtvariantproperty.h -o moc_qtvariantproperty.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include ../qtpropertybrowser/src/qttreepropertybrowser.h -o moc_qttreepropertybrowser.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include ../qtpropertybrowser/src/qtbuttonpropertybrowser.h -o moc_qtbuttonpropertybrowser.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include ../qtpropertybrowser/src/qtgroupboxpropertybrowser.h -o moc_qtgroupboxpropertybrowser.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include ../qtpropertybrowser/src/qtpropertybrowserutils_p.h -o moc_qtpropertybrowserutils_p.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include aboutdialog.h -o moc_aboutdialog.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include abstractimagetool.h -o moc_abstractimagetool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include abstractobjecttool.h -o moc_abstractobjecttool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include abstracttiletool.h -o moc_abstracttiletool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include abstracttool.h -o moc_abstracttool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include automapper.h -o moc_automapper.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include automappingmanager.h -o moc_automappingmanager.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include bucketfilltool.h -o moc_bucketfilltool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include clipboardmanager.h -o moc_clipboardmanager.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include colorbutton.h -o moc_colorbutton.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include commandbutton.h -o moc_commandbutton.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include commanddatamodel.h -o moc_commanddatamodel.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include commanddialog.h -o moc_commanddialog.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include command.h -o moc_command.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include consoledock.h -o moc_consoledock.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include createellipseobjecttool.h -o moc_createellipseobjecttool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include createmultipointobjecttool.h -o moc_createmultipointobjecttool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include createobjecttool.h -o moc_createobjecttool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include createpolygonobjecttool.h -o moc_createpolygonobjecttool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include createpolylineobjecttool.h -o moc_createpolylineobjecttool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include createrectangleobjecttool.h -o moc_createrectangleobjecttool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include createscalableobjecttool.h -o moc_createscalableobjecttool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include createtileobjecttool.h -o moc_createtileobjecttool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include documentmanager.h -o moc_documentmanager.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include editpolygontool.h -o moc_editpolygontool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include editterraindialog.h -o moc_editterraindialog.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include eraser.h -o moc_eraser.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include exportasimagedialog.h -o moc_exportasimagedialog.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include fileedit.h -o moc_fileedit.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include filesystemwatcher.h -o moc_filesystemwatcher.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include imagemovementtool.h -o moc_imagemovementtool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include layerdock.h -o moc_layerdock.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include layermodel.h -o moc_layermodel.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include mainwindow.h -o moc_mainwindow.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include mapdocumentactionhandler.h -o moc_mapdocumentactionhandler.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include mapdocument.h -o moc_mapdocument.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include mapobjectmodel.h -o moc_mapobjectmodel.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include mapscene.h -o moc_mapscene.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include mapsdock.h -o moc_mapsdock.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include mapview.h -o moc_mapview.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include minimap.h -o moc_minimap.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include minimapdock.h -o moc_minimapdock.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include movabletabwidget.h -o moc_movabletabwidget.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include newmapdialog.h -o moc_newmapdialog.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include newtilesetdialog.h -o moc_newtilesetdialog.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include objectsdock.h -o moc_objectsdock.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include objectselectionitem.h -o moc_objectselectionitem.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include objectselectiontool.h -o moc_objectselectiontool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include objecttypesmodel.h -o moc_objecttypesmodel.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include offsetmapdialog.h -o moc_offsetmapdialog.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include patreondialog.h -o moc_patreondialog.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include preferencesdialog.h -o moc_preferencesdialog.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include preferences.h -o moc_preferences.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include propertiesdock.h -o moc_propertiesdock.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include propertybrowser.h -o moc_propertybrowser.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include resizedialog.h -o moc_resizedialog.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include resizehelper.h -o moc_resizehelper.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include selectsametiletool.h -o moc_selectsametiletool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include stampbrush.h -o moc_stampbrush.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include terrainbrush.h -o moc_terrainbrush.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include terraindock.h -o moc_terraindock.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include terrainmodel.h -o moc_terrainmodel.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include terrainview.h -o moc_terrainview.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tileanimationdriver.h -o moc_tileanimationdriver.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tileanimationeditor.h -o moc_tileanimationeditor.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tilecollisioneditor.h -o moc_tilecollisioneditor.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tiledapplication.h -o moc_tiledapplication.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tileselectionitem.h -o moc_tileselectionitem.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tileselectiontool.h -o moc_tileselectiontool.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tilesetdock.h -o moc_tilesetdock.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tilesetmanager.h -o moc_tilesetmanager.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tilesetmodel.h -o moc_tilesetmodel.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tilesetview.h -o moc_tilesetview.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tilestampmanager.h -o moc_tilestampmanager.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tilestampmodel.h -o moc_tilestampmodel.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tilestampsdock.h -o moc_tilestampsdock.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tmxmapformat.h -o moc_tmxmapformat.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include toolmanager.h -o moc_toolmanager.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include undodock.h -o moc_undodock.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include varianteditorfactory.h -o moc_varianteditorfactory.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include variantpropertymanager.h -o moc_variantpropertymanager.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include zoomable.h -o moc_zoomable.cpp
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include magicwandtool.h -o moc_magicwandtool.cpp
Makefile:	-$(DEL_FILE) qtpropertymanager.moc qteditorfactory.moc qttreepropertybrowser.moc documentmanager.moc tileanimationeditor.moc
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include ../qtpropertybrowser/src/qtpropertymanager.cpp -o qtpropertymanager.moc
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include ../qtpropertybrowser/src/qteditorfactory.cpp -o qteditorfactory.moc
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include ../qtpropertybrowser/src/qttreepropertybrowser.cpp -o qttreepropertybrowser.moc
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include documentmanager.cpp -o documentmanager.moc
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/moc $(DEFINES) $(INCPATH) -I/usr/include/c++/4.8 -I/usr/include/i386-linux-gnu/c++/4.8 -I/usr/include/c++/4.8/backward -I/usr/lib/gcc/i686-linux-gnu/4.8/include -I/usr/local/include -I/usr/lib/gcc/i686-linux-gnu/4.8/include-fixed -I/usr/include/i386-linux-gnu -I/usr/include tileanimationeditor.cpp -o tileanimationeditor.moc
Makefile:	-$(DEL_FILE) ui_aboutdialog.h ui_commanddialog.h ui_editterraindialog.h ui_exportasimagedialog.h ui_mainwindow.h ui_newmapdialog.h ui_newtilesetdialog.h ui_offsetmapdialog.h ui_patreondialog.h ui_preferencesdialog.h ui_resizedialog.h ui_tileanimationeditor.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic aboutdialog.ui -o ui_aboutdialog.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic commanddialog.ui -o ui_commanddialog.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic editterraindialog.ui -o ui_editterraindialog.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic exportasimagedialog.ui -o ui_exportasimagedialog.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic mainwindow.ui -o ui_mainwindow.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic newmapdialog.ui -o ui_newmapdialog.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic newtilesetdialog.ui -o ui_newtilesetdialog.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic offsetmapdialog.ui -o ui_offsetmapdialog.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic patreondialog.ui -o ui_patreondialog.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic preferencesdialog.ui -o ui_preferencesdialog.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic resizedialog.ui -o ui_resizedialog.h
Makefile:	/usr/lib/i386-linux-gnu/qt5/bin/uic tileanimationeditor.ui -o ui_tileanimationeditor.h
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o qtpropertybrowser.o ../qtpropertybrowser/src/qtpropertybrowser.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o qtpropertymanager.o ../qtpropertybrowser/src/qtpropertymanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o qteditorfactory.o ../qtpropertybrowser/src/qteditorfactory.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o qtvariantproperty.o ../qtpropertybrowser/src/qtvariantproperty.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o qttreepropertybrowser.o ../qtpropertybrowser/src/qttreepropertybrowser.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o qtbuttonpropertybrowser.o ../qtpropertybrowser/src/qtbuttonpropertybrowser.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o qtgroupboxpropertybrowser.o ../qtpropertybrowser/src/qtgroupboxpropertybrowser.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o qtpropertybrowserutils.o ../qtpropertybrowser/src/qtpropertybrowserutils.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o aboutdialog.o aboutdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o abstractimagetool.o abstractimagetool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o abstractobjecttool.o abstractobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o abstracttiletool.o abstracttiletool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o abstracttool.o abstracttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o addremovelayer.o addremovelayer.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o addremovemapobject.o addremovemapobject.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o addremoveterrain.o addremoveterrain.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o addremovetiles.o addremovetiles.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o addremovetileset.o addremovetileset.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o automapper.o automapper.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o automapperwrapper.o automapperwrapper.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o automappingmanager.o automappingmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o automappingutils.o automappingutils.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o brushitem.o brushitem.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o bucketfilltool.o bucketfilltool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changeimagelayerposition.o changeimagelayerposition.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changeimagelayerproperties.o changeimagelayerproperties.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changelayer.o changelayer.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changemapobject.o changemapobject.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changemapobjectsorder.o changemapobjectsorder.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changemapproperty.o changemapproperty.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changeobjectgroupproperties.o changeobjectgroupproperties.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changepolygon.o changepolygon.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changeproperties.o changeproperties.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changetileanimation.o changetileanimation.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changetileobjectgroup.o changetileobjectgroup.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changetileprobability.o changetileprobability.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changeselectedarea.o changeselectedarea.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o changetileterrain.o changetileterrain.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o clipboardmanager.o clipboardmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o colorbutton.o colorbutton.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o commandbutton.o commandbutton.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o command.o command.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o commanddatamodel.o commanddatamodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o commanddialog.o commanddialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o commandlineparser.o commandlineparser.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o consoledock.o consoledock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o createellipseobjecttool.o createellipseobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o createmultipointobjecttool.o createmultipointobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o createobjecttool.o createobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o createpolygonobjecttool.o createpolygonobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o createpolylineobjecttool.o createpolylineobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o createrectangleobjecttool.o createrectangleobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o createscalableobjecttool.o createscalableobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o createtileobjecttool.o createtileobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o documentmanager.o documentmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o editpolygontool.o editpolygontool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o editterraindialog.o editterraindialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o eraser.o eraser.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o erasetiles.o erasetiles.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o exportasimagedialog.o exportasimagedialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o fileedit.o fileedit.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o filesystemwatcher.o filesystemwatcher.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o filltiles.o filltiles.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o flipmapobjects.o flipmapobjects.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o geometry.o geometry.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o imagelayeritem.o imagelayeritem.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o imagemovementtool.o imagemovementtool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o languagemanager.o languagemanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o layerdock.o layerdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o layermodel.o layermodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o main.o main.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o mainwindow.o mainwindow.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o mapdocumentactionhandler.o mapdocumentactionhandler.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o mapdocument.o mapdocument.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o mapobjectitem.o mapobjectitem.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o mapobjectmodel.o mapobjectmodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o mapscene.o mapscene.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o mapsdock.o mapsdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o mapview.o mapview.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o minimap.o minimap.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o minimapdock.o minimapdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o movabletabwidget.o movabletabwidget.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o movelayer.o movelayer.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o movemapobject.o movemapobject.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o movemapobjecttogroup.o movemapobjecttogroup.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o movetileset.o movetileset.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o newmapdialog.o newmapdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o newtilesetdialog.o newtilesetdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o objectgroupitem.o objectgroupitem.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o objectsdock.o objectsdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o objectselectionitem.o objectselectionitem.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o objectselectiontool.o objectselectiontool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o objecttypes.o objecttypes.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o objecttypesmodel.o objecttypesmodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o offsetlayer.o offsetlayer.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o offsetmapdialog.o offsetmapdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o painttilelayer.o painttilelayer.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o patreondialog.o patreondialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o preferences.o preferences.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o preferencesdialog.o preferencesdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o propertiesdock.o propertiesdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o propertybrowser.o propertybrowser.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o raiselowerhelper.o raiselowerhelper.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o renamelayer.o renamelayer.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o renameterrain.o renameterrain.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o resizedialog.o resizedialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o resizehelper.o resizehelper.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o resizemap.o resizemap.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o resizemapobject.o resizemapobject.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o resizetilelayer.o resizetilelayer.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o rotatemapobject.o rotatemapobject.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o selectionrectangle.o selectionrectangle.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o selectsametiletool.o selectsametiletool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o snaphelper.o snaphelper.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o stampbrush.o stampbrush.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o terrainbrush.o terrainbrush.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o terraindock.o terraindock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o terrainmodel.o terrainmodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o terrainview.o terrainview.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o thumbnailrenderer.o thumbnailrenderer.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tileanimationdriver.o tileanimationdriver.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tileanimationeditor.o tileanimationeditor.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilecollisioneditor.o tilecollisioneditor.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tiledapplication.o tiledapplication.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilelayeritem.o tilelayeritem.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilepainter.o tilepainter.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tileselectionitem.o tileselectionitem.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tileselectiontool.o tileselectiontool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilesetchanges.o tilesetchanges.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilesetdock.o tilesetdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilesetmanager.o tilesetmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilesetmodel.o tilesetmodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilesetview.o tilesetview.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilestamp.o tilestamp.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilestampmanager.o tilestampmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilestampmodel.o tilestampmodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tilestampsdock.o tilestampsdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o tmxmapformat.o tmxmapformat.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o toolmanager.o toolmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o undodock.o undodock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o utils.o utils.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o varianteditorfactory.o varianteditorfactory.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o variantpropertymanager.o variantpropertymanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o zoomable.o zoomable.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o magicwandtool.o magicwandtool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o qrc_qtpropertybrowser.o qrc_qtpropertybrowser.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o qrc_tiled.o qrc_tiled.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_qtpropertybrowserutils_p.o moc_qtpropertybrowserutils_p.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_aboutdialog.o moc_aboutdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_abstractimagetool.o moc_abstractimagetool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_abstractobjecttool.o moc_abstractobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_abstracttiletool.o moc_abstracttiletool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_abstracttool.o moc_abstracttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_automapper.o moc_automapper.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_automappingmanager.o moc_automappingmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_bucketfilltool.o moc_bucketfilltool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_clipboardmanager.o moc_clipboardmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_colorbutton.o moc_colorbutton.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_commandbutton.o moc_commandbutton.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_commanddatamodel.o moc_commanddatamodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_commanddialog.o moc_commanddialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_command.o moc_command.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_consoledock.o moc_consoledock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_createellipseobjecttool.o moc_createellipseobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_createmultipointobjecttool.o moc_createmultipointobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_createobjecttool.o moc_createobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_createpolygonobjecttool.o moc_createpolygonobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_createpolylineobjecttool.o moc_createpolylineobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_createrectangleobjecttool.o moc_createrectangleobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_createscalableobjecttool.o moc_createscalableobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_createtileobjecttool.o moc_createtileobjecttool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_documentmanager.o moc_documentmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_editpolygontool.o moc_editpolygontool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_editterraindialog.o moc_editterraindialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_eraser.o moc_eraser.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_exportasimagedialog.o moc_exportasimagedialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_fileedit.o moc_fileedit.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_filesystemwatcher.o moc_filesystemwatcher.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_imagemovementtool.o moc_imagemovementtool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_layerdock.o moc_layerdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_layermodel.o moc_layermodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_mainwindow.o moc_mainwindow.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_mapdocumentactionhandler.o moc_mapdocumentactionhandler.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_mapdocument.o moc_mapdocument.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_mapobjectmodel.o moc_mapobjectmodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_mapscene.o moc_mapscene.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_mapsdock.o moc_mapsdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_mapview.o moc_mapview.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_minimap.o moc_minimap.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_minimapdock.o moc_minimapdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_movabletabwidget.o moc_movabletabwidget.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_newmapdialog.o moc_newmapdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_newtilesetdialog.o moc_newtilesetdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_objectsdock.o moc_objectsdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_objectselectionitem.o moc_objectselectionitem.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_objectselectiontool.o moc_objectselectiontool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_objecttypesmodel.o moc_objecttypesmodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_offsetmapdialog.o moc_offsetmapdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_patreondialog.o moc_patreondialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_preferencesdialog.o moc_preferencesdialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_preferences.o moc_preferences.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_propertiesdock.o moc_propertiesdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_propertybrowser.o moc_propertybrowser.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_resizedialog.o moc_resizedialog.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_resizehelper.o moc_resizehelper.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_selectsametiletool.o moc_selectsametiletool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_stampbrush.o moc_stampbrush.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_terrainbrush.o moc_terrainbrush.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_terraindock.o moc_terraindock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_terrainmodel.o moc_terrainmodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_terrainview.o moc_terrainview.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tileanimationdriver.o moc_tileanimationdriver.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tileanimationeditor.o moc_tileanimationeditor.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tilecollisioneditor.o moc_tilecollisioneditor.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tiledapplication.o moc_tiledapplication.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tileselectionitem.o moc_tileselectionitem.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tileselectiontool.o moc_tileselectiontool.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tilesetdock.o moc_tilesetdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tilesetmanager.o moc_tilesetmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tilesetmodel.o moc_tilesetmodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tilesetview.o moc_tilesetview.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tilestampmanager.o moc_tilestampmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tilestampmodel.o moc_tilestampmodel.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tilestampsdock.o moc_tilestampsdock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_tmxmapformat.o moc_tmxmapformat.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_toolmanager.o moc_toolmanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_undodock.o moc_undodock.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_varianteditorfactory.o moc_varianteditorfactory.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_variantpropertymanager.o moc_variantpropertymanager.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_zoomable.o moc_zoomable.cpp
Makefile:	$(CXX) -c $(CXXFLAGS) $(INCPATH) -o moc_magicwandtool.o moc_magicwandtool.cpp
Makefile:	@test -d $(INSTALL_ROOT)/usr/local/bin || mkdir -p $(INSTALL_ROOT)/usr/local/bin
Makefile:	-$(INSTALL_PROGRAM) "../../bin/$(QMAKE_TARGET)" "$(INSTALL_ROOT)/usr/local/bin/$(QMAKE_TARGET)"
Makefile:	-$(STRIP) "$(INSTALL_ROOT)/usr/local/bin/$(QMAKE_TARGET)"
Makefile:	-$(DEL_FILE) "$(INSTALL_ROOT)/usr/local/bin/$(QMAKE_TARGET)"
Makefile:	-$(DEL_DIR) $(INSTALL_ROOT)/usr/local/bin/ 
Makefile:	@test -d $(INSTALL_ROOT)/usr/local/share/icons/hicolor/32x32/apps/ || mkdir -p $(INSTALL_ROOT)/usr/local/share/icons/hicolor/32x32/apps/
Makefile:	-$(INSTALL_FILE) /home/student/tiled/src/tiled/images/32x32/tiled.png $(INSTALL_ROOT)/usr/local/share/icons/hicolor/32x32/apps/
Makefile:	-$(DEL_FILE) -r $(INSTALL_ROOT)/usr/local/share/icons/hicolor/32x32/apps/tiled.png
Makefile:	-$(DEL_DIR) $(INSTALL_ROOT)/usr/local/share/icons/hicolor/32x32/apps/ 
Makefile:	@test -d $(INSTALL_ROOT)/usr/local/share/icons/hicolor/16x16/apps/ || mkdir -p $(INSTALL_ROOT)/usr/local/share/icons/hicolor/16x16/apps/
Makefile:	-$(INSTALL_FILE) /home/student/tiled/src/tiled/images/16x16/tiled.png $(INSTALL_ROOT)/usr/local/share/icons/hicolor/16x16/apps/
Makefile:	-$(DEL_FILE) -r $(INSTALL_ROOT)/usr/local/share/icons/hicolor/16x16/apps/tiled.png
Makefile:	-$(DEL_DIR) $(INSTALL_ROOT)/usr/local/share/icons/hicolor/16x16/apps/ 
Makefile:	@test -d $(INSTALL_ROOT)/usr/local/share/icons/hicolor/scalable/apps/ || mkdir -p $(INSTALL_ROOT)/usr/local/share/icons/hicolor/scalable/apps/
Makefile:	-$(INSTALL_FILE) /home/student/tiled/src/tiled/images/scalable/tiled.svg $(INSTALL_ROOT)/usr/local/share/icons/hicolor/scalable/apps/
Makefile:	-$(DEL_FILE) -r $(INSTALL_ROOT)/usr/local/share/icons/hicolor/scalable/apps/tiled.svg
Makefile:	-$(DEL_DIR) $(INSTALL_ROOT)/usr/local/share/icons/hicolor/scalable/apps/ 
Makefile:	@test -d $(INSTALL_ROOT)/usr/local/share/icons/hicolor/16x16/mimetypes/ || mkdir -p $(INSTALL_ROOT)/usr/local/share/icons/hicolor/16x16/mimetypes/
Makefile:	-$(INSTALL_FILE) /home/student/tiled/src/tiled/images/16x16/application-x-tiled.png $(INSTALL_ROOT)/usr/local/share/icons/hicolor/16x16/mimetypes/
Makefile:	-$(DEL_FILE) -r $(INSTALL_ROOT)/usr/local/share/icons/hicolor/16x16/mimetypes/application-x-tiled.png
Makefile:	-$(DEL_DIR) $(INSTALL_ROOT)/usr/local/share/icons/hicolor/16x16/mimetypes/ 
Makefile:	@test -d $(INSTALL_ROOT)/usr/local/share/icons/hicolor/32x32/mimetypes/ || mkdir -p $(INSTALL_ROOT)/usr/local/share/icons/hicolor/32x32/mimetypes/
Makefile:	-$(INSTALL_FILE) /home/student/tiled/src/tiled/images/32x32/application-x-tiled.png $(INSTALL_ROOT)/usr/local/share/icons/hicolor/32x32/mimetypes/
Makefile:	-$(DEL_FILE) -r $(INSTALL_ROOT)/usr/local/share/icons/hicolor/32x32/mimetypes/application-x-tiled.png
Makefile:	-$(DEL_DIR) $(INSTALL_ROOT)/usr/local/share/icons/hicolor/32x32/mimetypes/ 
Makefile:	@test -d $(INSTALL_ROOT)/usr/local/share/icons/hicolor/scalable/mimetypes/ || mkdir -p $(INSTALL_ROOT)/usr/local/share/icons/hicolor/scalable/mimetypes/
Makefile:	-$(INSTALL_FILE) /home/student/tiled/src/tiled/images/scalable/application-x-tiled.svg $(INSTALL_ROOT)/usr/local/share/icons/hicolor/scalable/mimetypes/
Makefile:	-$(DEL_FILE) -r $(INSTALL_ROOT)/usr/local/share/icons/hicolor/scalable/mimetypes/application-x-tiled.svg
Makefile:	-$(DEL_DIR) $(INSTALL_ROOT)/usr/local/share/icons/hicolor/scalable/mimetypes/ 
Makefile:	@test -d $(INSTALL_ROOT)/usr/local/share/mime/packages/ || mkdir -p $(INSTALL_ROOT)/usr/local/share/mime/packages/
Makefile:	-$(INSTALL_FILE) /home/student/tiled/mime/tiled.xml $(INSTALL_ROOT)/usr/local/share/mime/packages/
Makefile:	-$(DEL_FILE) -r $(INSTALL_ROOT)/usr/local/share/mime/packages/tiled.xml
Makefile:	-$(DEL_DIR) $(INSTALL_ROOT)/usr/local/share/mime/packages/ 
Makefile:	@test -d $(INSTALL_ROOT)/usr/local/share/applications/ || mkdir -p $(INSTALL_ROOT)/usr/local/share/applications/
Makefile:	-$(INSTALL_FILE) /home/student/tiled/tiled.desktop $(INSTALL_ROOT)/usr/local/share/applications/
Makefile:	-$(DEL_FILE) -r $(INSTALL_ROOT)/usr/local/share/applications/tiled.desktop
Makefile:	-$(DEL_DIR) $(INSTALL_ROOT)/usr/local/share/applications/ 
Makefile:	@test -d $(INSTALL_ROOT)/usr/local/share/man/man1/ || mkdir -p $(INSTALL_ROOT)/usr/local/share/man/man1/
Makefile:	-$(INSTALL_FILE) /home/student/tiled/man/tiled.1 $(INSTALL_ROOT)/usr/local/share/man/man1/
Makefile:	-$(DEL_FILE) -r $(INSTALL_ROOT)/usr/local/share/man/man1/tiled.1
Makefile:	-$(DEL_DIR) $(INSTALL_ROOT)/usr/local/share/man/man1/ 
Binary file clipboardmanager.o matches
Binary file moc_clipboardmanager.o matches
moc_preferences.cpp:        - idx * sizeof(QByteArrayData) \
moc_preferences.cpp:        case 0: _t->showGridChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 1: _t->showTileObjectOutlinesChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 2: _t->showTileAnimationsChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 3: _t->snapToGridChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 4: _t->snapToFineGridChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 5: _t->gridColorChanged((*reinterpret_cast< QColor(*)>(_a[1]))); break;
moc_preferences.cpp:        case 6: _t->gridFineChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_preferences.cpp:        case 7: _t->objectLineWidthChanged((*reinterpret_cast< qreal(*)>(_a[1]))); break;
moc_preferences.cpp:        case 8: _t->highlightCurrentLayerChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 9: _t->showTilesetGridChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 10: _t->objectLabelVisibilityChanged((*reinterpret_cast< ObjectLabelVisiblity(*)>(_a[1]))); break;
moc_preferences.cpp:        case 11: _t->useOpenGLChanged((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 12: _t->objectTypesChanged(); break;
moc_preferences.cpp:        case 13: _t->mapsDirectoryChanged(); break;
moc_preferences.cpp:        case 14: _t->stampsDirectoryChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_preferences.cpp:        case 15: _t->isPatronChanged(); break;
moc_preferences.cpp:        case 16: _t->setShowGrid((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 17: _t->setShowTileObjectOutlines((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 18: _t->setShowTileAnimations((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 19: _t->setSnapToGrid((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 20: _t->setSnapToFineGrid((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 21: _t->setGridColor((*reinterpret_cast< QColor(*)>(_a[1]))); break;
moc_preferences.cpp:        case 22: _t->setGridFine((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_preferences.cpp:        case 23: _t->setObjectLineWidth((*reinterpret_cast< qreal(*)>(_a[1]))); break;
moc_preferences.cpp:        case 24: _t->setHighlightCurrentLayer((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:        case 25: _t->setShowTilesetGrid((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_preferences.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_preferences.cpp:        _id -= 26;
moc_preferences.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_preferences.cpp:        _id -= 26;
changelayer.h: * Copyright 2012-2013, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
ui_patreondialog.h:        if (PatreonDialog->objectName().isEmpty())
ui_patreondialog.h:            PatreonDialog->setObjectName(QStringLiteral("PatreonDialog"));
ui_patreondialog.h:        PatreonDialog->resize(407, 360);
ui_patreondialog.h:        verticalLayout_2->setObjectName(QStringLiteral("verticalLayout_2"));
ui_patreondialog.h:        textBrowser->setObjectName(QStringLiteral("textBrowser"));
ui_patreondialog.h:        textBrowser->setStyleSheet(QStringLiteral(""));
ui_patreondialog.h:        verticalLayout_2->addWidget(textBrowser);
ui_patreondialog.h:        verticalLayout->setSpacing(0);
ui_patreondialog.h:        verticalLayout->setObjectName(QStringLiteral("verticalLayout"));
ui_patreondialog.h:        gotoPatreon->setObjectName(QStringLiteral("gotoPatreon"));
ui_patreondialog.h:        verticalLayout->addWidget(gotoPatreon);
ui_patreondialog.h:        alreadyPatron->setObjectName(QStringLiteral("alreadyPatron"));
ui_patreondialog.h:        verticalLayout->addWidget(alreadyPatron);
ui_patreondialog.h:        maybeLaterButton->setObjectName(QStringLiteral("maybeLaterButton"));
ui_patreondialog.h:        verticalLayout->addWidget(maybeLaterButton);
ui_patreondialog.h:        verticalLayout_2->addLayout(verticalLayout);
ui_patreondialog.h:        buttonBox->setObjectName(QStringLiteral("buttonBox"));
ui_patreondialog.h:        buttonBox->setOrientation(Qt::Horizontal);
ui_patreondialog.h:        buttonBox->setStandardButtons(QDialogButtonBox::Close);
ui_patreondialog.h:        verticalLayout_2->addWidget(buttonBox);
ui_patreondialog.h:        PatreonDialog->setWindowTitle(QApplication::translate("PatreonDialog", "Become a Patron", 0));
ui_patreondialog.h:        gotoPatreon->setText(QApplication::translate("PatreonDialog", "Visit https://www.patreon.com/bjorn", 0));
ui_patreondialog.h:        alreadyPatron->setText(QApplication::translate("PatreonDialog", "I'm already a patron!", 0));
ui_patreondialog.h:        maybeLaterButton->setText(QApplication::translate("PatreonDialog", "Maybe later", 0));
ui_aboutdialog.h:        if (AboutDialog->objectName().isEmpty())
ui_aboutdialog.h:            AboutDialog->setObjectName(QStringLiteral("AboutDialog"));
ui_aboutdialog.h:        AboutDialog->resize(432, 452);
ui_aboutdialog.h:        verticalLayout_3->setObjectName(QStringLiteral("verticalLayout_3"));
ui_aboutdialog.h:        verticalLayout_3->setSizeConstraint(QLayout::SetDefaultConstraint);
ui_aboutdialog.h:        logoLayout->setObjectName(QStringLiteral("logoLayout"));
ui_aboutdialog.h:        logoLayout->addItem(horizontalSpacer);
ui_aboutdialog.h:        logo->setObjectName(QStringLiteral("logo"));
ui_aboutdialog.h:        logo->setMinimumSize(QSize(400, 200));
ui_aboutdialog.h:        logo->setPixmap(QPixmap(QString::fromUtf8(":/images/about-tiled-logo.png")));
ui_aboutdialog.h:        logoLayout->addWidget(logo);
ui_aboutdialog.h:        logoLayout->addItem(horizontalSpacer_2);
ui_aboutdialog.h:        verticalLayout_3->addLayout(logoLayout);
ui_aboutdialog.h:        textBrowser->setObjectName(QStringLiteral("textBrowser"));
ui_aboutdialog.h:        textBrowser->setOpenExternalLinks(true);
ui_aboutdialog.h:        verticalLayout_3->addWidget(textBrowser);
ui_aboutdialog.h:        buttonLayout->setObjectName(QStringLiteral("buttonLayout"));
ui_aboutdialog.h:        buttonLayout->setSizeConstraint(QLayout::SetDefaultConstraint);
ui_aboutdialog.h:        buttonLayout->addItem(horizontalSpacer_3);
ui_aboutdialog.h:        donateButton->setObjectName(QStringLiteral("donateButton"));
ui_aboutdialog.h:        buttonLayout->addWidget(donateButton);
ui_aboutdialog.h:        pushButton->setObjectName(QStringLiteral("pushButton"));
ui_aboutdialog.h:        pushButton->setDefault(true);
ui_aboutdialog.h:        buttonLayout->addWidget(pushButton);
ui_aboutdialog.h:        verticalLayout_3->addLayout(buttonLayout);
ui_aboutdialog.h:        AboutDialog->setWindowTitle(QApplication::translate("AboutDialog", "About Tiled", 0));
ui_aboutdialog.h:        logo->setText(QString());
ui_aboutdialog.h:        donateButton->setText(QApplication::translate("AboutDialog", "Donate", 0));
ui_aboutdialog.h:        pushButton->setText(QApplication::translate("AboutDialog", "OK", 0));
Binary file variantpropertymanager.o matches
Binary file qtpropertymanager.o matches
mainwindow.h: * Copyright 2008-2015, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
mainwindow.h: * Copyright 2009-2010, Jeff Bland <jksb@member.fsf.org>
mainwindow.h: * Copyright 2010-2011, Stefan Beller <stefanbeller@googlemail.com>
Binary file qttreepropertybrowser.o matches
brushitem.h: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
createmultipointobjecttool.cpp:    mOverlayObjectGroup->addObject(mOverlayPolygonObject);
createmultipointobjecttool.cpp:    mOverlayObjectGroup->setColor(highlight);
createmultipointobjecttool.cpp:    const MapRenderer *renderer = mapDocument()->renderer();
createmultipointobjecttool.cpp:    QPointF pixelCoords = renderer->screenToPixelCoords(pos);
createmultipointobjecttool.cpp:    pixelCoords -= mNewMapObjectItem->mapObject()->position();
createmultipointobjecttool.cpp:    QPolygonF polygon = mOverlayPolygonObject->polygon();
createmultipointobjecttool.cpp:    mOverlayPolygonItem->setPolygon(polygon);
createmultipointobjecttool.cpp:    if (event->button() == Qt::RightButton) {
createmultipointobjecttool.cpp:    } else if (event->button() == Qt::LeftButton) {
createmultipointobjecttool.cpp:        QPolygonF current = mNewMapObjectItem->mapObject()->polygon();
createmultipointobjecttool.cpp:        QPolygonF next = mOverlayPolygonObject->polygon();
createmultipointobjecttool.cpp:        mNewMapObjectItem->setPolygon(next);
createmultipointobjecttool.cpp:        mOverlayPolygonItem->setPolygon(next);
createmultipointobjecttool.cpp:    MapObject *newMapObject = mNewMapObjectItem->mapObject();
createmultipointobjecttool.cpp:    newMapObject->setPolygon(polygon);
createmultipointobjecttool.cpp:    mOverlayPolygonObject->setPolygon(polygon);
createmultipointobjecttool.cpp:    mOverlayPolygonObject->setShape(newMapObject->shape());
createmultipointobjecttool.cpp:    mOverlayPolygonObject->setPosition(pos);
Binary file tileselectiontool.o matches
Binary file moc_magicwandtool.o matches
moc_qtgroupboxpropertybrowser.cpp:        - idx * sizeof(QByteArrayData) \
moc_qtgroupboxpropertybrowser.cpp:        case 0: _t->d_func()->slotUpdate(); break;
moc_qtgroupboxpropertybrowser.cpp:        case 1: _t->d_func()->slotEditorDestroyed(); break;
moc_qtgroupboxpropertybrowser.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_qtgroupboxpropertybrowser.cpp:        _id -= 2;
moc_qtgroupboxpropertybrowser.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_qtgroupboxpropertybrowser.cpp:        _id -= 2;
objectselectionitem.cpp:    r.translate(-alignmentOffset(r, alignment));
objectselectionitem.cpp:    if (!object->cell().isEmpty()) {
objectselectionitem.cpp:        const Tile *tile = object->cell().tile;
objectselectionitem.cpp:        const QSize imgSize = tile->image().size();
objectselectionitem.cpp:        const QPointF position = renderer->pixelToScreenCoords(object->position());
objectselectionitem.cpp:        const QPoint tileOffset = tile->tileset()->tileOffset();
objectselectionitem.cpp:        const QSizeF objectSize = object->size();
objectselectionitem.cpp:        align(bounds, object->alignment());
objectselectionitem.cpp:        switch (object->shape()) {
objectselectionitem.cpp:            QRectF bounds(object->bounds());
objectselectionitem.cpp:            align(bounds, object->alignment());
objectselectionitem.cpp:            QPolygonF screenPolygon = renderer->pixelToScreenCoords(bounds);
objectselectionitem.cpp:            const QPointF &pos = object->position();
objectselectionitem.cpp:            const QPolygonF polygon = object->polygon().translated(pos);
objectselectionitem.cpp:            QPolygonF screenPolygon = renderer->pixelToScreenCoords(polygon);
objectselectionitem.cpp:    const QPointF pixelPos = renderer->pixelToScreenCoords(mObject->position());
objectselectionitem.cpp:    bounds.translate(-pixelPos);
objectselectionitem.cpp:    setPos(pixelPos + mObject->objectGroup()->offset());
objectselectionitem.cpp:    setRotation(mObject->rotation());
objectselectionitem.cpp:    painter->setPen(dashPen);
objectselectionitem.cpp:    painter->drawLines(horizontal, 2);
objectselectionitem.cpp:    painter->setPen(dashPen);
objectselectionitem.cpp:    painter->drawLines(vertical, 2);
objectselectionitem.cpp:    const bool nameVisible = mObject->isVisible() && !mObject->name().isEmpty();
objectselectionitem.cpp:    QRectF boundingRect = metrics.boundingRect(mObject->name());
objectselectionitem.cpp:    boundingRect.translate(-boundingRect.width() / 2, -labelDistance);
objectselectionitem.cpp:    boundingRect.adjust(-labelMargin*2, -labelMargin, labelMargin*2, labelMargin);
objectselectionitem.cpp:    QPointF pixelPos = renderer->pixelToScreenCoords(mObject->position());
objectselectionitem.cpp:    transform.rotate(mObject->rotation());
objectselectionitem.cpp:    transform.translate(-pixelPos.x(), -pixelPos.y());
objectselectionitem.cpp:    setPos(pos + mObject->objectGroup()->offset());
objectselectionitem.cpp:    painter->setRenderHint(QPainter::Antialiasing);
objectselectionitem.cpp:    painter->setBrush(Qt::black);
objectselectionitem.cpp:    painter->setPen(Qt::NoPen);
objectselectionitem.cpp:    painter->drawRoundedRect(mBoundingRect.translated(1, 1), 4, 4);
objectselectionitem.cpp:    painter->setBrush(color);
objectselectionitem.cpp:    painter->drawRoundedRect(mBoundingRect, 4, 4);
objectselectionitem.cpp:    QPointF textPos(-(mBoundingRect.width() - labelMargin*4) / 2, -labelDistance);
objectselectionitem.cpp:    painter->drawRoundedRect(mBoundingRect, 4, 4);
objectselectionitem.cpp:    painter->setPen(Qt::black);
objectselectionitem.cpp:    painter->drawText(textPos + QPointF(1,1), mObject->name());
objectselectionitem.cpp:    painter->setPen(Qt::white);
objectselectionitem.cpp:    painter->drawText(textPos, mObject->name());
objectselectionitem.cpp:    if (Preferences::instance()->objectLabelVisibility() == Preferences::AllObjectLabels)
objectselectionitem.cpp:    syncOverlayItems(mMapDocument->selectedObjects());
objectselectionitem.cpp:    ObjectGroup *objectGroup = mMapDocument->map()->layerAt(index)->asObjectGroup();
objectselectionitem.cpp:    if (Preferences::instance()->objectLabelVisibility() == Preferences::AllObjectLabels)
objectselectionitem.cpp:    syncOverlayItems(objectGroup->objects());
objectselectionitem.cpp:    MapRenderer *renderer = mMapDocument->renderer();
objectselectionitem.cpp:            outlineItem->syncWithMapObject(renderer);
objectselectionitem.cpp:            labelItem->syncWithMapObject(renderer);
objectselectionitem.cpp:    MapRenderer *renderer = mMapDocument->renderer();
objectselectionitem.cpp:            labelItem->syncWithMapObject(renderer);
objectselectionitem.cpp:    switch (Preferences::instance()->objectLabelVisibility()) {
objectselectionitem.cpp:        for (Layer *layer : mMapDocument->map()->layers()) {
objectselectionitem.cpp:            if (!layer->isVisible())
objectselectionitem.cpp:            if (ObjectGroup *objectGroup = layer->asObjectGroup())
objectselectionitem.cpp:                for (MapObject *object : objectGroup->objects())
objectselectionitem.cpp:        for (MapObject *object : mMapDocument->selectedObjects())
objectselectionitem.cpp:    MapRenderer *renderer = mMapDocument->renderer();
objectselectionitem.cpp:    for (MapObject *mapObject : mMapDocument->selectedObjects()) {
objectselectionitem.cpp:            outlineItem->syncWithMapObject(renderer);
automapper.cpp: * Copyright 2010-2012, Stefan Beller, stefanbeller@googlemail.com
automapper.cpp:    , mMapWork(workingDocument ? workingDocument->map() : 0)
automapper.cpp:    Properties properties = mMapRules->properties();
automapper.cpp:    foreach (Layer *layer, mMapRules->layers()) {
automapper.cpp:        const QString layerName = layer->name();
automapper.cpp:                if (layer->isTileLayer()) {
automapper.cpp:                    mLayerInputRegions = layer->asTileLayer();
automapper.cpp:                if (layer->isTileLayer()) {
automapper.cpp:                    mLayerOutputRegions = layer->asTileLayer();
automapper.cpp:        QString name = layerName.right(layerName.size() - nameStartPosition);
automapper.cpp:            if (!layer->isTileLayer()) {
automapper.cpp:                mInputRules[index][name].listNo.append(layer->asTileLayer());
automapper.cpp:                mInputRules[index][name].listYes.append(layer->asTileLayer());
automapper.cpp:            if (layer->isTileLayer())
automapper.cpp:            Layer::TypeFlag type = layer->layerType();
automapper.cpp:            int layerIndex = mMapWork->indexOfLayer(name, type);
automapper.cpp:                if (translationTable->index == index) {
automapper.cpp:                    translationTable->insert(layer, layerIndex);
automapper.cpp:                mLayerList.last()->insert(layer, layerIndex);
automapper.cpp:                mLayerList.last()->index = index;
automapper.cpp:            mLayerInputRegions->region() +
automapper.cpp:            mLayerOutputRegions->region());
automapper.cpp:            mLayerInputRegions->region());
automapper.cpp:            mLayerOutputRegions->region());
automapper.cpp:        if (mMapWork->indexOfLayer(name, Layer::TileLayerType) != -1)
automapper.cpp:        const int index =  mMapWork->layerCount();
automapper.cpp:                                             mMapWork->width(),
automapper.cpp:                                             mMapWork->height());
automapper.cpp:        mMapDocument->undoStack()->push(
automapper.cpp:        if (mMapWork->indexOfLayer(name, Layer::ObjectGroupType) != -1)
automapper.cpp:        const int index =  mMapWork->layerCount();
automapper.cpp:                                                   mMapWork->width(),
automapper.cpp:                                                   mMapWork->height());
automapper.cpp:        mMapDocument->undoStack()->push(
automapper.cpp:        foreach (Layer *layerKey, translationTable->keys()) {
automapper.cpp:            QString name = layerKey->name();
automapper.cpp:            name = name.right(name.length() - pos);
automapper.cpp:            const int index = translationTable->value(layerKey, -1);
automapper.cpp:            if (index >= mMapWork->layerCount() || index == -1 ||
automapper.cpp:                    name != mMapWork->layerAt(index)->name()) {
automapper.cpp:                int newIndex = mMapWork->indexOfLayer(name, layerKey->layerType());
automapper.cpp:                Q_ASSERT(newIndex != -1);
automapper.cpp:                translationTable->insert(layerKey, newIndex);
automapper.cpp:    const QVector<SharedTileset> &existingTilesets = dst->tilesets();
automapper.cpp:    foreach (const SharedTileset &tileset, src->tilesets()) {
automapper.cpp:        QUndoStack *undoStack = mMapDocument->undoStack();
automapper.cpp:        SharedTileset replacement = tileset->findSimilarTileset(existingTilesets);
automapper.cpp:            undoStack->push(new AddTileset(mMapDocument, tileset));
automapper.cpp:        const int sharedTileCount = qMin(tileset->tileCount(),
automapper.cpp:                                         replacement->tileCount());
automapper.cpp:            Tile *replacementTile = replacement->tileAt(i);
automapper.cpp:            Properties properties = replacementTile->properties();
automapper.cpp:            properties.merge(tileset->tileAt(i)->properties());
automapper.cpp:            undoStack->push(new ChangeProperties(mMapDocument,
automapper.cpp:        src->replaceTileset(tileset, replacement);
automapper.cpp:        tilesetManager->addReference(replacement);
automapper.cpp:        tilesetManager->removeReference(tileset);
automapper.cpp:        foreach (const QRect &r, where->rects()) {
automapper.cpp:            region += r.adjusted(- mAutoMappingRadius,
automapper.cpp:                                 - mAutoMappingRadius,
automapper.cpp:            foreach (Layer *layer, translationTable->keys()) {
automapper.cpp:                const int index = mLayerList.at(i)->value(layer);
automapper.cpp:                Layer *dstLayer = mMapWork->layerAt(index);
automapper.cpp:                TileLayer *dstTileLayer = dstLayer->asTileLayer();
automapper.cpp:                    dstTileLayer->erase(region);
automapper.cpp:                                           dstLayer->asObjectGroup(),
automapper.cpp:    foreach (const QRect &rect, where->rects())
automapper.cpp:    *where = where->united(ret);
automapper.cpp:        const int index = mMapWork->indexOfLayer(name, Layer::TileLayerType);
automapper.cpp:        if (index == -1)
automapper.cpp:        TileLayer *setLayer = mMapWork->layerAt(index)->asTileLayer();
automapper.cpp:        result |= setLayer->region();
automapper.cpp:    const int minX = where.left() - rbr.left() - rbr.width() + 1;
automapper.cpp:    const int minY = where.top() - rbr.top() - rbr.height() + 1;
automapper.cpp:    const int maxX = where.right() - rbr.left() + rbr.width() - 1;
automapper.cpp:    const int maxY = where.bottom() - rbr.top() + rbr.height() - 1;
automapper.cpp:        appliedRegions.resize(mMapWork->layerCount());
automapper.cpp:                const int i = mMapWork->indexOfLayer(name, Layer::TileLayerType);
automapper.cpp:                if (i == -1) {
automapper.cpp:                    const TileLayer *setLayer = mMapWork->layerAt(i)->asTileLayer();
automapper.cpp:            QList<Layer*> layers = translationTable->keys();
automapper.cpp:                TileLayer *tileLayer = layer->asTileLayer();
automapper.cpp:                    appliedPlace = tileLayer->region();
automapper.cpp:                    appliedPlace = tileRegionOfObjectGroup(layer->asObjectGroup());
automapper.cpp:            for (int i = 0; i < translationTable->size(); ++i) {
automapper.cpp:                    const Cell &cell = tilelayer->cellAt(x, y);
automapper.cpp: *  - both listYes and listNo are empty:
automapper.cpp: *  - both listYes and listNo are not empty:
automapper.cpp: *  - either of both lists are not empty
automapper.cpp:                if (!setLayer->contains(x + offset.x(), y + offset.y()))
automapper.cpp:                const Cell &c1 = setLayer->cellAt(x + offset.x(),
automapper.cpp:                    if (!comparedTileLayer->contains(x, y))
automapper.cpp:                    const Cell &c2 = comparedTileLayer->cellAt(x, y);
automapper.cpp:                    if (!comparedTileLayer->contains(x, y))
automapper.cpp:                    const Cell &c2 = comparedTileLayer->cellAt(x, y);
automapper.cpp:    for (int i = 0; i < layerTranslation->keys().size(); ++i) {
automapper.cpp:        Layer *from = layerTranslation->keys().at(i);
automapper.cpp:        Layer *to = mMapWork->layerAt(layerTranslation->value(from));
automapper.cpp:            TileLayer *fromTileLayer = from->asTileLayer();
automapper.cpp:            ObjectGroup *fromObjectGroup = from->asObjectGroup();
automapper.cpp:                TileLayer *toTileLayer = to->asTileLayer();
automapper.cpp:                ObjectGroup *toObjectGroup = to->asObjectGroup();
automapper.cpp:    const int endX = qMin(dstX + width, dstLayer->width());
automapper.cpp:    const int endY = qMin(dstY + height, dstLayer->height());
automapper.cpp:    const int offsetX = srcX - dstX;
automapper.cpp:    const int offsetY = srcY - dstY;
automapper.cpp:            const Cell &cell = srcLayer->cellAt(x + offsetX, y + offsetY);
automapper.cpp:                dstLayer->setCell(x, y, cell);
automapper.cpp:    QUndoStack *undo = mMapDocument->undoStack();
automapper.cpp:    const QRectF pixelRect = mMapDocument->renderer()->tileToPixelCoords(rect);
automapper.cpp:    QPointF pixelOffset = mMapDocument->renderer()->tileToPixelCoords(dstX, dstY);
automapper.cpp:    pixelOffset -= pixelRect.topLeft();
automapper.cpp:        MapObject *clone = obj->clone();
automapper.cpp:        clone->setX(clone->x() + pixelOffset.x());
automapper.cpp:        clone->setY(clone->y() + pixelOffset.y());
automapper.cpp:        undo->push(new AddMapObject(mMapDocument, dstLayer, clone));
automapper.cpp:        if (mMapWork->isTilesetUsed(tileset.data()))
automapper.cpp:        const int index = mMapWork->indexOfTileset(tileset);
automapper.cpp:        if (index == -1)
automapper.cpp:        QUndoStack *undo = mMapDocument->undoStack();
automapper.cpp:        undo->push(new RemoveTileset(mMapDocument, index));
automapper.cpp:        const int layerIndex = mMapWork->indexOfLayer(tilelayerName,
automapper.cpp:        if (layerIndex == -1)
automapper.cpp:        const Layer *layer = mMapWork->layerAt(layerIndex);
automapper.cpp:        if (!layer->isEmpty())
automapper.cpp:        QUndoStack *undo = mMapDocument->undoStack();
automapper.cpp:        undo->push(new RemoveLayer(mMapDocument, layerIndex));
automapper.cpp:    tilesetManager->removeReferences(mMapRules->tilesets());
terrainview.cpp: * Copyright 2008-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
terrainview.cpp:    const QVariant data = model()->data(index, TerrainModel::TerrainRole);
terrainview.cpp:    if (event->modifiers() & Qt::ControlModifier
terrainview.cpp:        && event->orientation() == Qt::Vertical)
terrainview.cpp:        mZoomable->handleWheelDelta(event->delta());
terrainview.cpp:    Terrain *terrain = terrainAt(indexAt(event->pos()));
terrainview.cpp:    const bool isExternal = terrain->tileset()->isExternal();
terrainview.cpp:    QIcon propIcon(QLatin1String(":images/16x16/document-properties.png"));
terrainview.cpp:    terrainProperties->setEnabled(!isExternal);
terrainview.cpp:    Utils::setThemeIcon(terrainProperties, "document-properties");
terrainview.cpp:    menu.exec(event->globalPos());
terrainview.cpp:    Terrain *terrain = terrainAt(selectionModel()->currentIndex());
terrainview.cpp:    mMapDocument->setCurrentObject(terrain);
terrainview.cpp:    mMapDocument->emitEditCurrentObject();
terrainview.cpp://    terrainModel()->tilesetChanged();
Binary file moc_stampbrush.o matches
Binary file thumbnailrenderer.o matches
changemapproperty.cpp:    Map *map = mMapDocument->map();
changemapproperty.cpp:        const int tileWidth = map->tileWidth();
changemapproperty.cpp:        map->setTileWidth(mIntValue);
changemapproperty.cpp:        const int tileHeight = map->tileHeight();
changemapproperty.cpp:        map->setTileHeight(mIntValue);
changemapproperty.cpp:        const Map::Orientation orientation = map->orientation();
changemapproperty.cpp:        map->setOrientation(mOrientation);
changemapproperty.cpp:        mMapDocument->createRenderer();
changemapproperty.cpp:        const int hexSideLength = map->hexSideLength();
changemapproperty.cpp:        map->setHexSideLength(mIntValue);
changemapproperty.cpp:        const Map::StaggerAxis staggerAxis = map->staggerAxis();
changemapproperty.cpp:        map->setStaggerAxis(mStaggerAxis);
changemapproperty.cpp:        const Map::StaggerIndex staggerIndex = map->staggerIndex();
changemapproperty.cpp:        map->setStaggerIndex(mStaggerIndex);
changemapproperty.cpp:        const Map::RenderOrder renderOrder = map->renderOrder();
changemapproperty.cpp:        map->setRenderOrder(mRenderOrder);
changemapproperty.cpp:        const QColor backgroundColor = map->backgroundColor();
changemapproperty.cpp:        map->setBackgroundColor(mBackgroundColor);
changemapproperty.cpp:        const Map::LayerDataFormat layerDataFormat = map->layerDataFormat();
changemapproperty.cpp:        map->setLayerDataFormat(mLayerDataFormat);
changemapproperty.cpp:    mMapDocument->emitMapChanged();
Binary file utils.o matches
moc_createscalableobjecttool.cpp:        - idx * sizeof(QByteArrayData) \
moc_createscalableobjecttool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
objecttypesmodel.cpp:    for (int i = rows.size() - 1; i >= 0; --i) {
Binary file qtpropertybrowserutils.o matches
changeimagelayerproperties.cpp:    , mUndoColor(imageLayer->transparentColor())
changeimagelayerproperties.cpp:    , mUndoPath(imageLayer->imageSource())
changeimagelayerproperties.cpp:    mImageLayer->setTransparentColor(mRedoColor);
changeimagelayerproperties.cpp:        mImageLayer->resetImage();
changeimagelayerproperties.cpp:        mImageLayer->loadFromImage(QImage(mRedoPath), mRedoPath);
changeimagelayerproperties.cpp:    mMapDocument->emitImageLayerChanged(mImageLayer);
changeimagelayerproperties.cpp:    mImageLayer->setTransparentColor(mUndoColor);
changeimagelayerproperties.cpp:        mImageLayer->resetImage();
changeimagelayerproperties.cpp:        mImageLayer->loadFromImage(QImage(mUndoPath), mUndoPath);
changeimagelayerproperties.cpp:    mMapDocument->emitImageLayerChanged(mImageLayer);
Binary file tilestampmanager.o matches
Binary file mapscene.o matches
stampbrush.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
stampbrush.cpp:                               ":images/22x22/stock-tool-clone.png")),
stampbrush.cpp:            if (i == points.size() - 1)
stampbrush.cpp:                brushItem()->setTileLayer(mPreviewLayer);
stampbrush.cpp:        mapDocument()->emitRegionEdited(editedRegion, currentTileLayer());
stampbrush.cpp:    if (!brushItem()->isVisible())
stampbrush.cpp:    if (event->button() == Qt::LeftButton) {
stampbrush.cpp:        if (event->button() == Qt::RightButton)
stampbrush.cpp:        if (event->button() == Qt::RightButton) {
stampbrush.cpp:        if (event->button() == Qt::LeftButton) {
stampbrush.cpp: * This is done by taking all non-null tiles from the original stamp mStamp.
stampbrush.cpp:        mapDocument()->unifyTilesets(variation.map, mMissingTilesets);
stampbrush.cpp:        for (int x = 0; x < tileLayer->width(); x++) {
stampbrush.cpp:            for (int y = 0; y < tileLayer->height(); y++) {
stampbrush.cpp:                const Cell &cell = tileLayer->cellAt(x, y);
stampbrush.cpp:                    mRandomCellPicker.add(cell, cell.tile->probability());
stampbrush.cpp:    captured &= QRect(tileLayer->x(), tileLayer->y(),
stampbrush.cpp:                      tileLayer->width(), tileLayer->height());
stampbrush.cpp:        captured.translate(-tileLayer->x(), -tileLayer->y());
stampbrush.cpp:        Map *map = tileLayer->map();
stampbrush.cpp:        TileLayer *capture = tileLayer->copy(captured);
stampbrush.cpp:        Map *stamp = new Map(map->orientation(),
stampbrush.cpp:                             capture->width(),
stampbrush.cpp:                             capture->height(),
stampbrush.cpp:                             map->tileWidth(),
stampbrush.cpp:                             map->tileHeight());
stampbrush.cpp:        foreach (const SharedTileset &tileset, capture->usedTilesets())
stampbrush.cpp:            stamp->addTileset(tileset);
stampbrush.cpp:        stamp->addLayer(capture);
stampbrush.cpp:        captured.adjust(-1, 0, 1, 0);
stampbrush.cpp:        captured.adjust(0, -1, 0, 1);
stampbrush.cpp:    if (!tileLayer->bounds().intersects(QRect(preview->x(),
stampbrush.cpp:                                              preview->y(),
stampbrush.cpp:                                              preview->width(),
stampbrush.cpp:                                              preview->height())))
stampbrush.cpp:                                               preview->x(),
stampbrush.cpp:                                               preview->y(),
stampbrush.cpp:    paint->setMergeable(flags & Mergeable);
stampbrush.cpp:    mapDocument()->undoStack()->push(paint);
stampbrush.cpp:    QRegion editedRegion = preview->region();
stampbrush.cpp:        mapDocument()->emitRegionEdited(editedRegion, tileLayer);
stampbrush.cpp:            preview->setCell(p.x() - bounds.left(),
stampbrush.cpp:                             p.y() - bounds.top(),
stampbrush.cpp:            mapDocument()->unifyTilesets(variation, mMissingTilesets);
stampbrush.cpp:            TileLayer *stamp = static_cast<TileLayer*>(variation->layerAt(0));
stampbrush.cpp:                stampRegion = stamp->region();
stampbrush.cpp:            QPoint centered(p.x() - stamp->width() / 2,
stampbrush.cpp:                            p.y() - stamp->height() / 2);
stampbrush.cpp:            preview->merge(op.pos - bounds.topLeft(), op.stamp);
stampbrush.cpp:    brushItem()->setTileLayer(mPreviewLayer);
stampbrush.cpp:        brushItem()->setTileRegion(tileRegion);
Binary file moc_terrainview.o matches
terrainmodel.h: * Copyright 2008-2012, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
commandbutton.cpp:    setIcon(QIcon(QLatin1String(":images/24x24/system-run.png")));
commandbutton.cpp:    setThemeIcon(this, "system-run");
commandbutton.cpp:    if (action && action->data().isValid()) {
commandbutton.cpp:        command = Command::fromQVariant(action->data());
commandbutton.cpp:    mMenu->clear();
commandbutton.cpp:        QAction *action = mMenu->addAction(command.name);
commandbutton.cpp:        action->setStatusTip(command.command);
commandbutton.cpp:        action->setData(command.toQVariant());
commandbutton.cpp:    if (!mMenu->isEmpty())
commandbutton.cpp:        mMenu->addSeparator();
commandbutton.cpp:    QAction *action = mMenu->addAction(tr("Edit Commands..."));
commandbutton.cpp:    switch (event->type()) {
Binary file resizemap.o matches
command.cpp:    MapDocument *mapDocument = DocumentManager::instance()->currentDocument();
command.cpp:        const QString fileName = mapDocument->fileName();
command.cpp:        MapObject *currentObject = dynamic_cast<MapObject *>(mapDocument->currentObject());
command.cpp:                                 QString(QLatin1String("\"%1\"")).arg(currentObject->type()));
command.cpp:        MapDocument *document = DocumentManager::instance()->currentDocument();
command.cpp:            document->save();
command.cpp:                                    QLatin1String("which gnome-terminal")) == 0;
command.cpp:            mFinalCommand = QLatin1String("gnome-terminal -x ") + mFinalCommand;
command.cpp:            mFinalCommand = QLatin1String("xterm -e ") + mFinalCommand;
command.cpp:        // -W makes it not return immediately
command.cpp:        // -n makes it open a new instance of terminal if it is open already
command.cpp:        mFinalCommand = QString(QLatin1String("open -W -n \"%1\""))
command.cpp:    QWidget *parent = DocumentManager::instance()->widget();
preferencesdialog.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
preferencesdialog.cpp:            index.model()->data(index, ObjectTypesModel::ColorRole);
preferencesdialog.cpp:    const QRect rect = option.rect.adjusted(4, 4, -4, -4);
preferencesdialog.cpp:    painter->setPen(shadowPen);
preferencesdialog.cpp:    painter->setBrush(QBrush());
preferencesdialog.cpp:    painter->drawRect(rect.translated(QPoint(1, 1)));
preferencesdialog.cpp:    painter->setPen(linePen);
preferencesdialog.cpp:    painter->setBrush(fillBrush);
preferencesdialog.cpp:    painter->drawRect(rect);
preferencesdialog.cpp:    mLanguages(LanguageManager::instance()->availableLanguages())
preferencesdialog.cpp:    mUi->setupUi(this);
preferencesdialog.cpp:    mUi->openGL->setEnabled(QGLFormat::hasOpenGL());
preferencesdialog.cpp:    mUi->openGL->setEnabled(false);
preferencesdialog.cpp:        mUi->languageCombo->addItem(string, name);
preferencesdialog.cpp:    mUi->languageCombo->model()->sort(0);
preferencesdialog.cpp:    mUi->languageCombo->insertItem(0, tr("System default"));
preferencesdialog.cpp:    mUi->objectTypesTable->setModel(mObjectTypesModel);
preferencesdialog.cpp:    mUi->objectTypesTable->setItemDelegateForColumn(1, new ColorDelegate(this));
preferencesdialog.cpp:    QHeaderView *horizontalHeader = mUi->objectTypesTable->horizontalHeader();
preferencesdialog.cpp:    horizontalHeader->setSectionResizeMode(QHeaderView::Stretch);
preferencesdialog.cpp:    Utils::setThemeIcon(mUi->addObjectTypeButton, "add");
preferencesdialog.cpp:    Utils::setThemeIcon(mUi->removeObjectTypeButton, "remove");
preferencesdialog.cpp:    connect(mUi->languageCombo, SIGNAL(currentIndexChanged(int)),
preferencesdialog.cpp:    connect(mUi->openGL, SIGNAL(toggled(bool)), SLOT(useOpenGLToggled(bool)));
preferencesdialog.cpp:    connect(mUi->gridColor, SIGNAL(colorChanged(QColor)),
preferencesdialog.cpp:    connect(mUi->gridFine, SIGNAL(valueChanged(int)),
preferencesdialog.cpp:    connect(mUi->objectLineWidth, SIGNAL(valueChanged(double)),
preferencesdialog.cpp:    connect(mUi->objectTypesTable->selectionModel(),
preferencesdialog.cpp:    connect(mUi->objectTypesTable, SIGNAL(doubleClicked(QModelIndex)),
preferencesdialog.cpp:    connect(mUi->addObjectTypeButton, SIGNAL(clicked()),
preferencesdialog.cpp:    connect(mUi->removeObjectTypeButton, SIGNAL(clicked()),
preferencesdialog.cpp:    connect(mUi->importObjectTypesButton, SIGNAL(clicked()),
preferencesdialog.cpp:    connect(mUi->exportObjectTypesButton, SIGNAL(clicked()),
preferencesdialog.cpp:    connect(mUi->autoMapWhileDrawing, SIGNAL(toggled(bool)),
preferencesdialog.cpp:    connect(mUi->openLastFiles, SIGNAL(toggled(bool)), SLOT(openLastFilesToggled(bool)));
preferencesdialog.cpp:    switch (e->type()) {
preferencesdialog.cpp:            mUi->retranslateUi(this);
preferencesdialog.cpp:            mUi->languageCombo->setItemText(0, tr("System default"));
preferencesdialog.cpp:    const QString language = mUi->languageCombo->itemData(index).toString();
preferencesdialog.cpp:    prefs->setLanguage(language);
preferencesdialog.cpp:    Preferences::instance()->setObjectLineWidth(lineWidth);
preferencesdialog.cpp:    Preferences::instance()->setUseOpenGL(useOpenGL);
preferencesdialog.cpp:    const int newRow = mObjectTypesModel->objectTypes().size();
preferencesdialog.cpp:    mObjectTypesModel->appendNewObjectType();
preferencesdialog.cpp:    QItemSelectionModel *sm = mUi->objectTypesTable->selectionModel();
preferencesdialog.cpp:    const QModelIndex newIndex = mObjectTypesModel->index(newRow, 0);
preferencesdialog.cpp:    sm->select(newIndex,
preferencesdialog.cpp:    sm->setCurrentIndex(newIndex, QItemSelectionModel::Current);
preferencesdialog.cpp:    mUi->objectTypesTable->setFocus();
preferencesdialog.cpp:    mUi->objectTypesTable->scrollTo(newIndex);
preferencesdialog.cpp:    const QItemSelectionModel *sm = mUi->objectTypesTable->selectionModel();
preferencesdialog.cpp:    mUi->removeObjectTypeButton->setEnabled(sm->hasSelection());
preferencesdialog.cpp:    const QItemSelectionModel *sm = mUi->objectTypesTable->selectionModel();
preferencesdialog.cpp:    mObjectTypesModel->removeObjectTypes(sm->selectedRows());
preferencesdialog.cpp:        QColor color = mObjectTypesModel->objectTypes().at(index.row()).color;
preferencesdialog.cpp:            mObjectTypesModel->setObjectTypeColor(index.row(), newColor);
preferencesdialog.cpp:    prefs->setObjectTypes(mObjectTypesModel->objectTypes());
preferencesdialog.cpp:    const QString lastPath = prefs->lastPath(Preferences::ObjectTypesFile);
preferencesdialog.cpp:    prefs->setLastPath(Preferences::ObjectTypesFile, fileName);
preferencesdialog.cpp:        prefs->setObjectTypes(objectTypes);
preferencesdialog.cpp:        mObjectTypesModel->setObjectTypes(objectTypes);
preferencesdialog.cpp:    QString lastPath = prefs->lastPath(Preferences::ObjectTypesFile);
preferencesdialog.cpp:    prefs->setLastPath(Preferences::ObjectTypesFile, fileName);
preferencesdialog.cpp:    if (!writer.writeObjectTypes(fileName, prefs->objectTypes())) {
preferencesdialog.cpp:    mUi->reloadTilesetImages->setChecked(prefs->reloadTilesetsOnChange());
preferencesdialog.cpp:    mUi->enableDtd->setChecked(prefs->dtdEnabled());
preferencesdialog.cpp:    mUi->openLastFiles->setChecked(prefs->openLastFilesOnStartup());
preferencesdialog.cpp:    if (mUi->openGL->isEnabled())
preferencesdialog.cpp:        mUi->openGL->setChecked(prefs->useOpenGL());
preferencesdialog.cpp:    // Not found (-1) ends up at index 0, system default
preferencesdialog.cpp:    int languageIndex = mUi->languageCombo->findData(prefs->language());
preferencesdialog.cpp:    if (languageIndex == -1)
preferencesdialog.cpp:    mUi->languageCombo->setCurrentIndex(languageIndex);
preferencesdialog.cpp:    mUi->gridColor->setColor(prefs->gridColor());
preferencesdialog.cpp:    mUi->gridFine->setValue(prefs->gridFine());
preferencesdialog.cpp:    mUi->objectLineWidth->setValue(prefs->objectLineWidth());
preferencesdialog.cpp:    mUi->autoMapWhileDrawing->setChecked(prefs->automappingDrawing());
preferencesdialog.cpp:    mObjectTypesModel->setObjectTypes(prefs->objectTypes());
preferencesdialog.cpp:    prefs->setReloadTilesetsOnChanged(mUi->reloadTilesetImages->isChecked());
preferencesdialog.cpp:    prefs->setDtdEnabled(mUi->enableDtd->isChecked());
preferencesdialog.cpp:    prefs->setAutomappingDrawing(mUi->autoMapWhileDrawing->isChecked());
preferencesdialog.cpp:    prefs->setOpenLastFilesOnStartup(mUi->openLastFiles->isChecked());
preferencesdialog.cpp:    Preferences::instance()->setAutomappingDrawing(enabled);
preferencesdialog.cpp:    Preferences::instance()->setOpenLastFilesOnStartup(enabled);
Binary file moc_qtpropertybrowserutils_p.o matches
eraser.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
eraser.cpp:                               ":images/22x22/stock-tool-eraser.png")),
eraser.cpp:    brushItem()->setTileRegion(QRect(tilePos, QSize(1, 1)));
eraser.cpp:    if (!brushItem()->isVisible())
eraser.cpp:    if (event->button() == Qt::LeftButton) {
eraser.cpp:    if (event->button() == Qt::LeftButton)
eraser.cpp:    if (!tileLayer->bounds().intersects(eraseRegion.boundingRect()))
eraser.cpp:    erase->setMergeable(continuation);
eraser.cpp:    mapDocument()->undoStack()->push(erase);
eraser.cpp:    mapDocument()->emitRegionEdited(eraseRegion, tileLayer);
Binary file renameterrain.o matches
geometry.h: * Copyright 2010-2011, Stefan Beller <stefanbeller@googlemail.com>
aboutdialog.cpp: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
aboutdialog.cpp:            "<p align=\"center\">Copyright 2008-2015 Thorbj&oslash;rn Lindeijer<br>(see the AUTHORS file for a full list of contributors)</p>\n"
aboutdialog.cpp:    textBrowser->setHtml(html);
Binary file changetileprobability.o matches
moc_documentmanager.cpp:        - idx * sizeof(QByteArrayData) \
moc_documentmanager.cpp:        case 0: _t->currentDocumentChanged((*reinterpret_cast< MapDocument*(*)>(_a[1]))); break;
moc_documentmanager.cpp:        case 1: _t->documentCloseRequested((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_documentmanager.cpp:        case 2: _t->documentAboutToClose((*reinterpret_cast< MapDocument*(*)>(_a[1]))); break;
moc_documentmanager.cpp:        case 3: _t->reloadError((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_documentmanager.cpp:        case 4: _t->switchToLeftDocument(); break;
moc_documentmanager.cpp:        case 5: _t->switchToRightDocument(); break;
moc_documentmanager.cpp:        case 6: _t->setSelectedTool((*reinterpret_cast< AbstractTool*(*)>(_a[1]))); break;
moc_documentmanager.cpp:        case 7: _t->currentIndexChanged(); break;
moc_documentmanager.cpp:        case 8: _t->fileNameChanged((*reinterpret_cast< const QString(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2]))); break;
moc_documentmanager.cpp:        case 9: _t->updateDocumentTab(); break;
moc_documentmanager.cpp:        case 10: _t->documentSaved(); break;
moc_documentmanager.cpp:        case 11: _t->documentTabMoved((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
moc_documentmanager.cpp:        case 12: _t->fileChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_documentmanager.cpp:        case 13: _t->reloadRequested(); break;
moc_documentmanager.cpp:        case 14: _t->cursorChanged((*reinterpret_cast< const QCursor(*)>(_a[1]))); break;
moc_documentmanager.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_documentmanager.cpp:        _id -= 15;
moc_documentmanager.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_documentmanager.cpp:        _id -= 15;
Binary file tilecollisioneditor.o matches
Binary file tileanimationeditor.o matches
filltiles.cpp:    , mOriginalCells(tileLayer->copy(mFillRegion))
commanddialog.cpp:    mUi->setupUi(this);
commanddialog.cpp:    mUi->saveBox->setChecked(mUi->treeView->model()->saveBeforeExecute());
commanddialog.cpp:    mUi->treeView->model()->setSaveBeforeExecute(mUi->saveBox->isChecked());
commanddialog.cpp:    mUi->treeView->model()->commit();
commanddialog.cpp:    h->setStretchLastSection(false);
commanddialog.cpp:    h->setSectionResizeMode(CommandDataModel::NameColumn, QHeaderView::Interactive);
commanddialog.cpp:    h->setSectionResizeMode(CommandDataModel::CommandColumn, QHeaderView::Stretch);
commanddialog.cpp:    h->setSectionResizeMode(CommandDataModel::EnabledColumn,
commanddialog.cpp:    d->setContext(Qt::WidgetShortcut);
commanddialog.cpp:    QModelIndex index = indexAt(event->pos());
commanddialog.cpp:    QMenu *menu = mModel->contextMenu(this, index);
commanddialog.cpp:        menu->exec(event->globalPos());
commanddialog.cpp:    QModelIndex index = sModel->currentIndex();
commanddialog.cpp:    sModel->select(index.sibling(index.row() + 1,index.column()),
commanddialog.cpp:    const QModelIndexList indices = selection->selectedRows();
commanddialog.cpp:    mModel->removeRows(indices);
moc_abstracttiletool.cpp:        - idx * sizeof(QByteArrayData) \
moc_abstracttiletool.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
terrainbrush.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
terrainbrush.cpp:                               ":images/24x24/terrain-edit.png")),
terrainbrush.cpp:    if (!brushItem()->isVisible())
terrainbrush.cpp:    if (event->button() == Qt::LeftButton) {
terrainbrush.cpp:        if (event->button() == Qt::RightButton)
terrainbrush.cpp:        if (event->button() == Qt::LeftButton)
terrainbrush.cpp:    foreach (const SharedTileset &tileset, mapDocument->map()->tilesets())
terrainbrush.cpp:        if (tileset->terrainCount() > 0)
terrainbrush.cpp:            return tileset->terrain(0);
terrainbrush.cpp:    brushItem()->clear();
terrainbrush.cpp:    if (mIsActive && brushItem()->isVisible())
terrainbrush.cpp:    if (!tileLayer->contains(position))
terrainbrush.cpp:    const Cell &cell = tileLayer->cellAt(position);
terrainbrush.cpp:    Terrain *t = cell.tile->terrainAtCorner(0);
terrainbrush.cpp:    TileLayer *stamp = brushItem()->tileLayer().data();
terrainbrush.cpp:    whereX -= mOffsetX;
terrainbrush.cpp:    whereY -= mOffsetY;
terrainbrush.cpp:    if (!tileLayer->bounds().intersects(QRect(whereX, whereY, stamp->width(), stamp->height())))
terrainbrush.cpp:    paint->setMergeable(mergeable);
terrainbrush.cpp:    mapDocument()->undoStack()->push(paint);
terrainbrush.cpp:    mapDocument()->emitRegionEdited(brushItem()->tileRegion(), tileLayer);
terrainbrush.cpp:        if ((t->terrain() & considerationMask) != (terrain & considerationMask))
terrainbrush.cpp:        int tr = tileset.terrainTransitionPenalty(t->terrain() >> 24, terrain >> 24);
terrainbrush.cpp:        int tl = tileset.terrainTransitionPenalty((t->terrain() >> 16) & 0xFF, (terrain >> 16) & 0xFF);
terrainbrush.cpp:        int br = tileset.terrainTransitionPenalty((t->terrain() >> 8) & 0xFF, (terrain >> 8) & 0xFF);
terrainbrush.cpp:        int bl = tileset.terrainTransitionPenalty(t->terrain() & 0xFF, terrain & 0xFF);
terrainbrush.cpp:            matches.add(t, t->probability());
terrainbrush.cpp:    return tile ? tile->terrain() : 0xFFFFFFFF;
terrainbrush.cpp:    int layerWidth = currentLayer->width();
terrainbrush.cpp:    int layerHeight = currentLayer->height();
terrainbrush.cpp:            cursorPos.setX(cursorPos.x() - 1);
terrainbrush.cpp:            cursorPos.setY(cursorPos.y() - 1);
terrainbrush.cpp:    if (!currentLayer->bounds().contains(cursorPos))
terrainbrush.cpp:    int terrainId = -1;
terrainbrush.cpp:        terrainTileset = mTerrain->tileset();
terrainbrush.cpp:        terrainId = mTerrain->id();
terrainbrush.cpp:    // produce terrain with transitions using a simple, relative naive approach (considers each tile once, and doesn't allow re-consideration if selection was bad)
terrainbrush.cpp:        // TODO: we might want to allow re-consideration if prior tiles... but not for now, this would risk infinite loops
terrainbrush.cpp:        const Tile *tile = currentLayer->cellAt(p).tile;
terrainbrush.cpp:            tileset = tile->tileset();
terrainbrush.cpp:                if (tile && tile->tileset() != tileset)
terrainbrush.cpp:                mask = 0xFF << (3 - paintCorner)*8;
terrainbrush.cpp:                preferredTerrain = (currentTerrain & ~mask) | (terrainId << (3 - paintCorner)*8);
terrainbrush.cpp:            --initialTiles;
terrainbrush.cpp:            if (preferredTerrain == currentTerrain && (!tile || tile->tileset() == tileset))
terrainbrush.cpp:            if (tile && tile->tileset() != tileset)
terrainbrush.cpp:            if (y > 0 && checked[i - layerWidth]) {
terrainbrush.cpp:                preferredTerrain = (::terrain(newTerrain[i - layerWidth]) << 16) | (preferredTerrain & 0x0000FFFF);
terrainbrush.cpp:            if (y < layerHeight - 1 && checked[i + layerWidth]) {
terrainbrush.cpp:            if (x > 0 && checked[i - 1]) {
terrainbrush.cpp:                preferredTerrain = ((::terrain(newTerrain[i - 1]) << 8) & 0xFF00FF00) | (preferredTerrain & 0x00FF00FF);
terrainbrush.cpp:            if (x < layerWidth - 1 && checked[i + 1]) {
terrainbrush.cpp:        if (y > 0 && !checked[i - layerWidth]) {
terrainbrush.cpp:            const Tile *above = currentLayer->cellAt(x, y - 1).tile;
terrainbrush.cpp:                transitionList.append(QPoint(x, y - 1));
terrainbrush.cpp:        if (y < layerHeight - 1 && !checked[i + layerWidth]) {
terrainbrush.cpp:            const Tile *below = currentLayer->cellAt(x, y + 1).tile;
terrainbrush.cpp:        if (x > 0 && !checked[i - 1]) {
terrainbrush.cpp:            const Tile *left = currentLayer->cellAt(x - 1, y).tile;
terrainbrush.cpp:                transitionList.append(QPoint(x - 1, y));
terrainbrush.cpp:        if (x < layerWidth - 1 && !checked[i + 1]) {
terrainbrush.cpp:            const Tile *right = currentLayer->cellAt(x + 1, y).tile;
terrainbrush.cpp:                stamp->setCell(x - brushRect.left(),
terrainbrush.cpp:                               y - brushRect.top(),
terrainbrush.cpp:    brushItem()->setTileLayer(stamp);
terrainbrush.cpp:    mOffsetX = cursorPos.x() - brushRect.left();
terrainbrush.cpp:    mOffsetY = cursorPos.y() - brushRect.top();
moc_tileanimationeditor.cpp:        - idx * sizeof(QByteArrayData) \
moc_tileanimationeditor.cpp:        case 0: _t->closed(); break;
moc_tileanimationeditor.cpp:        case 1: _t->setTile((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_tileanimationeditor.cpp:        case 2: _t->framesEdited(); break;
moc_tileanimationeditor.cpp:        case 3: _t->tileAnimationChanged((*reinterpret_cast< Tile*(*)>(_a[1]))); break;
moc_tileanimationeditor.cpp:        case 4: _t->tilesetFileNameChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_tileanimationeditor.cpp:        case 5: _t->currentObjectChanged((*reinterpret_cast< Object*(*)>(_a[1]))); break;
moc_tileanimationeditor.cpp:        case 6: _t->addFrameForTileAt((*reinterpret_cast< const QModelIndex(*)>(_a[1]))); break;
moc_tileanimationeditor.cpp:        case 7: _t->undo(); break;
moc_tileanimationeditor.cpp:        case 8: _t->redo(); break;
moc_tileanimationeditor.cpp:        case 9: _t->delete_(); break;
moc_tileanimationeditor.cpp:        case 10: _t->advancePreviewAnimation((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_tileanimationeditor.cpp:        case 11: _t->resetPreview(); break;
moc_tileanimationeditor.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tileanimationeditor.cpp:        _id -= 12;
moc_tileanimationeditor.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tileanimationeditor.cpp:        _id -= 12;
automappingutils.cpp:    QUndoStack *undo = mapDocument->undoStack();
automappingutils.cpp:    foreach (MapObject *obj, layer->objects()) {
automappingutils.cpp:        const QRectF objBounds = obj->boundsUseTile();
automappingutils.cpp:        QPointF tl = mapDocument->renderer()->pixelToTileCoords(objBounds.topLeft());
automappingutils.cpp:        QPointF tr = mapDocument->renderer()->pixelToTileCoords(objBounds.topRight());
automappingutils.cpp:        QPointF br = mapDocument->renderer()->pixelToTileCoords(objBounds.bottomRight());
automappingutils.cpp:        QPointF bl = mapDocument->renderer()->pixelToTileCoords(objBounds.bottomLeft());
automappingutils.cpp:            undo->push(new RemoveMapObject(mapDocument, obj));
automappingutils.cpp:    foreach (MapObject *obj, layer->objects()) {
automappingutils.cpp:        ret += obj->bounds().toAlignedRect();
automappingutils.cpp:    foreach (MapObject *obj, layer->objects()) {
automappingutils.cpp:        const QRect rect = obj->boundsUseTile().toAlignedRect();
Binary file mapobjectmodel.o matches
Binary file qrc_tiled.o matches
Binary file movetileset.o matches
moc_tilestampmodel.cpp:        - idx * sizeof(QByteArrayData) \
moc_tilestampmodel.cpp:        case 0: _t->stampAdded((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_tilestampmodel.cpp:        case 1: _t->stampRenamed((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_tilestampmodel.cpp:        case 2: _t->stampChanged((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_tilestampmodel.cpp:        case 3: _t->stampRemoved((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_tilestampmodel.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_tilestampmodel.cpp:        _id -= 4;
moc_tilestampmodel.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_tilestampmodel.cpp:        _id -= 4;
macsupport.mm:        NSView *nsview = (NSView *) window->winId();
consoledock.cpp:    layout->setMargin(5);
consoledock.cpp:    plainTextEdit->setReadOnly(true);
consoledock.cpp:    plainTextEdit->setStyleSheet(QString::fromUtf8(
consoledock.cpp:                            " background-color: black;"
consoledock.cpp:    layout->addWidget(plainTextEdit);
consoledock.cpp:    plainTextEdit->appendHtml(QLatin1String("<pre>") + str +
consoledock.cpp:    plainTextEdit->appendHtml(QLatin1String("<pre style='color:red'>") + str +
Binary file raiselowerhelper.o matches
Binary file abstractimagetool.o matches
tiled.qbs:        cpp.cxxFlags: ["-Wno-unknown-pragmas"]
Binary file commandbutton.o matches
resizehelper.cpp:    const QSize _size = size() - QSize(2, 2);
resizehelper.cpp:    double origX = (_size.width() - mNewSize.width() * mScale) / 2 + 0.5;
resizehelper.cpp:    double origY = (_size.height() - mNewSize.height() * mScale) / 2 + 0.5;
resizehelper.cpp:    mMouseAnchorPoint = event->pos();
resizehelper.cpp:    mDragging = event->button() == Qt::LeftButton;
resizehelper.cpp:    const QPoint &pos = event->pos();
resizehelper.cpp:        setOffset(mOrigOffset + (pos - mMouseAnchorPoint) / mScale);
resizehelper.cpp:    const QSize _size = size() - QSize(2, 2);
resizehelper.cpp:        2 * mOldSize.width() - mNewSize.width();
resizehelper.cpp:        2 * mOldSize.height() - mNewSize.height();
resizehelper.cpp:        offsetBounds.setRight(mNewSize.width() - mOldSize.width());
resizehelper.cpp:        offsetBounds.setLeft(mNewSize.width() - mOldSize.width());
resizehelper.cpp:        offsetBounds.setBottom(mNewSize.height() - mOldSize.height());
resizehelper.cpp:        offsetBounds.setTop(mNewSize.height() - mOldSize.height());
tilestamp.cpp:    return static_cast<TileLayer*>(map->layerAt(0));
tilestamp.cpp:    : quickStampIndex(-1)
tilestamp.cpp:    , quickStampIndex(-1)
tilestamp.cpp:    // deep-copy the map data
tilestamp.cpp:        tilesetManager->addReferences(variation.map->tilesets());
tilestamp.cpp:        tilesetManager->removeReferences(variation.map->tilesets());
tilestamp.cpp:    return d->name;
tilestamp.cpp:    d->name = name;
tilestamp.cpp:    return d->fileName;
tilestamp.cpp:    d->fileName = fileName;
tilestamp.cpp:    return d->variations.at(index).probability;
tilestamp.cpp:    d->variations[index].probability = probability;
tilestamp.cpp:    return d->variations;
tilestamp.cpp:    TilesetManager::instance()->addReferences(map->tilesets());
tilestamp.cpp:    d->variations.append(TileStampVariation(map, probability));
tilestamp.cpp:    return d->variations.takeAt(index).map;
tilestamp.cpp:    Map *variation = d->variations.at(index).map;
tilestamp.cpp:    d->variations.remove(index);
tilestamp.cpp:    TilesetManager::instance()->removeReferences(map->tilesets());
tilestamp.cpp:    return d->variations.isEmpty();
tilestamp.cpp:    return d->quickStampIndex;
tilestamp.cpp:    d->quickStampIndex = quickStampIndex;
tilestamp.cpp:    if (d->variations.isEmpty())
tilestamp.cpp:    for (const TileStampVariation &variation : d->variations)
tilestamp.cpp:    return randomPicker.pick()->map;
tilestamp.cpp:        layer->flip(direction);
tilestamp.cpp:        layer->rotate(direction);
tilestamp.cpp:        variation.map->setWidth(layer->width());
tilestamp.cpp:        variation.map->setHeight(layer->height());
tilestamp.cpp:    json.insert(QLatin1String("name"), d->name);
tilestamp.cpp:    if (d->quickStampIndex != -1)
tilestamp.cpp:        json.insert(QLatin1String("quickStampIndex"), d->quickStampIndex);
tilestamp.cpp:    for (const TileStampVariation &variation : d->variations) {
tilestamp.cpp:    stamp.setQuickStampIndex(static_cast<int>(json.value(QLatin1String("quickStampIndex")).toDouble(-1)));
tilecollisioneditor.cpp:    layout->setSpacing(0);
tilecollisioneditor.cpp:    layout->setMargin(5);
tilecollisioneditor.cpp:    mMapView->setScene(mMapScene);
tilecollisioneditor.cpp:    mMapView->setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
tilecollisioneditor.cpp:    mMapView->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
tilecollisioneditor.cpp:    toolBar->setMovable(false);
tilecollisioneditor.cpp:    toolBar->setFloatable(false);
tilecollisioneditor.cpp:    toolBar->setContextMenuPolicy(Qt::ActionsContextMenu);
tilecollisioneditor.cpp:    toolBar->addAction(mToolManager->registerTool(new ObjectSelectionTool(this)));
tilecollisioneditor.cpp:    toolBar->addAction(mToolManager->registerTool(new EditPolygonTool(this)));
tilecollisioneditor.cpp:    toolBar->addAction(mToolManager->registerTool(rectangleObjectsTool));
tilecollisioneditor.cpp:    toolBar->addAction(mToolManager->registerTool(ellipseObjectsTool));
tilecollisioneditor.cpp:    toolBar->addAction(mToolManager->registerTool(polygonObjectsTool));
tilecollisioneditor.cpp:    toolBar->addAction(mToolManager->registerTool(polylineObjectsTool));
tilecollisioneditor.cpp:    mMapScene->setSelectedTool(mToolManager->selectedTool());
tilecollisioneditor.cpp:    statusBar()->addPermanentWidget(zoomComboBox);
tilecollisioneditor.cpp:    Zoomable *zoomable = mMapView->zoomable();
tilecollisioneditor.cpp:    zoomable->connectToComboBox(zoomComboBox);
tilecollisioneditor.cpp:        mMapDocument->disconnect(this);
tilecollisioneditor.cpp:    mMapScene->disableSelectedTool();
tilecollisioneditor.cpp:    MapDocument *previousDocument = mMapScene->mapDocument();
tilecollisioneditor.cpp:        mMapView->setEnabled(!mTile->tileset()->isExternal());
tilecollisioneditor.cpp:        Map *map = new Map(Map::Orthogonal, 1, 1, tile->width(), tile->height());
tilecollisioneditor.cpp:        map->addTileset(tile->sharedTileset());
tilecollisioneditor.cpp:        tileLayer->setCell(0, 0, Cell(tile));
tilecollisioneditor.cpp:        map->addLayer(tileLayer);
tilecollisioneditor.cpp:        if (tile->objectGroup())
tilecollisioneditor.cpp:            objectGroup = static_cast<ObjectGroup*>(tile->objectGroup()->clone());
tilecollisioneditor.cpp:        objectGroup->setDrawOrder(ObjectGroup::IndexOrder);
tilecollisioneditor.cpp:        map->addLayer(objectGroup);
tilecollisioneditor.cpp:        mMapScene->setMapDocument(mapDocument);
tilecollisioneditor.cpp:        mToolManager->setMapDocument(mapDocument);
tilecollisioneditor.cpp:        mapDocument->setCurrentLayerIndex(1);
tilecollisioneditor.cpp:        mMapScene->enableSelectedTool();
tilecollisioneditor.cpp:        connect(mapDocument->undoStack(), SIGNAL(indexChanged(int)),
tilecollisioneditor.cpp:        mMapView->setEnabled(false);
tilecollisioneditor.cpp:        mMapScene->setMapDocument(0);
tilecollisioneditor.cpp:        mToolManager->setMapDocument(0);
tilecollisioneditor.cpp:        previousDocument->undoStack()->disconnect(this);
tilecollisioneditor.cpp:    if (event->isAccepted())
tilecollisioneditor.cpp:    mMapScene->disableSelectedTool();
tilecollisioneditor.cpp:    mMapScene->setSelectedTool(tool);
tilecollisioneditor.cpp:    mMapScene->enableSelectedTool();
tilecollisioneditor.cpp:    MapDocument *dummyDocument = mMapScene->mapDocument();
tilecollisioneditor.cpp:    Layer *objectGroup = dummyDocument->map()->layerAt(1);
tilecollisioneditor.cpp:    ObjectGroup *clonedGroup = static_cast<ObjectGroup*>(objectGroup->clone());
tilecollisioneditor.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
tilecollisioneditor.cpp:    undoStack->push(new ChangeTileObjectGroup(mMapDocument, mTile, clonedGroup));
tilecollisioneditor.cpp:    MapDocument *dummyDocument = mMapScene->mapDocument();
tilecollisioneditor.cpp:    LayerModel *layerModel = dummyDocument->layerModel();
tilecollisioneditor.cpp:    dummyDocument->undoStack()->clear();
tilecollisioneditor.cpp:    delete layerModel->takeLayerAt(1);
tilecollisioneditor.cpp:    if (tile->objectGroup())
tilecollisioneditor.cpp:        objectGroup = static_cast<ObjectGroup*>(tile->objectGroup()->clone());
tilecollisioneditor.cpp:    objectGroup->setDrawOrder(ObjectGroup::IndexOrder);
tilecollisioneditor.cpp:    layerModel->insertLayer(1, objectGroup);
tilecollisioneditor.cpp:    dummyDocument->setCurrentLayerIndex(1);
tilecollisioneditor.cpp:    if (mTile && mTile->tileset() == tileset)
tilecollisioneditor.cpp:        mMapView->setEnabled(!tileset->isExternal());
tilecollisioneditor.cpp:    if (object && object->typeId() == Object::MapObjectType) {
tilecollisioneditor.cpp:        const Cell &cell = static_cast<MapObject*>(object)->cell();
tilecollisioneditor.cpp:        mMapDocument->undoStack()->undo();
tilecollisioneditor.cpp:        mMapDocument->undoStack()->redo();
tilecollisioneditor.cpp:    MapDocument *dummyDocument = mMapScene->mapDocument();
tilecollisioneditor.cpp:    ClipboardManager::instance()->copySelection(dummyDocument);
tilecollisioneditor.cpp:    QScopedPointer<Map> map(clipboardManager->map());
tilecollisioneditor.cpp:    if (map->layerCount() != 1)
tilecollisioneditor.cpp:    Layer *layer = map->layerAt(0);
tilecollisioneditor.cpp:    if (ObjectGroup *objectGroup = layer->asObjectGroup()) {
tilecollisioneditor.cpp:        MapDocument *dummyDocument = mMapScene->mapDocument();
tilecollisioneditor.cpp:        clipboardManager->pasteObjectGroup(objectGroup,
tilecollisioneditor.cpp:    MapDocument *dummyDocument = mMapScene->mapDocument();
tilecollisioneditor.cpp:    const QList<MapObject*> &selectedObjects = dummyDocument->selectedObjects();
tilecollisioneditor.cpp:    QUndoStack *undoStack = dummyDocument->undoStack();
tilecollisioneditor.cpp:    undoStack->beginMacro(operation == Delete ? tr("Delete") : tr("Cut"));
tilecollisioneditor.cpp:        undoStack->push(new RemoveMapObject(dummyDocument, mapObject));
tilecollisioneditor.cpp:    undoStack->endMacro();
tilecollisioneditor.cpp:    switch (e->type()) {
changeselectedarea.cpp: * Copyright 2009-2010, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
changeselectedarea.cpp:    const QRegion oldSelection = mMapDocument->selectedArea();
changeselectedarea.cpp:    mMapDocument->setSelectedArea(mSelection);
resizetilelayer.cpp:    , mIndex(mapDocument->map()->layers().indexOf(layer))
resizetilelayer.cpp:    Q_ASSERT(mIndex != -1);
resizetilelayer.cpp:    mResizedLayer = static_cast<TileLayer*>(layer->clone());
resizetilelayer.cpp:    mResizedLayer->resize(size, offset);
resizetilelayer.cpp:    const int currentIndex = mMapDocument->currentLayerIndex();
resizetilelayer.cpp:    LayerModel *layerModel = mMapDocument->layerModel();
resizetilelayer.cpp:    Layer *replaced = layerModel->takeLayerAt(mIndex);
resizetilelayer.cpp:    layerModel->insertLayer(mIndex, layer);
resizetilelayer.cpp:        mMapDocument->setCurrentLayerIndex(mIndex);
changetileanimation.cpp:    const QVector<Frame> frames = mTile->frames();
changetileanimation.cpp:    mTile->setFrames(mFrames);
changetileanimation.cpp:    mMapDocument->emitTileAnimationChanged(mTile);
moc_varianteditorfactory.cpp:        - idx * sizeof(QByteArrayData) \
moc_varianteditorfactory.cpp:        case 0: _t->slotPropertyChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QVariant(*)>(_a[2]))); break;
moc_varianteditorfactory.cpp:        case 1: _t->slotPropertyAttributeChanged((*reinterpret_cast< QtProperty*(*)>(_a[1])),(*reinterpret_cast< const QString(*)>(_a[2])),(*reinterpret_cast< const QVariant(*)>(_a[3]))); break;
moc_varianteditorfactory.cpp:        case 2: _t->slotSetValue((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_varianteditorfactory.cpp:        case 3: _t->slotEditorDestroyed((*reinterpret_cast< QObject*(*)>(_a[1]))); break;
moc_varianteditorfactory.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_varianteditorfactory.cpp:        _id -= 4;
moc_varianteditorfactory.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_varianteditorfactory.cpp:        _id -= 4;
propertiesdock.cpp:    mActionAddProperty->setEnabled(false);
propertiesdock.cpp:    mActionAddProperty->setIcon(QIcon(QLatin1String(":/images/16x16/add.png")));
propertiesdock.cpp:    mActionRemoveProperty->setEnabled(false);
propertiesdock.cpp:    mActionRemoveProperty->setIcon(QIcon(QLatin1String(":/images/16x16/remove.png")));
propertiesdock.cpp:    mActionRenameProperty->setEnabled(false);
propertiesdock.cpp:    mActionRenameProperty->setIcon(QIcon(QLatin1String(":/images/16x16/rename.png")));
propertiesdock.cpp:    toolBar->setFloatable(false);
propertiesdock.cpp:    toolBar->setMovable(false);
propertiesdock.cpp:    toolBar->setIconSize(QSize(16, 16));
propertiesdock.cpp:    toolBar->addAction(mActionAddProperty);
propertiesdock.cpp:    toolBar->addAction(mActionRemoveProperty);
propertiesdock.cpp:    toolBar->addAction(mActionRenameProperty);
propertiesdock.cpp:    layout->setMargin(5);
propertiesdock.cpp:    layout->setSpacing(0);
propertiesdock.cpp:    layout->addWidget(mPropertyBrowser);
propertiesdock.cpp:    layout->addWidget(toolBar);
propertiesdock.cpp:    widget->setLayout(layout);
propertiesdock.cpp:    mPropertyBrowser->setFocus();
propertiesdock.cpp:        mMapDocument->disconnect(this);
propertiesdock.cpp:    mPropertyBrowser->setMapDocument(mapDocument);
propertiesdock.cpp:        currentObjectChanged(mapDocument->currentObject());
propertiesdock.cpp:    switch (object->typeId()) {
propertiesdock.cpp:        return static_cast<const Tileset*>(object)->isExternal();
propertiesdock.cpp:        return static_cast<const Tile*>(object)->tileset()->isExternal();
propertiesdock.cpp:        return static_cast<const Terrain*>(object)->tileset()->isExternal();
propertiesdock.cpp:    mPropertyBrowser->setObject(object);
propertiesdock.cpp:    mPropertyBrowser->setEnabled(enabled);
propertiesdock.cpp:    mActionAddProperty->setEnabled(enabled);
propertiesdock.cpp:    bool isCustomProperty = mPropertyBrowser->isCustomPropertyItem(item);
propertiesdock.cpp:    bool external = isExternal(mPropertyBrowser->object());
propertiesdock.cpp:    mActionRemoveProperty->setEnabled(isCustomProperty && !external);
propertiesdock.cpp:    mActionRenameProperty->setEnabled(isCustomProperty && !external);
propertiesdock.cpp:    Object *object = mMapDocument->currentObject();
propertiesdock.cpp:    switch (object->typeId()) {
propertiesdock.cpp:        update = static_cast<Tile*>(object)->tileset() == tileset;
propertiesdock.cpp:        update = static_cast<Terrain*>(object)->tileset() == tileset;
propertiesdock.cpp:        currentItemChanged(mPropertyBrowser->currentItem());
propertiesdock.cpp:    dialog->setInputMode(QInputDialog::TextInput);
propertiesdock.cpp:    dialog->setLabelText(tr("Name:"));
propertiesdock.cpp:    dialog->setWindowTitle(tr("Add Property"));
propertiesdock.cpp:    dialog->open(this, SLOT(addProperty(QString)));
propertiesdock.cpp:    Object *object = mMapDocument->currentObject();
propertiesdock.cpp:    if (!object->hasProperty(name)) {
propertiesdock.cpp:        QUndoStack *undoStack = mMapDocument->undoStack();
propertiesdock.cpp:        undoStack->push(new SetProperty(mMapDocument, mMapDocument->currentObjects(), name, QString()));
propertiesdock.cpp:    mPropertyBrowser->editCustomProperty(name);
propertiesdock.cpp:    QtBrowserItem *item = mPropertyBrowser->currentItem();
propertiesdock.cpp:    Object *object = mMapDocument->currentObject();
propertiesdock.cpp:    const QString name = item->property()->propertyName();
propertiesdock.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
propertiesdock.cpp:    QList<QtBrowserItem *> items = item->parent()->children();
propertiesdock.cpp:            mPropertyBrowser->setCurrentItem(items.at(currentItemIndex - 1));
propertiesdock.cpp:            mPropertyBrowser->setCurrentItem(items.at(currentItemIndex + 1));
propertiesdock.cpp:    undoStack->push(new RemoveProperty(mMapDocument, mMapDocument->currentObjects(), name));
propertiesdock.cpp:    QtBrowserItem *item = mPropertyBrowser->currentItem();
propertiesdock.cpp:    const QString oldName = item->property()->propertyName();
propertiesdock.cpp:    dialog->setInputMode(QInputDialog::TextInput);
propertiesdock.cpp:    dialog->setLabelText(tr("Name:"));
propertiesdock.cpp:    dialog->setTextValue(oldName);
propertiesdock.cpp:    dialog->setWindowTitle(tr("Rename Property"));
propertiesdock.cpp:    dialog->open(this, SLOT(renameProperty(QString)));
propertiesdock.cpp:    QtBrowserItem *item = mPropertyBrowser->currentItem();
propertiesdock.cpp:    const QString oldName = item->property()->propertyName();
propertiesdock.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
propertiesdock.cpp:    undoStack->push(new RenameProperty(mMapDocument, mMapDocument->currentObjects(), oldName, name));
propertiesdock.cpp:    switch (event->type()) {
propertiesdock.cpp:        if (keyEvent->matches(QKeySequence::Delete) || keyEvent->key() == Qt::Key_Backspace) {
propertiesdock.cpp:            if (event->type() == QEvent::KeyPress)
propertiesdock.cpp:            event->accept();
propertiesdock.cpp:    mActionAddProperty->setText(tr("Add Property"));
propertiesdock.cpp:    mActionRemoveProperty->setText(tr("Remove Property"));
propertiesdock.cpp:    mActionRenameProperty->setText(tr("Rename Property"));
moc_mapscene.cpp:        - idx * sizeof(QByteArrayData) \
moc_mapscene.cpp:        case 0: _t->selectedObjectItemsChanged(); break;
moc_mapscene.cpp:        case 1: _t->setGridVisible((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 2: _t->setObjectLineWidth((*reinterpret_cast< qreal(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 3: _t->setShowTileObjectOutlines((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 4: _t->setHighlightCurrentLayer((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 5: _t->refreshScene(); break;
moc_mapscene.cpp:        case 6: _t->repaintRegion((*reinterpret_cast< const QRegion(*)>(_a[1])),(*reinterpret_cast< Layer*(*)>(_a[2]))); break;
moc_mapscene.cpp:        case 7: _t->currentLayerIndexChanged(); break;
moc_mapscene.cpp:        case 8: _t->mapChanged(); break;
moc_mapscene.cpp:        case 9: _t->tilesetChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 10: _t->tileLayerDrawMarginsChanged((*reinterpret_cast< TileLayer*(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 11: _t->layerAdded((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 12: _t->layerRemoved((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 13: _t->layerChanged((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 14: _t->objectGroupChanged((*reinterpret_cast< ObjectGroup*(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 15: _t->imageLayerChanged((*reinterpret_cast< ImageLayer*(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 16: _t->tilesetTileOffsetChanged((*reinterpret_cast< Tileset*(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 17: _t->objectsInserted((*reinterpret_cast< ObjectGroup*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_mapscene.cpp:        case 18: _t->objectsRemoved((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 19: _t->objectsChanged((*reinterpret_cast< const QList<MapObject*>(*)>(_a[1]))); break;
moc_mapscene.cpp:        case 20: _t->objectsIndexChanged((*reinterpret_cast< ObjectGroup*(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2])),(*reinterpret_cast< int(*)>(_a[3]))); break;
moc_mapscene.cpp:        case 21: _t->updateSelectedObjectItems(); break;
moc_mapscene.cpp:        case 22: _t->syncAllObjectItems(); break;
moc_mapscene.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_mapscene.cpp:        _id -= 23;
moc_mapscene.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_mapscene.cpp:        _id -= 23;
tileanimationeditor.cpp:        if (Tile *tile = mTileset->tileAt(tileId))
tileanimationeditor.cpp:            return tile->image();
tileanimationeditor.cpp:            beginRemoveRows(parent, row, row + count - 1);
tileanimationeditor.cpp:    mimeData->setData(QLatin1String(FRAMES_MIMETYPE), encodedData);
tileanimationeditor.cpp:    if (row != -1)
tileanimationeditor.cpp:    if (data->hasFormat(QLatin1String(FRAMES_MIMETYPE))) {
tileanimationeditor.cpp:        QByteArray encodedData = data->data(QLatin1String(FRAMES_MIMETYPE));
tileanimationeditor.cpp:    } else if (data->hasFormat(QLatin1String(TILES_MIMETYPE))) {
tileanimationeditor.cpp:        QByteArray encodedData = data->data(QLatin1String(TILES_MIMETYPE));
tileanimationeditor.cpp:    beginInsertRows(QModelIndex(), beginRow, beginRow + newFrames.size() - 1);
tileanimationeditor.cpp:    mUi->setupUi(this);
tileanimationeditor.cpp:    zoomable->connectToComboBox(mUi->zoomComboBox);
tileanimationeditor.cpp:    mUi->frameList->setModel(mFrameListModel);
tileanimationeditor.cpp:    mUi->tilesetView->setMarkAnimatedTiles(false);
tileanimationeditor.cpp:    mUi->tilesetView->setZoomable(zoomable);
tileanimationeditor.cpp:    connect(mUi->tilesetView, SIGNAL(doubleClicked(QModelIndex)),
tileanimationeditor.cpp:    mUi->horizontalSplitter->setSizes(QList<int>() << 128 << 512);
tileanimationeditor.cpp:        mMapDocument->disconnect(this);
tileanimationeditor.cpp:    mUi->tilesetView->setMapDocument(mapDocument);
tileanimationeditor.cpp:    delete mUi->tilesetView->model();
tileanimationeditor.cpp:        mFrameListModel->setFrames(tile->tileset(), tile->frames());
tileanimationeditor.cpp:        TilesetModel *tilesetModel = new TilesetModel(tile->tileset(),
tileanimationeditor.cpp:                                                      mUi->tilesetView);
tileanimationeditor.cpp:        mUi->tilesetView->setModel(tilesetModel);
tileanimationeditor.cpp:        mFrameListModel->setFrames(nullptr, QVector<Frame>());
tileanimationeditor.cpp:    mUi->frameList->setEnabled(tile && !tile->tileset()->isExternal());
tileanimationeditor.cpp:    if (event->isAccepted())
tileanimationeditor.cpp:    switch (e->type()) {
tileanimationeditor.cpp:        mUi->retranslateUi(this);
tileanimationeditor.cpp:    mPreviewAnimationDriver->start();
tileanimationeditor.cpp:    mPreviewAnimationDriver->stop();
tileanimationeditor.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
tileanimationeditor.cpp:    undoStack->push(new ChangeTileAnimation(mMapDocument,
tileanimationeditor.cpp:                                            mFrameListModel->frames()));
tileanimationeditor.cpp:    mFrameListModel->setFrames(tile->tileset(), tile->frames());
tileanimationeditor.cpp:    if (mTile && mTile->tileset() == tileset)
tileanimationeditor.cpp:        mUi->frameList->setEnabled(!tileset->isExternal());
tileanimationeditor.cpp:    if (object && object->typeId() == Object::MapObjectType) {
tileanimationeditor.cpp:        const Cell &cell = static_cast<MapObject*>(object)->cell();
tileanimationeditor.cpp:    if (mTile->tileset()->isExternal())
tileanimationeditor.cpp:    const Tile *tile = mUi->tilesetView->tilesetModel()->tileAt(index);
tileanimationeditor.cpp:    mFrameListModel->addTileIdAsFrame(tile->id());
tileanimationeditor.cpp:        mMapDocument->undoStack()->undo();
tileanimationeditor.cpp:        mMapDocument->undoStack()->redo();
tileanimationeditor.cpp:    if (mTile->tileset()->isExternal())
tileanimationeditor.cpp:    QItemSelectionModel *selectionModel = mUi->frameList->selectionModel();
tileanimationeditor.cpp:    const QModelIndexList indexes = selectionModel->selectedIndexes();
tileanimationeditor.cpp:    QUndoStack *undoStack = mMapDocument->undoStack();
tileanimationeditor.cpp:    undoStack->beginMacro(tr("Delete Frames"));
tileanimationeditor.cpp:        --it;
tileanimationeditor.cpp:        mFrameListModel->removeRows(it.first(), it.length(), QModelIndex());
tileanimationeditor.cpp:    undoStack->endMacro();
tileanimationeditor.cpp:    if (!mTile || !mTile->isAnimated())
tileanimationeditor.cpp:    const QVector<Frame> &frames = mTile->frames();
tileanimationeditor.cpp:        mPreviewUnusedTime -= frame.duration;
tileanimationeditor.cpp:        if (const Tile *tile = mTile->tileset()->tileAt(frame.tileId))
tileanimationeditor.cpp:            mUi->preview->setPixmap(tile->image());
tileanimationeditor.cpp:    if (mTile && mTile->isAnimated()) {
tileanimationeditor.cpp:        const int tileId = mTile->frames().first().tileId;
tileanimationeditor.cpp:        if (const Tile *tile = mTile->tileset()->tileAt(tileId)) {
tileanimationeditor.cpp:            mUi->preview->setPixmap(tile->image());
tileanimationeditor.cpp:    mUi->preview->setText(QApplication::translate("TileAnimationEditor",
moc_mainwindow.cpp:        - idx * sizeof(QByteArrayData) \
moc_mainwindow.cpp:        case 0: { bool _r = _t->openFile((*reinterpret_cast< const QString(*)>(_a[1])));
moc_mainwindow.cpp:        case 1: _t->newMap(); break;
moc_mainwindow.cpp:        case 2: _t->openFile(); break;
moc_mainwindow.cpp:        case 3: { bool _r = _t->saveFile();
moc_mainwindow.cpp:        case 4: { bool _r = _t->saveFileAs();
moc_mainwindow.cpp:        case 5: _t->saveAll(); break;
moc_mainwindow.cpp:        case 6: _t->export_(); break;
moc_mainwindow.cpp:        case 7: _t->exportAs(); break;
moc_mainwindow.cpp:        case 8: _t->exportAsImage(); break;
moc_mainwindow.cpp:        case 9: _t->reload(); break;
moc_mainwindow.cpp:        case 10: _t->closeFile(); break;
moc_mainwindow.cpp:        case 11: _t->closeAllFiles(); break;
moc_mainwindow.cpp:        case 12: _t->cut(); break;
moc_mainwindow.cpp:        case 13: _t->copy(); break;
moc_mainwindow.cpp:        case 14: _t->paste(); break;
moc_mainwindow.cpp:        case 15: _t->delete_(); break;
moc_mainwindow.cpp:        case 16: _t->openPreferences(); break;
moc_mainwindow.cpp:        case 17: _t->labelVisibilityActionTriggered((*reinterpret_cast< QAction*(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 18: _t->zoomIn(); break;
moc_mainwindow.cpp:        case 19: _t->zoomOut(); break;
moc_mainwindow.cpp:        case 20: _t->zoomNormal(); break;
moc_mainwindow.cpp:        case 21: { bool _r = _t->newTileset((*reinterpret_cast< const QString(*)>(_a[1])));
moc_mainwindow.cpp:        case 22: { bool _r = _t->newTileset();
moc_mainwindow.cpp:        case 23: _t->newTilesets((*reinterpret_cast< const QStringList(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 24: _t->reloadTilesets(); break;
moc_mainwindow.cpp:        case 25: _t->addExternalTileset(); break;
moc_mainwindow.cpp:        case 26: _t->resizeMap(); break;
moc_mainwindow.cpp:        case 27: _t->offsetMap(); break;
moc_mainwindow.cpp:        case 28: _t->editMapProperties(); break;
moc_mainwindow.cpp:        case 29: { bool _r = _t->selectAllTiles();
moc_mainwindow.cpp:        case 30: _t->updateWindowTitle(); break;
moc_mainwindow.cpp:        case 31: _t->updateActions(); break;
moc_mainwindow.cpp:        case 32: _t->updateZoomLabel(); break;
moc_mainwindow.cpp:        case 33: _t->openDocumentation(); break;
moc_mainwindow.cpp:        case 34: _t->becomePatron(); break;
moc_mainwindow.cpp:        case 35: _t->aboutTiled(); break;
moc_mainwindow.cpp:        case 36: _t->openRecentFile(); break;
moc_mainwindow.cpp:        case 37: _t->clearRecentFiles(); break;
moc_mainwindow.cpp:        case 38: _t->flipHorizontally(); break;
moc_mainwindow.cpp:        case 39: _t->flipVertically(); break;
moc_mainwindow.cpp:        case 40: _t->rotateLeft(); break;
moc_mainwindow.cpp:        case 41: _t->rotateRight(); break;
moc_mainwindow.cpp:        case 42: _t->flip((*reinterpret_cast< FlipDirection(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 43: _t->rotate((*reinterpret_cast< RotateDirection(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 44: _t->setStamp((*reinterpret_cast< const TileStamp(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 45: _t->setTerrainBrush((*reinterpret_cast< const Terrain*(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 46: _t->updateStatusInfoLabel((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 47: _t->mapDocumentChanged((*reinterpret_cast< MapDocument*(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 48: _t->closeMapDocument((*reinterpret_cast< int(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 49: _t->reloadError((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 50: _t->autoMappingError((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 51: _t->autoMappingWarning((*reinterpret_cast< bool(*)>(_a[1]))); break;
moc_mainwindow.cpp:        case 52: _t->onAnimationEditorClosed(); break;
moc_mainwindow.cpp:        case 53: _t->onCollisionEditorClosed(); break;
moc_mainwindow.cpp:        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
moc_mainwindow.cpp:            default: *reinterpret_cast<int*>(_a[0]) = -1; break;
moc_mainwindow.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_mainwindow.cpp:        _id -= 54;
moc_mainwindow.cpp:        _id -= 54;
moc_filesystemwatcher.cpp:        - idx * sizeof(QByteArrayData) \
moc_filesystemwatcher.cpp:        case 0: _t->fileChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_filesystemwatcher.cpp:        case 1: _t->directoryChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_filesystemwatcher.cpp:        case 2: _t->onFileChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_filesystemwatcher.cpp:        case 3: _t->onDirectoryChanged((*reinterpret_cast< const QString(*)>(_a[1]))); break;
moc_filesystemwatcher.cpp:    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
moc_filesystemwatcher.cpp:        _id -= 4;
moc_filesystemwatcher.cpp:            *reinterpret_cast<int*>(_a[0]) = -1;
moc_filesystemwatcher.cpp:        _id -= 4;
tilesetmanager.cpp: * Copyright 2008-2014, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
tilesetmanager.cpp:        if (tileset->fileName() == fileName)
tilesetmanager.cpp:        if (tileset->imageSource() == spec.imageSource
tilesetmanager.cpp:            && tileset->tileWidth() == spec.tileWidth
tilesetmanager.cpp:            && tileset->tileHeight() == spec.tileHeight
tilesetmanager.cpp:            && tileset->tileSpacing() == spec.tileSpacing
tilesetmanager.cpp:            && tileset->margin() == spec.margin)
tilesetmanager.cpp:        if (!tileset->imageSource().isEmpty())
tilesetmanager.cpp:            mWatcher->addPath(tileset->imageSource());
tilesetmanager.cpp:    mTilesets[tileset]--;
tilesetmanager.cpp:        if (!tileset->imageSource().isEmpty())
tilesetmanager.cpp:            mWatcher->removePath(tileset->imageSource());
tilesetmanager.cpp:    QString fileName = tileset->imageSource();
tilesetmanager.cpp:    if (tileset->loadFromImage(fileName))
tilesetmanager.cpp:        mAnimationDriver->start();
tilesetmanager.cpp:        mAnimationDriver->stop();
tilesetmanager.cpp:    return mAnimationDriver->state() == QAbstractAnimation::Running;
tilesetmanager.cpp:     * Use a one-shot timer since GIMP (for example) seems to generate many
tilesetmanager.cpp:        QString fileName = tileset->imageSource();
tilesetmanager.cpp:            if (tileset->loadFromImage(fileName))
tilesetmanager.cpp:        foreach (Tile *tile, tileset->tiles())
tilesetmanager.cpp:            imageChanged |= tile->advanceAnimation(ms);
mapobjectitem.h: * Copyright 2008-2011, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file magicwandtool.o matches
tilesetmodel.h: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
Binary file changeimagelayerproperties.o matches
imagelayeritem.cpp: * Copyright 2008-2009, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
imagelayeritem.cpp:    setOpacity(mLayer->opacity());
imagelayeritem.cpp:    mBoundingRect = mMapDocument->renderer()->boundingRect(mLayer);
imagelayeritem.cpp:    MapRenderer *renderer = mMapDocument->renderer();
imagelayeritem.cpp:    renderer->drawImageLayer(painter, mLayer, option->exposedRect);
ui_editterraindialog.h:        if (EditTerrainDialog->objectName().isEmpty())
ui_editterraindialog.h:            EditTerrainDialog->setObjectName(QStringLiteral("EditTerrainDialog"));
ui_editterraindialog.h:        EditTerrainDialog->resize(615, 372);
ui_editterraindialog.h:        verticalLayout_2->setObjectName(QStringLiteral("verticalLayout_2"));
ui_editterraindialog.h:        horizontalLayout_3->setObjectName(QStringLiteral("horizontalLayout_3"));
ui_editterraindialog.h:        undo->setObjectName(QStringLiteral("undo"));
ui_editterraindialog.h:        undo->setEnabled(false);
ui_editterraindialog.h:        icon.addFile(QStringLiteral(":/images/24x24/edit-undo.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_editterraindialog.h:        undo->setIcon(icon);
ui_editterraindialog.h:        undo->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
ui_editterraindialog.h:        undo->setAutoRaise(true);
ui_editterraindialog.h:        horizontalLayout_3->addWidget(undo);
ui_editterraindialog.h:        redo->setObjectName(QStringLiteral("redo"));
ui_editterraindialog.h:        redo->setEnabled(false);
ui_editterraindialog.h:        icon1.addFile(QStringLiteral(":/images/24x24/edit-redo.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_editterraindialog.h:        redo->setIcon(icon1);
ui_editterraindialog.h:        redo->setAutoRaise(true);
ui_editterraindialog.h:        horizontalLayout_3->addWidget(redo);
ui_editterraindialog.h:        eraseTerrain->setObjectName(QStringLiteral("eraseTerrain"));
ui_editterraindialog.h:        icon2.addFile(QStringLiteral(":/images/22x22/stock-tool-eraser.png"), QSize(), QIcon::Normal, QIcon::Off);
ui_editterraindialog.h:        eraseTerrain->setIcon(icon2);
ui_editterraindialog.h:        eraseTerrain->setCheckable(true);
ui_editterraindialog.h:        eraseTerrain->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
ui_editterraindialog.h:        eraseTerrain->setAutoRaise(true);
ui_editterraindialog.h:        horizontalLayout_3->addWidget(eraseTerrain);
ui_editterraindialog.h:        horizontalLayout_3->addItem(horizontalSpacer_2);
ui_editterraindialog.h:        zoomComboBox->setObjectName(QStringLiteral("zoomComboBox"));
ui_editterraindialog.h:        horizontalLayout_3->addWidget(zoomComboBox);
ui_editterraindialog.h:        verticalLayout_2->addLayout(horizontalLayout_3);
ui_editterraindialog.h:        horizontalLayout_2->setObjectName(QStringLiteral("horizontalLayout_2"));
ui_editterraindialog.h:        verticalLayout->setObjectName(QStringLiteral("verticalLayout"));
ui_editterraindialog.h:        terrainList->setObjectName(QStringLiteral("terrainList"));
ui_editterraindialog.h:        terrainList->setMaximumSize(QSize(200, 16777215));
ui_editterraindialog.h:        terrainList->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
ui_editterraindialog.h:        terrainList->setIndentation(0);
ui_editterraindialog.h:        terrainList->setRootIsDecorated(false);
ui_editterraindialog.h:        terrainList->setItemsExpandable(false);
ui_editterraindialog.h:        terrainList->header()->setVisible(false);
ui_editterraindialog.h:        verticalLayout->addWidget(terrainList);
ui_editterraindialog.h:        horizontalLayout_2->addLayout(verticalLayout);
ui_editterraindialog.h:        tilesetView->setObjectName(QStringLiteral("tilesetView"));
ui_editterraindialog.h:        sizePolicy.setHeightForWidth(tilesetView->sizePolicy().hasHeightForWidth());
ui_editterraindialog.h:        tilesetView->setSizePolicy(sizePolicy);
ui_editterraindialog.h:        tilesetView->setMinimumSize(QSize(200, 0));
ui_editterraindialog.h:        horizontalLayout_2->addWidget(tilesetView);
ui_editterraindialog.h:        verticalLayout_2->addLayout(horizontalLayout_2);
ui_editterraindialog.h:        horizontalLayout->setObjectName(QStringLiteral("horizontalLayout"));
ui_editterraindialog.h:        addTerrainTypeButton->setObjectName(QStringLiteral("addTerrainTypeButton"));
ui_editterraindialog.h:        addTerrainTypeButton->setIcon(icon3);
ui_editterraindialog.h:        addTerrainTypeButton->setAutoRaise(true);
ui_editterraindialog.h:        horizontalLayout->addWidget(addTerrainTypeButton);
ui_editterraindialog.h:        removeTerrainTypeButton->setObjectName(QStringLiteral("removeTerrainTypeButton"));
ui_editterraindialog.h:        removeTerrainTypeButton->setEnabled(false);
ui_editterraindialog.h:        removeTerrainTypeButton->setIcon(icon4);
ui_editterraindialog.h:        removeTerrainTypeButton->setAutoRaise(true);
ui_editterraindialog.h:        horizontalLayout->addWidget(removeTerrainTypeButton);
ui_editterraindialog.h:        horizontalLayout->addItem(horizontalSpacer);
ui_editterraindialog.h:        verticalLayout_2->addLayout(horizontalLayout);
ui_editterraindialog.h:        buttonBox->setObjectName(QStringLiteral("buttonBox"));
ui_editterraindialog.h:        buttonBox->setOrientation(Qt::Horizontal);
ui_editterraindialog.h:        buttonBox->setStandardButtons(QDialogButtonBox::Close);
ui_editterraindialog.h:        verticalLayout_2->addWidget(buttonBox);
ui_editterraindialog.h:        EditTerrainDialog->setWindowTitle(QApplication::translate("EditTerrainDialog", "Edit Terrain Information", 0));
ui_editterraindialog.h:        undo->setToolTip(QApplication::translate("EditTerrainDialog", "Undo", 0));
ui_editterraindialog.h:        undo->setText(QApplication::translate("EditTerrainDialog", "Undo", 0));
ui_editterraindialog.h:        redo->setToolTip(QApplication::translate("EditTerrainDialog", "Redo", 0));
ui_editterraindialog.h:        redo->setText(QApplication::translate("EditTerrainDialog", "Redo", 0));
ui_editterraindialog.h:        eraseTerrain->setText(QApplication::translate("EditTerrainDialog", "Erase", 0));
ui_editterraindialog.h:        addTerrainTypeButton->setToolTip(QApplication::translate("EditTerrainDialog", "Add Terrain Type", 0));
ui_editterraindialog.h:        addTerrainTypeButton->setText(QApplication::translate("EditTerrainDialog", "Add", 0));
ui_editterraindialog.h:        removeTerrainTypeButton->setToolTip(QApplication::translate("EditTerrainDialog", "Remove Terrain Type", 0));
ui_editterraindialog.h:        removeTerrainTypeButton->setText(QApplication::translate("EditTerrainDialog", "Remove", 0));
terraindock.cpp: * Copyright 2008-2012, Thorbj√∏rn Lindeijer <thorbjorn@lindeijer.nl>
terraindock.cpp:        const QModelIndex index = model->index(sourceRow, 0, sourceParent);
terraindock.cpp:        return index.isValid() && model->hasChildren(index);
terraindock.cpp:    mTerrainView->setModel(mProxyModel);
terraindock.cpp:    connect(mTerrainView->selectionModel(),
terraindock.cpp:    horizontal->setSpacing(5);
terraindock.cpp:    horizontal->setMargin(5);
terraindock.cpp:    horizontal->addWidget(mTerrainView);
terraindock.cpp:        mMapDocument->disconnect(this);
terraindock.cpp:        mTerrainView->setMapDocument(mMapDocument);
terraindock.cpp:        mProxyModel->setSourceModel(mMapDocument->terrainModel());
terraindock.cpp:        mTerrainView->expandAll();
terraindock.cpp:        mProxyModel->setSourceModel(0);
terraindock.cpp:    switch (e->type()) {
terraindock.cpp:    if (Terrain *terrain = mTerrainView->terrainAt(index))
terraindock.cpp:    if (Terrain *terrain = mTerrainView->terrainAt(index))
terraindock.cpp:        mMapDocument->setCurrentObject(terrain);
terraindock.cpp:        mTerrainView->expand(mProxyModel->index(row, 0, parent));
terraindock.cpp:        mMapDocument->setCurrentObject(terrain);
randompicker.h:            return (mThresholds.end() - 1).value();
exportasimagedialog.ui:<?xml version="1.0" encoding="UTF-8"?>
